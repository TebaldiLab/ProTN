---
author: "Gabriele Tomè, Toma Tebaldi"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  rmdformats::readthedown:
    css: custom_theme_report.css
    df_print: paged
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: true
params:
  doc_title: "Report of integrative pipeline for proteomics analysis"
  description: NA
  readPD_files: NA
  readMQ_files: NA
  file_input: NA
  file_prot: NA
  file_pep: NA
  filt_absent_value: "0"
  pval_fdr: NA
  signal_thr: "inf"
  fc_thr: "0.75"
  pval_thr: "0.05"
  batch_corr_exe: NA
  contr_design: NA
  prot_boxplot: NA
  run_enrich: NA
  run_enrich_universe: NA
  run_STRING: NA
  pval_fdr_enrich: NA
  pval_enrich_thr: "0.05"
  overlap_size_enrich_thr: 5
  enrich_filter_term: NA
  enrich_filter_DBs: NA
  enrichR_DB: NA
  dirOutput: NA
---

<!--############################################################################
# ProTN: an integrative pipeline for complete analysis of proteomics           # 
# data from mass spectrometry                                                  #
# Laboratory of RNA and Disease Data Science, University of Trento             #
# Developer: Gabriele Tomè                                                     #
# Issue at: https://github.com/TebaldiLab/ProTN/issues                         #
# PI: Dr. Toma Tebaldi, PhD                                                    #
#############################################################################-->

```{r settings, message=F, warning=F, echo=F,results='hide'}
shiny::setProgress(0, detail = "Initialize...")  # set progress to 50%

dirOutput = params$dirOutput
#Auto-install needed library
list.of.packages <- c("ggrepel","tidyr","ggraph","graphlayouts","RColorBrewer",
                      "scales","igraph","data.table","qpdf","devtools",
                      "corrplot", "data.table", "ggplot2", "ggfortify","lazyeval",
                      "lubridate", "pheatmap", "reshape2","readr", "rlang", "rmdformats",
                      "tibble", "dplyr", "tidyr", "wesanderson","WGCNA","ggbeeswarm","ggthemes", 
                      "magick", "pdftools", "plotly", "svgPanZoom", "enrichR")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) suppressMessages(suppressWarnings({install.packages(new.packages, dependencies = T)}))
list.of.packages.bio <- c("biomaRt","DEqMS","STRINGdb",
                          "GO.db", "impute", "preprocessCore", "pvca","sva")
new.packages <- list.of.packages.bio[!(list.of.packages.bio %in% installed.packages()[,"Package"])]
if(length(new.packages)) {
  if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  suppressMessages(suppressWarnings({BiocManager::install(new.packages)}))
}
list.of.packages <- c("proBatch", "PhosR")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) {
  suppressMessages(suppressWarnings({devtools::install_github("symbioticMe/proBatch", dependencies = T)}))
  suppressMessages(suppressWarnings({devtools::install_github("PYangLab/PhosR", dependencies = T)}))
}

#Load functions
suppressMessages(suppressWarnings({
  source("functions_2021.R") # new functions 2021
  #Library needed
  library('biomaRt')
  library('PhosR')
  library('DEqMS')
  library(ggrepel) # graphics
  library(tidyr)
  library(dplyr)
  library(tibble)
  library(ggraph)
  library(graphlayouts)
  library(RColorBrewer) # Color palettes
  library(scales) # heatmap colors scales
  library(igraph) # Network analysis
  library(data.table)
  library(qpdf)
  library(STRINGdb)
  library("proBatch")
  library(ggbeeswarm)
  library(parallel)
  library(readr)
  library(stringi)
  library(stringr)
  library(pdftools)
  library(magick)
  library(extrafont)
  library(plotly)
  library(knitr)
}))

options(dplyr.summarise.inform = FALSE)

#Set font and size
loadfonts(quiet=T)
bs<-11      # point sizes in ggplot
bf<-"Arial" # font family in ggplot

# Color definition
color_base<-c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A","#FF7F00",
              "black", "gold1", "skyblue2", "#FB9A99", "palegreen2","#CAB2D6", "#FDBF6F",
              "#9af7c9","#c0a0e6","#f5939a","#5fefee","#e8d388","#8abdff","#e3bf7a","#48c0f6","#ccb86f","#fafeaf",
              "#04bfe4","#ea92a8","#25cfe9","#ffbb97","#62e8ff","#ffd29b","#8fcbff","#aec87f","#b2c6ff","#aedf9b",
              "#ffb3c8","#81b97c","#ffcef0","#54bcae","#ffcab3","#7dd7ff","#ffe4ad","#81b0da","#ebffc5","#a7a8d5",
              "#bdffd0","#d6d2ff","#9fb282","#a5d8ff","#c9a395","#9bfff7","#ffcbce","#70b6ca","#faffdd","#88b3bc",
              "#d6ffdf","#a3e5ff","#b1ac8f","#ccffff","#b4bb9f","#7eb7a5","#c5dbc3","#a8b9ff","#74dfbc","#f2ace7")
colour_vec<-color_base

#Variables with names of subdir
subfold_Fig <- "figures/"
subfold_Dat <- "data/"
subfold_Tab <- "tables/"
subfold_MDSPCA <- "PCA_MDS/"
subfold_expr <- "Expression/"
subfold_enrich <- "Enrichment/"
subfold_net <- "Network/"

shiny::setProgress(0.01, detail = "Initialize...")  # set progress to 50%
```

```{r load_settings, warning=FALSE, echo=F, message=FALSE, results='hide'}
message("Reading options")
# #Read title and description
description<-params$description
#Read Platform of previuos quantification
readPD_files <- params$readPD_files
readMQ_files <- params$readMQ_files
#Read input directory
filenames<-list(params$file_input, params$file_pep, params$file_prot)
filt_absent_value=suppressWarnings(parse_double(params$filt_absent_value))
if(is.na(filt_absent_value)){
  message("Warning: parse error for the number of acceptable missing condition. Set default paramenter to 0\n")
  filt_absent_value <- 0
}
#Read input parameters for Limma
signal_thr=suppressWarnings(parse_double(params$signal_thr))
if(is.na(signal_thr)){signal_thr<- -Inf}
fc_thr=suppressWarnings(parse_double(params$fc_thr))
if(is.na(fc_thr)){
  message("Warning: parse error for Fold Change threshold. Set default paramenter to 0.75\n")
  fc_thr <- 0.75
}
pval_thr=suppressWarnings(parse_double(params$pval_thr))
if(is.na(pval_thr)){
  message("Warning: parse error for P.Value threshold. Set default paramenter to 5%\n")
  pval_thr <- 0.05
}
batch_corr_exe<-as.logical(params$batch_corr_exe)

message(params$contr_design)
#Read the design
input_settings<-read_excel_allsheets(params$contr_design)[[1]]
contr_design<-data.frame(t(input_settings[1:nrow(input_settings),]))
contr_design<-data.frame(contr_design[,colSums(is.na(contr_design)) != nrow(contr_design) ])
if(ncol(contr_design) > 0){
  if(any(is.na(contr_design[3,]))){
    contr_design[3,]<-color_base[1:ncol(contr_design)]
  }
  contr_design<-data.frame(t(fill(contr_design, names(contr_design), .direction = "down")))
  contr_design[,2]<-unlist(lapply(contr_design[,2], function(x){ if("-" %in% x){str_replace_all(x,"-","_")}else{x}}))
  formule_contrast<-(contr_design[,1])
  names(formule_contrast)<-contr_design[,2]
  color_constrast<-contr_design[,3]
  names(color_constrast)<-contr_design[,2]
  
  darker.col = function(color, how.much = 50){
    colorRampPalette(c(color, "black"))(100)[how.much]
  }
  color_constrast_dark<-c()
  for(col in names(color_constrast)){
    color_constrast_dark[col]<-darker.col(color_constrast[col])
  }
  color_constrast<-cbind(color_constrast,color_constrast_dark)
}else{
  stop("Error: At least one contrast design is required for the analysis.")
}

#Read Proteins List for control boxplot
prot_boxplot<-na.omit(strsplit(params$prot_boxplot, split = "\\;|\\,|\\ |\\; |\\, ")[[1]])
boxplot_prot_exe <- FALSE
if(length(prot_boxplot)>0){ boxplot_prot_exe<-TRUE }
#Read enrich parameter
doNextChunk_STRING <- doNextChunk <- run_enrich <- run_STRING <- run_enrich_universe <- pval_fdr <- enrichR_DB <- FALSE
pval_fdr_enrich <- TRUE
pval_fdr <- as.logical(params$pval_fdr)
pval_fdr_enrich <- as.logical(params$pval_fdr_enrich)
run_enrich <- as.logical(params$run_enrich)
run_enrich_universe <- as.logical(params$run_enrich_universe)
enrichR_DB <- as.logical(params$enrichR_DB)
run_STRING <- as.logical(params$run_STRING)

pval_enrich_thr <- if(is.null(params$pval_enrich_thr)){0.05
}else if(is.double(params$pval_enrich_thr)){params$pval_enrich_thr
}else{parse_double(params$pval_enrich_thr)}
if(is.na(pval_enrich_thr)){
  message("Warning: parse error for p-value enrichment threshold. Set default paramenter to 0.05\n")
  pval_enrich_thr <- 0.05
}
overlap_size_enrich_thr=if(is.null(params$overlap_size_enrich_thr)){5
}else if(is.integer(params$overlap_size_enrich_thr)){params$overlap_size_enrich_thr
}else{parse_double(params$overlap_size_enrich_thr)}
if(is.na(overlap_size_enrich_thr)){
  message("Warning: parse error for Overlap size enrichment threshold. Set default paramenter to 5\n")
  overlap_size_enrich_thr <- 5
}

enrich_filter_term<-if(is.null(params$enrich_filter_term)){list()
}else if(params$enrich_filter_term == ""){list()
}else{na.omit(strsplit(params$enrich_filter_term, split = "\\;|\\,|\\; |\\, ")[[1]])}
enrich_filter_DBs<-if(is.null(params$enrich_filter_DBs)){list()
}else if(is.character(params$enrich_filter_DBs)){ na.omit(params$enrich_filter_DBs)
}else{list()}

remove(input_settings,contr_design,color_constrast_dark)
shiny::setProgress(0.05, detail = "Reading setting...")  # set progress to 50%
```


---
title: `r if(params$doc_title==""){"Report of integrative pipeline for proteomics analysis"}else{params$doc_title}`
---

`r description`

The following report summarizes the results obtained by the proTN integrative pipeline for proteomics analysis. Full results can be found in the output folder.

## Description of the output files

- [**Data** folder](Data)
  - ```protn_env.RData```: RData object containing the essential variables and data for additional analyses in R. The variables are:
    - *c_anno*: dataframe with the description of the samples;
    - *dat_gene*: dataframe with the protein normalized abundances;
    - *dat_pep*: dataframe with the peptide normalized abundances;
    - *psm_peptide_table*: descriptive dataframe of the peptides;
    - *deps_l_df*: dataframe of differential expressed proteins;
    - *deps_pep_l_df*: dataframe of differential expressed peptides;
    - *expr_avgse_df*: dataframe with average, standard error and covariance for each condition based on protein abundances;
    - *expr_avgse_pep_df*: dataframe with average, standard error and covariance for each condition based on peptide abundances;
    - *formule_contrast*: design for the differential analysis;
    - Settings: *colour_vec*: color list for the plot, *bf*: family text, *bs*: base text size; 
    - Thresholds: *fc_thr*: Fold Change threshold, *pval_thr*: P.value threshold, *pval_enrich_thr*: P.value threshold for Enrichment, *overlap_size_enrich_thr*: Overlap size threshold for enrichment.
```{r print_descr_enrich_dat, warning=FALSE, echo=F, message=FALSE, eval=run_enrich, results='asis'}
cat("  - ```enrichment_DE.RData```: RData object containing enrichment results based on differentially expressed proteins \n")
```
```{r print_descr_enrich_uni_dat, warning=FALSE, echo=F, message=FALSE, eval=run_enrich_universe, results='asis'}
cat("  - ```enrichment_allproteins.RData```: RData object containing enrichment results based on all detected proteins \n")
```

- [**Tables** folder](Tables) 
  - ```normalised_abundances.xlsx```: excel file containing abundance values generated by proTN. abundances are log2 transformed, normalized, imputed (and batch corrected). The file is organized in the following sheets:
    - **protein_per_sample**: protein abundances per sample.
    - **peptide_per_sample**: peptide abundances per sample.
    - **protein_per_condition**: protein abundances per condition (average & standard deviation), as defined in the Sample Annotation.
    - **peptide_per_condition**: peptide abundances per condition (average & standard deviation), as defined in the Sample Annotation.

  - ```differential_expression.xlsx```: excel file containing the results of differential analysis, according to the contrasts defined in the Design file. The file is organized in the following sheets:
    - **protein_DE**: protein differential expression results protein abundances per sample.
    - **peptide_DE**: peptide differential expression results.
    Annotation columns:
    - **Accession**: protein UniprotID
    - **Description**: protein description
    - **GeneName**: Gene Symbol
    - **Peptide_Sequence**: peptide sequence
    - **Peptide_Modifications**: peptide modifications
    - **Peptide_Position**: start and end position of the peptide within the protein sequence, defined UniprotID
    - **Peptide_Tryptic**: peptide tryptic digestion status (fully tryptic, N-semi tryptic, C-semi tryptic, non tryptic)
    - Columns for each contrast:
    - **class**: defined according to the fold change, p-value and abundance thresholds specified in the input
      - *+* up-regulated protein/peptide
      - *-* down-regulated protein/peptide
      - *=* invariant protein/peptide
    - **log2_FC**: protein/peptide log2 transformed fold change
    - **p_val**: protein/peptide contrast p-value
    - **p_adj**: protein/peptide adjusted p-value (FDR after BH correction)
    - **log2_expr**: protein/peptide log2 average abundance

```{r print_descr_enrich_tab, warning=FALSE, echo=F, message=FALSE, eval=run_enrich, results='asis'}
cat("  - ```enrichment_DE.xlsx```: excel file containing a selection of enrichment results starting from differentially expressed proteins. Terms are selected according to significance thresholds specified in the input (Default: adj.P.Value < 0.05, Overlap Size >= 5) \n")
```
```{r print_descr_enrich_uni_tab, warning=FALSE, echo=F, message=FALSE, eval=run_enrich_universe, results='asis'}
cat("  - ```enrichment_allproteins.xlsx```: excel file containing a selection of enrichment results starting from all the detected proteins. Terms are selected according to significance thresholds specified in the input (Default: adj.P.Value < 0.05, Overlap Size >= 5) \n")
```
- [**Figures** folder](Figures)
  - ```PCA_MDS``` directory: Directory containing (Multidimensional scaling) and PCA (Principal component analysis) plots of samples.
    - **mds_proteins.pdf**: MDS, based on protein abundances.
    - **mds_peptides.pdf**: MDS of the samples by peptides.
    - **pca_protein.pdf**: PCA of the samples by proteins.
    - **pca_peptides.pdf**: PCA of the samples by peptides.
    - **DE_mds_protein.pdf**: MDS based on differentially expressed proteins.
    - **DE_mds_peptide.pdf**: MDS based on differentially expressed peptides.
    - **DE_pca_protein.pdf**: PCA based on differentially expressed proteins.
    - **DE_pca_peptide.pdf**: PCA based on differentially expressed peptides.

  - ```Expression``` directory: Directory containing figures related to expression analyses.
```{r print_descr_control, warning=FALSE, echo=F, message=FALSE, eval=prot_boxplot, results='asis'}
cat("    - **selected_protein_plot.pdf**: plot displaying the abundances of selected proteins \n")
```
    - **DE_protein_barplot.pdf**: number of differentially expressed proteins found in each contrast.
    - **DE_peptide_barplot.pdf**: number of differentially expressed peptides found in each contrast.

```{r print_descr_enrich_fig_global, warning=FALSE, echo=F, message=FALSE, eval=run_enrich, results='asis'}
cat("  - ```Enrichment``` directory: Directory containing figures from functional annotation enrichment analysi \n")  
```
```{r print_descr_enrich_fig, warning=FALSE, echo=F, message=FALSE, eval=run_enrich&(!run_enrich_universe), results='asis'}
cat("    - **enr_updown_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins, divided in up- and down-regulated. Terms are filtered for key source datasets selected in the advanced options. \n")
cat("    - **enr_updown_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins, divided in up- and down-regulated. Terms are filtered for keywords defined in the advanced options. \n")
cat("    - **enr_DE_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins. Terms are filtered for key source datasets selected in the advanced options. \n")
cat("    - **enr_DE_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins. Terms are filtered for keywords defined in the advanced options. \n")

shiny::setProgress(0.10, detail = "Settings...")
```
```{r print_descr_enrich_uni_fig, warning=FALSE, echo=F, message=FALSE, eval=run_enrich_universe, results='asis'}
cat("      - **enr_updown_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins, divided in up- and down-regulated. Terms are filtered for key source datasets selected in the advanced options. \n")
cat("      - **enr_updown_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins, divided in up- and down-regulated. Terms are filtered for keywords defined in the advanced options. \n")
cat("    - **enr_DE_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins. Terms are filtered for key datasets selected in the advanced options. \n")
cat("    - **enr_DE_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins. Terms are filtered for keywords defined in the advanced options. \n")

shiny::setProgress(0.10, detail = "Settings...")
```
```{r print_descr_STRING, warning=FALSE, echo=F, message=FALSE, eval=run_STRING, results='asis'}
cat("  - ```Network``` directory: Directory with figures from network analysis of differentially expressed proteins, based on STRINGdb protein-protein interactions. For each contrast, two files are generated: \n")
cat("    - **communities_sizes.pdf**: histogram representing the number of protein in each network community. \n")
cat("    - **ppi_network.pdf**: network representation in two layouts: Fruchterman Reingold (*fr*) and Kamada Kawai (*kk*). \n")
```

## Summary of input parameters and thresholds

```{r print_settings, warning=FALSE, echo=F, message=FALSE, results='asis'}
cat(" \n \n")
#Print summary of filter and contrast design
if(readPD_files){
  cat("**Source files:** Proteome Discoverer")
  cat(" \n")
} else{
  cat("**Source files:** MaxQuant")
  cat(" \n")
}
cat(" \n \n")
if(batch_corr_exe){
  cat("**Pipeline** \n ")
  cat(" \n")
  cat("- Execution of batch effect correction.")
}
cat(" \n \n ")
cat("**Differential expression** \n ")
cat(" \n")
cat(paste0("- Fold Change threshold: log2_FC > ",fc_thr," (+), log2_FC < -",fc_thr," (-) "))
cat(" \n")
cat(paste0("- Statistical significance threshold: p.val < ",pval_thr," "))
cat(" \n")
if(signal_thr != -Inf){cat(paste0("- Signal log2 intesity threshold: signal > ",signal_thr," "))}
cat(" \n")
if(filt_absent_value != 0){cat(paste0("- Threshold of acceptable missing values for condition = ",filt_absent_value," "))}
cat(" \n \n ")
if(run_enrich){
  cat("**Enrichment analysis** \n ")
  cat(" \n")
  cat(paste0("- Statistical significance threshold: p.val < ",pval_enrich_thr," "))
  cat(" \n")
  cat(paste0("- Overlap size threshold for enrichment analysis: OverlapSize > ",overlap_size_enrich_thr," "))
  cat(" \n")
  if(run_enrich_universe){cat("- Execution of the enrichment also on all detected proteins.")}
  cat(" \n \n ")
}
cat(" \n \n ")
if(run_STRING){
  cat("**Network analysis** \n ")
  cat(" \n")
  cat("- Execution of PPI network analysis with STRINGdb.")
}


shiny::setProgress(0.18, detail = "Reading files...")
```


```{r load_data_from_PD, eval=readPD_files,echo=F, message=F, warning=F, results='asis'}
message("Reading files from MS...")
#Read all files in the input folder
template_files=c("Input","pep","prot")
filenames <- list("Input"=params$file_input,"prot"=params$file_prot,"pep"=params$file_pep)
input_files<-list("FILES")
for (f in template_files){
  input_files[f] <- tryCatch({
    read_excel_allsheets(filenames[f][[1]])
  }, error=function(cond){
    stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
  })
}
names(input_files)<-c("dir","Input","PEP","PROT")
message("Data acquired")


#Clean files and merge
colToKeep<-intersect(colnames(input_files$Input), c("File ID","File Name","Condition","Color","Sample","MS_batch"))
input_files$Input <- input_files$Input[,colToKeep]
if(!("Condition" %in% colnames(input_files$Input))){ stop("Error: \'Condition\' column missin in \'Input\' file.") }
if(batch_corr_exe & !("MS_batch" %in% colnames(input_files$Input))){ stop("Error: \'MS_batch\' column missin in \'Input\' file with batch correction activated") }
if("Sample" %in% colnames(input_files$Input)){input_files$Input$`File Name` <- input_files$Input$Sample}
input_files$Input$`File Name`<- lapply(input_files$Input$`File Name`,
                                       function(x){tail(unlist(strsplit(x,"\\",fixed=T)),n=1)})

input_files$Input$`File Name`<-mf(unlist(input_files$Input$`File Name`),"_")
if(any(str_starts(input_files$Input$Condition, "[0-9]"))){
  name<-names(formule_contrast)
  formule_contrast <- lapply(unique(input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))]), 
                             function(x){
                               str_replace_all(formule_contrast,
                                               x,
                                               str_c("X.", x))
                             })[[1]]
  names(formule_contrast) <- name
  input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))] <- str_c("X.",
                                                                                           input_files$Input$Condition[(str_starts(input_files$Input$Condition,
                                                                                                                                   "[0-9]"))])
}
#Prepare PROT table with only column Accession and Dscription, extract fro Description the GeneName and remove contaminants
if(is_empty(which(grepl("Keratin|keratin",input_files$PROT$Description) |
                  grepl("CON_",input_files$PROT$Accession)))){
  input_files$PROT <- na.omit(input_files$PROT[,c("Accession","Description")])
}else{
  input_files$PROT <- na.omit(input_files$PROT[-which(grepl("Keratin|keratin",input_files$PROT$Description) |
                                                        grepl("CON_",input_files$PROT$Accession))
                                               ,c("Accession","Description")])
}
input_files$PROT$GeneName<-lapply(input_files$PROT$Description, function(x){gsub(".*GN=(.+) PE=.*", "\\1", x)}) %>% unlist()
taxonomy_NCBI<-lapply(input_files$PROT$Description, function(x){gsub(".*OX=(.+) GN=.*", "\\1", x)}) %>% unlist()
taxonomy_NCBI<-strtoi(names(sort(table(taxonomy_NCBI), decreasing = T))[1])
#Mantain only the first UNIPROT code
input_files$PEP$`Master Protein Accessions`<-lapply(input_files$PEP$`Master Protein Accessions`,
                                                    function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()
#Verify if the Abundance start in 5 column in PEP table, if not remove extra column
if(!grepl("Abundance",colnames(input_files$PEP)[5])){
  input_files$PEP<-input_files$PEP[,c("Annotated Sequence",if("Modifications" %in% colnames(input_files$PEP)){"Modifications"}else{"Modifications in Master Proteins"},
                                      "Master Protein Accessions","Positions in Master Proteins",
                                      colnames(input_files$PEP)[which(grepl("Abundance",colnames(input_files$PEP)))])]
}

#merge by uniprot the prot description and the pep table
uniprot_to_take<-merge(input_files$PROT, input_files$PEP, by.x = "Accession", by.y = "Master Protein Accessions")
input_files$PD_PEP_matrix<-merge(input_files$PROT[which(input_files$PROT$Accession %in% uniprot_to_take$Accession),],
                                 input_files$PEP, by.x = "Accession", by.y = "Master Protein Accessions")
input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,c(c("Accession","Description","GeneName","Annotated Sequence",
                                                          if("Modifications" %in% colnames(input_files$PEP)){"Modifications"}else{"Modifications in Master Proteins"},
                                                          "Positions in Master Proteins"),
                                                        lapply(input_files$Input$`File ID`, function(x){
                                                          colnames(input_files$PD_PEP_matrix)[grepl(str_c(x,":"), colnames(input_files$PD_PEP_matrix))]
                                                        }) %>% unlist())]
if("TRUE" %in% grepl("\\.", colnames(input_files$PD_PEP_matrix))){
  input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,-which(colnames(input_files$PD_PEP_matrix) %in%
                                                                 c(colnames(input_files$PD_PEP_matrix)[grepl("\\.",
                                                                                                             colnames(input_files$PD_PEP_matrix))]))]
}
colnames(input_files$PD_PEP_matrix)<-c(c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins"),
                                       unlist(lapply(colnames(input_files$PD_PEP_matrix), function(x){
                                         lapply(input_files$Input$`File ID`, function(y){if(str_detect(x,paste0(y,":"))){
                                           input_files$Input$`File Name`[which(input_files$Input$`File ID` %in% y)]
                                         }})
                                       })))
# input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1] %>% toupper()
input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1]
#Maintain only the new complete matrix of abundance
psm_sig_raw<-input_files$PD_PEP_matrix
c_anno<-input_files$Input
if(!("Sample" %in% colnames(c_anno))){
  colnames(c_anno)[2]<-"sample"
}else{
  colnames(psm_sig_raw)<-c(c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins"),
                           c_anno$Sample)
}
colnames(c_anno)<-tolower(colnames(c_anno))

rownames(c_anno)<-c_anno$sample
if("color" %in% colnames(c_anno)){
  colour_vec<-na.omit(c_anno[colnames(psm_sig_raw),]$color)
  names(colour_vec)<-na.omit(c_anno[colnames(psm_sig_raw),]$sample)
}else{
  c_anno<-left_join(c_anno,
                    data.frame("color"=colour_vec[match(sort(c_anno$condition),unique(sort(c_anno$condition)))],
                               "sample"=c_anno[order(c_anno$condition), "sample"]))
}
rownames(c_anno)<-c_anno$sample

remove(uniprot_to_take,input_files)
shiny::setProgress(0.23, detail = "Files correctly read...")
```

```{r load_data_from_MQ, eval=readMQ_files,echo=F, message=F, warning=F, results='asis'}
message("Reading files from MS...")
#Read all files in the input folder
template_files=c("Input","pep","prot")
filenames <- list("Input"=params$file_input,"prot"=params$file_prot,"pep"=params$file_pep)
input_files<-list("FILES"="in_files")
# save(template_files, filenames, input_files, file = "tmp.RData")
for (f in template_files){
  if(f == template_files[1]){
    input_files[f] <- tryCatch({
      read_excel_allsheets(filenames[f][[1]])
    }, error=function(cond){
      stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
    })
  }else{
    input_files[f] <- tryCatch({
      list(read_tsv(filenames[f][[1]]))
    }, error=function(cond){
      stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
    })
  }
}
names(input_files)<-c("dir","Input","PEP","PROT")
message("Data acquired")

#Clean files and merge
colToKeep<-intersect(colnames(input_files$Input), c("Condition","Color","Sample"))
input_files$Input <- input_files$Input[,colToKeep]
if(!("Condition" %in% colnames(input_files$Input))){ stop("Error: \'Condition\' column missin in \'Input\' file.") }
if(!("Sample" %in% colnames(input_files$Input))){ stop("Error: \'Sample\' column missin in \'Input\' file.") }
if(batch_corr_exe & !("MS_batch" %in% colnames(input_files$Input))){ stop("Error: \'MS_batch\' column missin in \'Input\' file with batch correction activated") }

if(any(str_starts(input_files$Input$Condition, "[0-9]"))){
  name<-names(formule_contrast)
  formule_contrast <- lapply(unique(input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))]), 
                             function(x){
                               str_replace_all(formule_contrast,
                                               x,
                                               str_c("X.", x))
                             })[[1]]
  names(formule_contrast) <- name
  input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))] <- str_c("X.",
                                                                                           input_files$Input$Condition[(str_starts(input_files$Input$Condition,
                                                                                                                                   "[0-9]"))])
}
#Prepare PROT table with only column Accession and Dscription, extract fro Description the GeneName and remove contaminants
input_files$PROT <- input_files$PROT[-which(grepl("Keratin|keratin",input_files$PROT$`Fasta headers`) |
                                              grepl("CON_|Keratin|keratin",input_files$PROT$`Majority protein IDs`))
                                     ,c("Majority protein IDs","Fasta headers")]

taxonomy_NCBI<-9606
if(any(grepl(".*GN=(.+) PE=.*", input_files$PROT$`Fasta headers`))){
  input_files$PROT$GeneName<-lapply(input_files$PROT$`Fasta headers`, function(x){gsub(".*GN=(.+) PE=.*", "\\1", x)}) %>% unlist()
  input_files$PROT$GeneName[which(str_detect(input_files$PROT$GeneName,";"))] <- lapply(
    input_files$PROT$GeneName[which(str_detect(input_files$PROT$GeneName,";"))],
    function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()
  
  taxonomy_NCBI2<-lapply(input_files$PROT$`Fasta headers`, function(x){gsub(".*OX=(.+) GN=.*", "\\1", x)}) %>% unlist()
  taxonomy_NCBI2<-strtoi(names(sort(table(taxonomy_NCBI2), decreasing = T))[1])
  if(!is.na(taxonomy_NCBI2)){
    taxonomy_NCBI<-9606
  }
} else if(any(grepl("ENS\\w+\\||ENS\\w+\\.\\w+\\|", input_files$PROT$`Fasta headers`))){
  input_files$PROT$GeneName<-lapply(input_files$PROT$`Fasta headers`, 
                                    function(x){
                                      tail(
                                        strsplit(
                                          stri_split_regex(x, ";")[[1]][1], 
                                          split = "\\|")[[1]], 
                                        n=2)[1]}) %>% unlist()
  
  taxonomy_NCBI2<-unlist(stri_extract_all_regex(input_files$PROT$`Fasta headers`, "^\\w+P"))
  taxonomy_NCBI2<-names(sort(table(taxonomy_NCBI2), decreasing = T))[1]
  if(taxonomy_NCBI2 == "ENSMUSP|ENSMUS"){
    taxonomy_NCBI<-10090
  }
  
  input_files$PROT$`Majority protein IDs` <- lapply(input_files$PROT$`Majority protein IDs`, 
                                                    function(x){strsplit(x, ";")[[1]][1]}) %>% unlist()
} else{
  input_files$PROT$GeneName<-input_files$PROT$`Fasta headers`
}

#Mantain only the first UNIPROT code
colPep <- if(length(intersect(input_files$PROT$`Majority protein IDs`, 
                              input_files$PEP$`Leading razor protein`)) >
             length(intersect(input_files$PROT$`Majority protein IDs`,
                              input_files$PEP$Proteins))){"Leading razor protein"}else{"Proteins"}
input_files$PEP<-input_files$PEP[,c(colPep,"Sequence","Start position","End position",
                                    grep("Intensity ",colnames(input_files$PEP)[grepl(paste(input_files$Input$Sample, collapse = "|"), colnames(input_files$PEP))], value = T))]


#merge by uniprot the prot description and the pep table
input_files$PD_PEP_matrix<-merge(input_files$PROT, 
                                 input_files$PEP, 
                                 by.x = "Majority protein IDs", 
                                 by.y = colPep)

input_files$PD_PEP_matrix$`End position` <- str_c(input_files$PD_PEP_matrix$GeneName,input_files$PD_PEP_matrix$`Start position`, input_files$PD_PEP_matrix$`End position`, sep = "_")
input_files$PD_PEP_matrix$`Start position` <- c(NA)

colnames(input_files$PD_PEP_matrix)<-c(c("Accession","Description","GeneName",
                                         "Annotated Sequence","Modifications","Position in Master Proteins"),
                                       unlist(lapply(colnames(input_files$PD_PEP_matrix), function(x){ if(str_detect(x,"Intensity")){
                                         str_split(x," ")[[1]][2]
                                       }})
                                       ))
input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1]
#Maintain only the new complete matrix of intensity
psm_sig_raw<-input_files$PD_PEP_matrix
c_anno<-input_files$Input
colnames(c_anno)<-tolower(colnames(c_anno))

rownames(c_anno)<-c_anno$sample
if("color" %in% colnames(c_anno)){
  colour_vec<-na.omit(c_anno[colnames(psm_sig_raw),]$color)
  names(colour_vec)<-na.omit(c_anno[colnames(psm_sig_raw),]$sample)
}else{
  c_anno<-left_join(c_anno,
                    data.frame("color"=colour_vec[match(sort(c_anno$condition),unique(sort(c_anno$condition)))],
                               "sample"=c_anno[order(c_anno$condition), "sample"]))
}
rownames(c_anno)<-c_anno$sample
remove(uniprot_to_take,input_files)

shiny::setProgress(0.23, detail = "Files correctly read...")
```

```{r peptide_annotation, message=F, warning=F, echo=F, eval=T}
psm_sig_raw$`Position in Master Proteins`<-gsub(" ", "_", psm_sig_raw$`Position in Master Proteins`)
psm_sig_raw$Modifications<-gsub(" ", "_", psm_sig_raw$Modifications)

if(readPD_files){
  psm_anno_raw <- data.frame("symbol"=psm_sig_raw$GeneName,
                             "sequence"=psm_sig_raw$`Annotated Sequence`,
                             "modifications"=psm_sig_raw$Modifications)
  psm_anno_raw$id<-paste(psm_anno_raw$symbol,psm_anno_raw$sequence,psm_anno_raw$modifications,sep="_")
}else{
  psm_anno_raw <- data.frame("symbol"=psm_sig_raw$GeneName,
                             "sequence"=psm_sig_raw$`Annotated Sequence`,
                             "modifications"=psm_sig_raw$Modifications)
  psm_anno_raw$id<-paste(psm_anno_raw$symbol,psm_anno_raw$sequence,psm_anno_raw$modifications,sep="_")
}


rownames(psm_sig_raw)<-rownames(psm_anno_raw)<-paste(psm_anno_raw$symbol,seq(1:nrow(psm_anno_raw)),sep="_")
psm_anno_raw$old_id<-rownames(psm_anno_raw)

# create peptide names linked to symbols
psm_anno_raw$row <- seq(1,nrow(psm_anno_raw))
psm_anno_raw <- psm_anno_raw %>% dplyr::group_by(symbol) %>% dplyr::mutate("min"=min(row),"card"=n()) %>% ungroup()
psm_anno_raw$rank<- psm_anno_raw$row - psm_anno_raw$min +1
psm_anno_raw$id<- paste(psm_anno_raw$symbol,psm_anno_raw$rank,psm_anno_raw$card,sep="_")

psm_sig_raw<-psm_sig_raw[psm_anno_raw$old_id,]
rownames(psm_sig_raw)<-psm_anno_raw$id

psm_anno_raw<-as.data.frame(psm_anno_raw)
rownames(psm_anno_raw)<- psm_anno_raw$id

#Divide the table info from the matrix of peptide intensity
psm_peptide_table<-psm_sig_raw[,c(1:6)]
rownames(psm_peptide_table)<-make.names(paste(psm_peptide_table$`Position in Master Proteins`,
                                              psm_peptide_table$Modifications,
                                              psm_peptide_table$`Annotated Sequence`,sep = "_"), 
                                        unique = T)
psm_sig_prot_raw<-psm_sig_raw[,c(7:ncol(psm_sig_raw))]
psm_sig_pet_raw<-psm_sig_raw[,c(7:ncol(psm_sig_raw))]
rownames(psm_sig_pet_raw)<-rownames(psm_peptide_table)

shiny::setProgress(0.27, detail = "Annotate proteins/peptides...")

```

```{r preprocess_sig_raw, echo=F, message=F, warning=F}
n_prot_preFILT <- length(unique(psm_anno_raw$symbol))
n_pep_pre_FILT <- length(psm_peptide_table$Accession)
#Preprocess Protein intensities
psm_sig_prot_raw[psm_sig_prot_raw == 0] <- NA # transform 0s into NAs

sig_thr<-filt_absent_value # NA threshold

psm_long_df <- psm_sig_prot_raw %>% mutate(id=as.factor(rownames(psm_sig_prot_raw)))
psm_long_df <- psm_long_df %>% pivot_longer(-id, names_to = "sample", values_to = "counts")
psm_long_df <- suppressMessages(left_join(psm_long_df,c_anno))


psm_filter_df <- psm_long_df %>% dplyr::group_by(id,condition, .drop=FALSE) %>% dplyr::summarise("min_c"=sum(is.na(counts))) %>% ungroup()

psm_filter_df <- psm_filter_df %>% dplyr::group_by(id,.drop=FALSE) %>% dplyr::summarise("passes_c"= sum(min_c <= sig_thr)) %>% ungroup()

filter_id <- as.character(psm_filter_df %>% dplyr::filter(passes_c > 0) %>% pull(id))
psm_sig_prot_df <-psm_sig_prot_raw[filter_id,]
psm_anno_df <- psm_anno_raw[filter_id,]

#Log2
psm_log_prot_df <- psm_sig_prot_df
psm_log_prot_df <- psm_sig_prot_df %>% log2()


#Filter proteins with only 1 peptides
filter_df_single_pep<-psm_anno_df %>% dplyr::group_by(symbol) %>% dplyr::summarise(N=n()) %>% ungroup() %>% filter(N > 1)
filter_df_single_pep <- left_join(filter_df_single_pep, psm_anno_df) %>% pull(id)
psm_log_prot_df <-psm_log_prot_df[intersect(rownames(psm_log_prot_df), filter_df_single_pep),]
psm_anno_df <- psm_anno_df[intersect(rownames(psm_anno_df), filter_df_single_pep),]
#Clean old variables
remove(psm_anno_raw,psm_sig_prot_raw,psm_long_df,psm_filter_df,filter_id,sig_thr)

#Preprocess peptide intensities
psm_sig_pet_raw[psm_sig_pet_raw == 0] <- NA # transform 0s into NAs
sig_thr<-filt_absent_value # NA threshold

psm_long_df <- psm_sig_pet_raw %>% mutate(id=as.factor(rownames(psm_sig_pet_raw)))
psm_long_df <- psm_long_df %>% pivot_longer(-id, names_to = "sample", values_to = "counts")
psm_long_df <- suppressMessages(left_join(psm_long_df,c_anno))

psm_filter_df <- psm_long_df %>% dplyr::group_by(id,condition, .drop=FALSE) %>% dplyr::summarise("min_c"=sum(is.na(counts))) %>% ungroup()
psm_filter_df <- psm_filter_df %>% dplyr::group_by(id,.drop=FALSE) %>% dplyr::summarise("passes_c"= sum(min_c <= sig_thr)) %>% ungroup()
filter_id <- as.character(psm_filter_df %>% dplyr::filter(passes_c > 0) %>% pull(id))

psm_sig_pet_df <-psm_sig_pet_raw[filter_id,]
psm_peptide_table<-psm_peptide_table[filter_id,]

#Determine column tryptic
peptides_df <- psm_peptide_table[,c("Accession", "Annotated Sequence")]
peptides_df$preAA <- str_sub(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,1], regex("\\[\\w+\\]")),
                             2,
                             str_length(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."),
                                                                    n = 3)[,1], regex("\\[\\w+\\]")))-1)

peptides_df$endAA <- str_sub(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,2], -1, -1)
peptides_df$postAA <- str_sub(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,3], regex("\\[\\w+\\]")),
                              2,
                              str_length(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."),
                                                                     n = 3)[,3], regex("\\[\\w+\\]")))-1)

peptides_df$fully_TRI = (peptides_df$preAA %in% c("K","R") &
                           peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$NSEMI_TRI = (peptides_df$preAA %in% c("K","R") &
                           !peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$CSEMI_TRI = (!peptides_df$preAA %in% c("K","R") &
                           peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$non_TRI = (!peptides_df$fully_TRI & !peptides_df$NSEMI_TRI & !peptides_df$CSEMI_TRI)

peptides_df$tryptic_cond[peptides_df$fully_TRI] <- "fully tryptic"
peptides_df$tryptic_cond[peptides_df$NSEMI_TRI] <- "N-semi tryptic"
peptides_df$tryptic_cond[peptides_df$CSEMI_TRI] <- "C-semi tryptic"
peptides_df$tryptic_cond[peptides_df$non_TRI] <- "non tryptic"

psm_peptide_table$tryptic_cond <- peptides_df$tryptic_cond

#Log2
psm_log_pet_df <- psm_sig_pet_df
psm_log_pet_df <- psm_sig_pet_df %>% log2()

#Filter proteins with only 1 peptides
filter_df_single_pep<-psm_anno_df %>% dplyr::group_by(symbol) %>% dplyr::summarise(N=n()) %>% ungroup() %>% filter(N > 0)
filter_df_single_pep <- left_join(filter_df_single_pep, psm_anno_df) %>% pull(symbol)
filter_df_single_pep <- rownames(psm_peptide_table[which(psm_peptide_table$GeneName %in% filter_df_single_pep),])
psm_log_pet_df <-psm_log_pet_df[intersect(rownames(psm_log_pet_df), filter_df_single_pep),]
psm_peptide_table <- psm_peptide_table[intersect(rownames(psm_peptide_table), filter_df_single_pep),]

remove(psm_sig_pet_raw,psm_sig_raw,psm_long_df,psm_filter_df,filter_id,sig_thr)

shiny::setProgress(0.29, detail = "Filtering abundance matrix...")
```


## 1. Analysis

### 1.1. Sample annotation
The sample table below annotates the samples of the study as in the **Sample_Annotation** file. Important columns for the analysis:

- **Sample**: sample name used in the results,
- **Condition**: condition of the sample used in study desgin and differential analyses,
- **Color**: the color of the sample in figures.

```{r print_sample, warning=FALSE, echo=F, message=FALSE, results='asis'}
cat(" \n")
kable(c_anno, row.names = F, col.names = str_to_title(colnames(c_anno)))
cat(" \n")
```


Raw abundances are determined from the area under the peak (m/z, time, number of events) for each PSM (Peptide-to-Spectrum Match).

Initial filtering removes the following peptides:

-   Low/missing abundance: PSMs not consistently present in all replicates of at least one condition are removed.
-   Contaminants.

After filtering, raw abundances are log2 transformed

#### Number of identified peptides/proteins
```{r stat_proteomic, echo=F, message=F, warning=F, results='asis'}
df_stat <- data.frame("number" = c(n_prot_preFILT, n_pep_pre_FILT, length(unique(psm_anno_df$symbol)), nrow(psm_anno_df)), 
                      row.names = c("Proteins (raw):", "Peptides (raw):", "Proteins (after filter):", "Peptides (after filter):"))
kable(df_stat)
```

#### 1.1. Distributions of log2 raw abundances
Violin plot showing sample distributions of log2 raw abundances of peptides.

```{r raw_distributions, message=F, warning=F, echo=F}

psm_long_df <- psm_log_prot_df[,c_anno[order(c_anno$condition),"sample"]] %>% mutate(id=as.factor(rownames(psm_log_prot_df[,c_anno[order(c_anno$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2 raw abundance")
psm_long_df <- suppressMessages(left_join(psm_long_df,c_anno))

hs<-ggplot(data=psm_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`log2 raw abundance`,fill=sample,colour=sample))+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F,colour=NA)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = T)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank()) +
  scale_fill_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

hs

shiny::setProgress(0.32, detail = "Calculate distributions...")
```

#### 1.2. Percentage of quantified peptides per sample
Barplot showing the percentage of peptides with available abundances for each sample.

```{r numeric_numbers, echo=F, message=F, warning=F}
numeric_df<- c_anno[c_anno[order(c_anno$condition),"sample"],]
numeric_df$numeric_values<-colSums(is.na(psm_sig_prot_df))
numeric_df$numeric_percentage<- 100-(numeric_df$numeric_values/nrow(psm_sig_prot_df)*100)
setnames(numeric_df,"numeric_percentage","% of available abundances")

hs<-ggplot(data=numeric_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`% of available abundances`,fill=sample,colour=sample))+
  coord_flip()+
  geom_bar(stat="identity",width=.7,alpha=.8)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  scale_fill_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

hs

remove(hs,numeric_df)
shiny::setProgress(0.34, detail = "Doing imputation...")
```


#### 1.3. Imputation, normalization, peptide-to-protein summarization 

**Imputation** is performed on peptide and protein abundances with the Bioconductor package [PhosR](https://www.sciencedirect.com/science/article/pii/S221112472100084X). Round imputation is performed in absence of replicates. ProTN uses two function of PhosR for the imputation, the first impute the missing values for a peptide across replicates within a single condition, the second is a tail-based imputation approach as implemented in Perseus.

**Normalization:**

**Peptides** abundances are normalized with the equalMedianNormalization function from the Bioconductor package [DEqMS](<https://www.bioconductor.org/packages/release/bioc/html/DEqMS.html>) (equal medians in all samples). 

**Protein** normalized abundances were calculated with the medianSweeping function from the Bioconductor package [DEqMS](<https://www.bioconductor.org/packages/release/bioc/html/DEqMS.html>).

```{r pep_in_proteins, echo=F, message=F, warning=F}

numeric_df <- as.data.table(table(psm_anno_df$symbol))
numeric_df[which(numeric_df$N > 20), "N"] <- 20
numeric_df <- numeric_df[order(numeric_df$N) , .(NPeptides = .N), by = c("N")]
numeric_df$N <- factor(str_sort(str_replace(as.character(numeric_df$N), pattern = "20", replacement = "20+"), numeric = T), levels = c(1:19, "20+"))

hs<-ggplot(data=numeric_df, aes(x=N,y=NPeptides, color = NPeptides, fill = NPeptides))+
  geom_bar(stat="identity",width=.7,alpha=.8)+
  theme_bw()+
  theme(legend.position = "none")+
  labs(x = "# peptides per protein", y = "# proteins") +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank(),panel.grid.major.x = element_blank())

hs

remove(hs,numeric_df)
```

```{r imputation, echo=F, message=F, warning=F, results='asis'}
message("Imputation of intensity matrix in progress...")
psm_log_prot_df<-tryCatch(
  {
    #Imputation with Phospho
    ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(psm_log_prot_df)))
    #Mantieni ordine
    grps <- as.factor(c_anno[colnames(psm_log_prot_df), "condition"])
    ppe <- scImpute(ppe, 0.6, grps)
    ppe <- tImpute(ppe, assay = "imputed")
    psm_log_prot_df[is.na(psm_log_prot_df)]<-ppe@assays@data@listData$imputed[is.na(psm_log_prot_df)]
    psm_log_prot_df
  },
  error=function(cond){
    # Rounds of imputation
    mat_i <- psm_log_prot_df
    col_sele<-colnames(mat_i)
    
    vec_all<-unlist(mat_i[,col_sele]) # convert to vector
    vec_numeric<-vec_all[-which(is.na(vec_all))] # remove NAs
    orig_stats<-c(mean(vec_numeric),sd(vec_numeric)) # calculate mean and sd
    imp_stats<-c(orig_stats[1]-(orig_stats[2]*1.8),orig_stats[2]*0.3) # imputed mean = mean-1.8*sd, imputed sd = sd*0.3
    
    set.seed(42)
    imp_matrix<-matrix(rnorm(length(vec_all), mean = imp_stats[1], sd = imp_stats[2]), ncol=ncol(mat_i)) # create matrix of imputed values
    psm_log_prot_df[is.na(psm_log_prot_df)]<-imp_matrix[is.na(psm_log_prot_df)]
    psm_log_prot_df
  }
)

remove(ppe,grps)

psm_log_pet_df<-tryCatch(
  {
    #Imputation with Phospho
    ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(psm_log_pet_df)))
    grps <- as.factor(c_anno[colnames(psm_log_prot_df), "condition"])
    ppe <- scImpute(ppe, 0.6, grps)
    ppe <- tImpute(ppe, assay = "imputed")
    psm_log_pet_df[is.na(psm_log_pet_df)]<-ppe@assays@data@listData$imputed[is.na(psm_log_pet_df)]
    psm_log_pet_df
  },
  error=function(cond){
    # Rounds of imputation
    mat_i <- psm_log_pet_df
    col_sele<-colnames(mat_i)
    
    vec_all<-unlist(mat_i[,col_sele]) # convert to vector
    vec_numeric<-vec_all[-which(is.na(vec_all))] # remove NAs
    orig_stats<-c(mean(vec_numeric),sd(vec_numeric)) # calculate mean and sd
    imp_stats<-c(orig_stats[1]-(orig_stats[2]*1.8),orig_stats[2]*0.3) # imputed mean = mean-1.8*sd, imputed sd = sd*0.3
    
    set.seed(42)
    imp_matrix<-matrix(rnorm(length(vec_all), mean = imp_stats[1], sd = imp_stats[2]), ncol=ncol(mat_i)) # create matrix of imputed values
    psm_log_pet_df[is.na(psm_log_pet_df)]<-imp_matrix[is.na(psm_log_pet_df)]
    psm_log_pet_df
  }
)

remove(ppe,grps)
```

```{r prot_summarization, warning=F, message=F, echo=F}
shiny::setProgress(0.38, detail = "Doing normalizations...")
message("Median normalization in progress...")
#Summarize into proteins and normalize by median
dat_psm <- cbind(psm_anno_df[,c("id","symbol")],psm_log_prot_df)
dat_gene = DEqMS::medianSweeping(dat_psm,group_col = 2)

# Median centering log2 table for peptides
dat_pep = DEqMS::equalMedianNormalization(psm_log_pet_df)

message("Normalization DONE.")
shiny::setProgress(0.42, detail = "Done normalization and imputation...")
```

```{r batch_correction, warning=F, message=F, echo=F, eval=batch_corr_exe, results='asis'}
cat("#### 1.3.1. Batch correction {.tabset}  \n")
cat("A batch effect correction is applied to the datased using the proBatch package. \n")
cat(" \n \n")

batch_annotation <- c_anno
batch_annotation$order<-c(1:nrow(batch_annotation))

#Batch correction of peptides
dat_pep_long <- matrix_to_long(dat_pep) %>% setnames("FullRunName","sample")
comBat_df_pep <- correct_with_ComBat_df(dat_pep_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
dat_pep = as.data.frame(long_to_matrix(comBat_df_pep, sample_id_col = "sample"))

#Batch correction of peptides
dat_gene_long <- matrix_to_long(dat_gene) %>% setnames("FullRunName","sample")
comBat_df_gene <- correct_with_ComBat_df(dat_gene_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
dat_gene = as.data.frame(long_to_matrix(comBat_df_gene, sample_id_col = "sample"))

```

```{r sig_tables, message=F, warning=F, echo=F, results='hide'}
#Save proteins table
expr_mat<-as.data.table(dat_gene)
expr_mat$gene <- rownames(dat_gene)

expr_l_df <- melt(expr_mat)
colnames(expr_l_df) <- c("id","sample","expr")
expr_l_df <- expr_l_df[c_anno, on = "sample"]

expr_cond_df <- expr_l_df[ , .(N = .N, avg = mean(expr), sd=sd(expr), CV=sd(expr)/mean(expr), se = sd(expr)/sqrt(.N)), by = c("condition","id")]

expr_avg_df <- dcast(expr_cond_df[,c("id","condition","avg")], id ~ condition)
colnames(expr_avg_df)[-1]<-paste0(colnames(expr_avg_df)[-1],"_avg")
expr_se_df <- dcast(expr_cond_df[,c("id","condition","se")], id ~ condition)
colnames(expr_se_df)[-1]<-paste0(colnames(expr_se_df)[-1],"_se")
expr_cv_df <- dcast(expr_cond_df[,c("id","condition","CV")], id ~ condition)
colnames(expr_cv_df)[-1]<-paste0(colnames(expr_cv_df)[-1],"_Coef_Variant_(%)")

expr_avgse_df <- Reduce(merge,list(expr_avg_df,expr_se_df,expr_cv_df))

toPrint<-expr_avgse_df
colnames(toPrint)[1]<-"symbol"

n_pep_prot <- unique(merge.data.table(as.data.table(psm_peptide_table[,c("Accession","Description","GeneName")]), as.data.table(psm_anno_df)[ , .(Num.Peptide = .N), by = symbol], by.x = "GeneName", by.y = "symbol"))
colnames(n_pep_prot)[1]<-"symbol"
toPrint_datGene<-as.data.table(dat_gene)
toPrint_datGene$symbol<-rownames(dat_gene)

df_to_save<-list("protein_per_sample"=merge.data.table(n_pep_prot,toPrint_datGene),
                 "protein_per_condition"=merge.data.table(n_pep_prot,toPrint))

#Save peptides table
expr_mat<-as.data.table(dat_pep)
expr_mat$gene <- rownames(dat_pep)

expr_l_df <- melt(expr_mat)
colnames(expr_l_df) <- c("id","sample","expr")
expr_l_df <- expr_l_df[c_anno, on = "sample"]

expr_cond_df <- expr_l_df[ , .(N = .N, avg = mean(expr), sd=sd(expr), CV=sd(expr)/mean(expr), se = sd(expr)/sqrt(.N)), by = c("condition","id")]

expr_avg_pet_df <- dcast(expr_cond_df[,c("id","condition","avg")], id ~ condition)
colnames(expr_avg_pet_df)[-1]<-paste0(colnames(expr_avg_pet_df)[-1],"_avg")
expr_se_pet_df <- dcast(expr_cond_df[,c("id","condition","se")], id ~ condition)
colnames(expr_se_pet_df)[-1]<-paste0(colnames(expr_se_pet_df)[-1],"_se")
expr_cv_pep_df <- dcast(expr_cond_df[,c("id","condition","CV")], id ~ condition)
colnames(expr_cv_pep_df)[-1]<-paste0(colnames(expr_cv_pep_df)[-1],"_Coef_Variant_(%)")

expr_avgse_pep_df <- Reduce(merge,list(expr_avg_pet_df,expr_se_pet_df,expr_cv_pep_df))

toPrint<-expr_avgse_pep_df

#Prepare the README
readme_sheet <- data.frame("INFO"=c(NA,
                                    "Excel file containing abundance values generated by proTN. Abundances are log2 transformed, normalized, imputed (and batch corrected). The file is organized in the following sheets",
                                    NA,
                                    "Sheet *protein_per_sample*: protein abundances per sample.",
                                    "Sheet *peptide_per_sample*: peptide abundances per sample.",
                                    "Sheet *protein_per_condition*: protein abundances per condition (average & standard deviation), as defined in the Sample Annotation.",
                                    "Sheet *peptide_per_condition*: peptide abundances per condition (average & standard deviation), as defined in the Sample Annotation."
))

#Export table with SE e MEAN
df_to_save<-list("README"=readme_sheet,
                 "protein_per_sample"=df_to_save$`protein_per_sample`,
                 "peptide_per_sample"=merge(psm_peptide_table, dat_pep, by=0)[,-c(1)],
                 "protein_per_condition"=df_to_save$`protein_per_condition`,
                 "peptide_per_condition"=merge.data.table(as.data.table(rownames_to_column(psm_peptide_table)), toPrint, by.x = "rowname", by.y = "id")[,-c(1)])

writexl::write_xlsx(df_to_save,paste0(dirOutput,subfold_Tab,"normalised_abundances.xlsx"))
remove(expr_mat,expr_l_df,expr_cond_df,expr_se_pet_df,expr_avg_pet_df,toPrint)

shiny::setProgress(0.45, detail =  "Save normalized data...")
```

```{r norm_distributions, message=F, warning=F, echo=F, results='asis'}
cat(" \n \n")
cat("#### 1.4. Distributions of normalized abundances {.tabset}  \n")
cat("Violin plot showing sample distributions of log2 normalized and imputed abundances. \n \n ")

cat(" \n \n")
pg_long_df <- dat_gene[,c_anno[order(c_anno$condition),"sample"]] %>% mutate(id=as.factor(rownames(dat_gene[,c_anno[order(c_anno$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2 normalized abundance")
pg_long_df <- suppressMessages(left_join(pg_long_df,c_anno))

hs<-ggplot(data=pg_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`log2 normalized abundance`,fill=sample,colour=sample))+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F,colour=NA)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = F)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  scale_fill_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Proteins \n")
print(hs)
cat(" \n \n")

pg_long_df <- dat_pep[,c_anno[order(c_anno$condition),"sample"]] %>% mutate(id=as.factor(rownames(dat_pep[,c_anno[order(c_anno$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2 normalized abundance")
pg_long_df <- suppressMessages(left_join(pg_long_df,c_anno))


hs<-ggplot(data=pg_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`log2 normalized abundance`,fill=sample,colour=sample))+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F,colour=NA)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = F)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  scale_fill_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Peptides \n")
print(hs)
cat(" \n \n")

remove(hs, pg_long_df)
shiny::setProgress(0.47, detail =  "Calculate post-norm distribution...")
```

```{r check_number_sample, warning=FALSE, echo=F, message=FALSE}
design = model.matrix(~0+c_anno$condition) 
colnames(design) = levels(as.factor(c_anno$condition))
rownames(design)<-c_anno$sample
filt_contro_list <- list()
for (i in 1:length(formule_contrast)) {
  if(all(stri_remove_empty(str_remove_all(str_extract_all(formule_contrast[i], "\\w+")[[1]], "^\\d+$")) %in% colnames(design))){
    filt_contro_list<-c(filt_contro_list,i)
  }
}
contro_list<-formule_contrast[unlist(filt_contro_list)]
if(length(contro_list) == 0){stop("Error: No valid contrast design given. Check the match between the spell of Condition and contrast design.")}
contrast =  limma::makeContrasts(contrasts=contro_list,levels=design)
colnames(contrast)<-names(contro_list)

unique_cond <- colSums(design) == 1
unique_cond <- sort(names(unique_cond[unique_cond]))
res<-lapply(colnames(contrast), function(i){all(sort(names((contrast[,i] != 0)[contrast[,i] != 0])) %in% unique_cond)}) %>% unlist()
formule_contrast<- contro_list[!res]

eval_single_Cond <- if(all(res)){FALSE}else{TRUE}
if(!eval_single_Cond | length(formule_contrast) > 0){
  cat("*WARNING*: Some comparisons cannot be done since have only two samples or has wrong condition. The comparison are removed.")
}
```

```{r mds_counts, warning=F, message=F, echo=F, results='asis', eval=eval_single_Cond}
cat(" \n \n")
cat("#### 1.5. Multi-dimensional scaling {.tabset}  \n")
cat("Multidimensional scaling (MDS) takes a set of dissimilarities and returns a set of points such that the distances between the points are approximately equal to the dissimilarities. Classical multidimensional scaling is also known as principal coordinates analysis. \n \n ")
cat("MDS analysis is performed on normalized **Protein** and **Peptide** abundances. \n")
cat(" \n \n")

sample_data<-(t(dat_gene))
sample_distances <- dist(sample_data, method = "euclidean")

mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
mds_cmdscale$sample <- rownames(mds_cmdscale)
mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno))

#Take correct order of color
cc<-mds_cmdscale$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
  names(cc)<-unique(mds_cmdscale$condition)
} else{
  names(cc)<-mds_cmdscale$condition
}

cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
  geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  scale_colour_manual(values=cc[unique(names(cc))]) +
  theme_bw(base_size = bs, base_family = bf) +
  theme(legend.position = "right", panel.grid.minor=element_blank())

cat("##### Proteins \n")
print(cmd)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"mds_proteins.pdf"), cmd, device=cairo_pdf, 
                        width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in")))
remove(sample_data,sample_distances,mds_cmdscale,cmd)

#Peptides
sample_data<-(t(dat_pep))
sample_distances <- dist(sample_data, method = "euclidean")

mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
mds_cmdscale$sample <- rownames(mds_cmdscale)
mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno))

#Take correct order of color
cc<-mds_cmdscale$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
  names(cc)<-unique(mds_cmdscale$condition)
} else{
  names(cc)<-mds_cmdscale$condition
}

cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
  geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  scale_colour_manual(values=cc[unique(names(cc))]) +
  theme_bw(base_size = bs, base_family = bf) +
  theme(legend.position = "right", panel.grid.minor=element_blank())

cat("##### Peptides \n")
print(cmd)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"mds_peptides.pdf"), cmd, device=cairo_pdf, 
                        width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,cmd)
shiny::setProgress(0.49, detail = "Calculate MDS...")
```

```{r pca_norm, warning=F, message=F, echo=F, results='asis', eval=eval_single_Cond}
cat(" \n \n")
cat("#### 1.6. Principal Component Analysis {.tabset}  \n")
cat("Principal component analysis (PCA) is performed on normalized Protein and Peptide abundances. \n \n ")
cat(" \n \n")

sample_data<-(t(dat_gene))
apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
pc <- apca_prot$x[,1:2]

pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
pc<- merge(pc, c_anno, by = 0)
pc$condition <- as.factor(pc$condition)

ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
ve <- ve[c(1, 2)]
labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

#Take correct order of color
cc<-pc$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(pc$condition))]
  names(cc)<-unique(pc$condition)
} else{
  names(cc)<-pc$condition
}

#ggplot method
p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
  geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  scale_colour_manual(values=cc[unique(names(cc))]) +
  theme_bw(base_size = bs, base_family = bf) +
  theme(legend.position = "right", panel.grid.minor=element_blank()) +
  xlab(labs[1]) +
  ylab(labs[2])

cat("##### Proteins \n")
print(p1)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"pca_protein.pdf"), p1, device=cairo_pdf, 
                        width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,cmd)

#Peptides
sample_data<-(t(dat_pep))
apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
pc <- apca_prot$x[,1:2]

pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
pc<- merge(pc, c_anno, by = 0)
pc$condition <- as.factor(pc$condition)

ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
ve <- ve[c(1, 2)]
labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

#Take correct order of color
cc<-pc$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(pc$condition))]
  names(cc)<-unique(pc$condition)
} else{
  names(cc)<-pc$condition
}

#ggplot method
p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
  geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  scale_colour_manual(values=cc[unique(names(cc))]) +
  theme_bw(base_size = bs, base_family = bf) +
  theme(legend.position = "right", panel.grid.minor=element_blank()) +
  xlab(labs[1]) +
  ylab(labs[2])

cat("##### Peptides \n")
print(p1)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"pca_peptides.pdf"), p1, device=cairo_pdf, 
                        width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,p1)
shiny::setProgress(0.51, detail = "Calculate PCA...")
```

```{r boxplot_proteins, warning=F, message=F, echo=F, eval=boxplot_prot_exe, results='asis'}
prot_find<-unique(c(intersect(prot_boxplot,rownames(dat_gene)),
                    intersect(str_to_title(prot_boxplot),rownames(dat_gene)),
                    intersect(str_to_upper(prot_boxplot),rownames(dat_gene)),
                    intersect(str_to_lower(prot_boxplot),rownames(dat_gene))))

if(length(prot_find)>0){
  cat("#### 1.7. Abundances of selected proteins {.tabset}  \n")
  cat("Normalized log2 abundances are displayed for proteins selected in the input. Abundances are grouped per condition. \n \n ")
  cat("Selected proteins with available abundances: \n")
  cat(paste(prot_find, sep = ", "))
  cat(" \n")
  cat(" \n \n")
  
  prot_intensity_long <- proBatch::matrix_to_long(dat_gene[prot_find,]) %>%
    data.table::setnames(new = c("Protein","Condition","Intensity"))
  prot_intensity_long <- unique((left_join(prot_intensity_long,
                                           c_anno[prot_intensity_long$Condition, c("sample","condition")],
                                           by=c("Condition"="sample")))[,-c(2)])  %>%
    data.table::setnames(new = c("Protein","Intensity","Condition"))
  
  
  avg_df = expr_avg_df %>% dplyr::filter(id %in% prot_find) %>% dplyr::select(colnames(expr_avg_df)[-c(1)])
  se_df = expr_se_df %>% dplyr::filter(id %in% prot_find) %>% dplyr::select(colnames(expr_se_df)[-c(1)])
  prot_avg_long <- proBatch::matrix_to_long(avg_df) %>% data.table::setnames(new = c("Protein","Condition","avg"))
  prot_avg_long$Protein<-(expr_avg_df %>% dplyr::filter(id %in% prot_find))$id[as.integer(prot_avg_long$Protein)]
  prot_se_long <- proBatch::matrix_to_long(se_df) %>% data.table::setnames(new = c("Protein","Condition","se"))
  prot_se_long$Protein<-(expr_se_df %>% dplyr::filter(id %in% prot_find))$id[as.integer(prot_se_long$Protein)]
  prot_avg_se_long <- cbind(prot_avg_long,prot_se_long[3])
  prot_avg_se_long$Condition <- str_replace(prot_avg_se_long$Condition, "_avg", "")
  
  g<-ggplot(prot_avg_se_long,aes(Condition,avg,fill=Condition,colour=Condition))+
    geom_crossbar(aes(ymin=avg,ymax=avg),position = "dodge",width=.8,alpha=.9,fatten=1.5)+
    geom_errorbar(aes(ymin=(avg-se), ymax=(avg+se)), width=.4,position=position_dodge(),show.legend=F,alpha=.8)+
    geom_quasirandom(data=prot_intensity_long, aes(Condition,Intensity), alpha=.7,width=.1,shape=16,size=0.11*bs)+
    scale_fill_manual(name="Condition",values=cc[sort(unique(prot_intensity_long$Condition))]) +
    scale_colour_manual(name="Condition",values=cc[sort(unique(prot_intensity_long$Condition))])+
    theme_bw(base_size = bs, base_family = bf) +
    theme(axis.title.x=element_blank(),
          axis.text.x = element_text(angle = 30, hjust = 1, colour=cc[sort(unique(prot_intensity_long$Condition))]),
          panel.grid.major.x=element_blank(),
          panel.grid.minor.y=element_blank(),
          legend.text = element_text(size = 0.7*bs),
          legend.key.size = unit((0.015*bs),"in"),
          legend.position="none",
          legend.title=element_blank(),
          legend.background = element_rect(fill = NA),
          strip.text=element_text(colour="white",face="bold"),
          panel.border=element_rect(colour=c("grey40"),size=0.03*bs),
          strip.background=element_rect(fill="grey40",colour="grey40",size=0.03*bs),
          plot.title = element_text(hjust = 0.5))+
    facet_wrap(~Protein, scales = "free",ncol = if(length(prot_find)>4){round(length(prot_find)/1.9)}else{4})+
    labs(y="Abundance")
  print(g)
  
  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_expr,"selected_protein_plot.pdf"), g, device=cairo_pdf, 
                          width = ((if(length(prot_find)<4){((length(prot_find)-1/(length(prot_find)))^1.2)*0.9}else{(4*1.2)*0.9}))+(0.75*length(unique(prot_avg_se_long$Condition))), 
                          height = 3*(if(length(prot_find)>=4){(length(prot_find) %/% 4)+1}else{1}), units = c("in")))
  
}else{
  cat("##### Selected proteins in options file do not find in the normalised matrix. Check the spell of the proteins. \n")
  cat(" \n \n")
}

shiny::setProgress(0.56, detail = "Control boxplot proteins...")
```

## 2. Identification of Differentially Expressed Proteins and Peptides

Differentially expressed peptides are identified using the Limma Bioconductor package.

```{r print_error_diff_analysis, warning=FALSE, echo=F, message=FALSE, results='asis', eval=!(eval_single_Cond)}
cat(" \n \n")
#Print summary of filter and contrast design
cat("**WARNING:** differential analysis not executed since are identified only 1 sample for the two condition \n ")
cat(" \n")
run_enrich <- run_enrich_universe <- run_STRING <- FALSE
```

```{r print_settings_diff_analysis, warning=FALSE, echo=F, message=FALSE, results='asis', eval=eval_single_Cond}
cat(" \n \n")
#Print summary of filter and contrast design
cat("**Thresholds used:** \n ")
cat(" \n")
cat(paste0("- Fold Change threshold: log2_FC > ",fc_thr," (+), log2_FC < -",fc_thr," (-) "))
cat(" \n")
cat(paste0("- Statistical significance threshold: p.val < ",pval_thr," "))
cat(" \n")
if(signal_thr != -Inf){cat(paste0("- Signal log2 intesity threshold: signal > ",signal_thr," "))}
cat(" \n")

```

```{r print_settings_design, warning=FALSE, echo=F, message=FALSE, results='asis', eval=eval_single_Cond}
cat("### 2.1. Differential expression contrasts \n \n")
cat("The following table contains the names and the formulas of the contrasts considered for differential expression analysis. \n \n")
cat("**Contrast design formula are:** ")
cat(" \n")
kable(data.frame("Name"=names(formule_contrast), "Formula"=formule_contrast, "Color"=color_constrast[names(formule_contrast), "color_constrast"]), row.names = F)
cat(" \n")
```

```{r diff_analysis,  warning=F, message=F, echo=F, eval=eval_single_Cond}
shiny::setProgress(0.58, detail = "Differential Analysis in progress...")
message("Differentiation analysis in progress...")
#Execution of differentiation analysis using DEqMS for proteins
psm_count_table = as.data.frame(table(dat_psm$symbol))
deps_df <- limmafnc("PROT",c_anno,dat_gene,psm_count_table,formule_contrast,as.data.frame(expr_avgse_df),signal_thr,fc_thr, pval_thr, pval_fdr)
deps_l_df<-deps_df$degs_l_df
deps_w_df<-deps_df$degs_w_df
toPrint<-deps_w_df
colnames(toPrint)[1]<-"GeneSymbol"

#Execution of differentiation analysis using DEqMS for proteins
psm_count_table<-as.data.frame(table(rownames(dat_pep)))
deps_pep_df <- limmafnc("PEP",c_anno,dat_pep,psm_count_table,formule_contrast,as.data.frame(expr_avgse_pep_df),signal_thr,fc_thr, pval_thr, pval_fdr)
deps_pep_l_df<-deps_pep_df$degs_l_df
deps_pep_w_df<-deps_pep_df$degs_w_df
toPrint_pep<-deps_pep_w_df

#Prepare the README
readme_sheet <- data.frame("INFO"=c(NA,
                                    "Excel file containing the results of differential analysis, according to the contrasts defined in the Design file. The file is organized in the following sheets:",
                                    "protein_DE: protein differential expression results protein abundances per sample.",
                                    "peptide_DE: peptide differential expression results. ",
                                    NA,
                                    "Annotation columns:",
                                    "1. *Accession*: protein UniprotID,",
                                    "2. *Description*: protein description,",
                                    "3. *GeneName*: Gene Symbol,",
                                    "4. *Peptide_Sequence*: peptide sequence,",
                                    "5. *Peptide_Modifications*: peptide modifications,",
                                    "6. *Peptide_Position*: start and end position of the peptide within the protein sequence, defined UniprotID,",
                                    "7. *Peptide_Tryptic*: peptide tryptic digestion status (fully tryptic, N-semi tryptic, C-semi tryptic, non tryptic)",
                                    NA,
                                    "And for each comparison:",
                                    "8. *class*: defined according to the fold change, p-value and abundance thresholds specified in the input: \"+\" up-regulated protein/peptide, \"-\" down-regulated protein/peptide, \"=\" invariant protein/peptide",
                                    "9. *log2_FC*: protein/peptide log2 transformed fold change",
                                    "10. *p_val*: protein/peptide contrast p-value",
                                    "11. *p_adj*: protein/peptide adjusted p-value (FDR after BH correction)",
                                    "12. *log2_expr*: protein/peptide log2 average abundance"
))

#Export table with SE e MEAN
prot_id <- unique(psm_peptide_table[,c("Accession","GeneName")]) %>% group_by(GeneName) %>% summarize_all(toString) %>% left_join(unique(psm_peptide_table[,c("Accession","Description","GeneName")]), 
                                                                                                                                  by = "GeneName", 
                                                                                                                                  multiple = "first",
                                                                                                                                  suffix = c(".id", ".old"))
protein_DE <- unique(left_join(prot_id[,c("Accession.id","Description","GeneName")], toPrint, by=c("GeneName" = "GeneSymbol")))
colnames(protein_DE)[1:3] <- c("Accession","Description","GeneName")
peptide_DE <- left_join(rownames_to_column(psm_peptide_table), toPrint_pep, by=c("rowname" = "id"))[,-c(1)]
colnames(peptide_DE)[1:7] <- c("Accession","Description","GeneName","Peptide_Sequence","Peptide_Modifications","Peptide_Position","Peptide_Tryptic")
df_to_save<-list("README"=readme_sheet,
                 "protein_DE"=protein_DE,
                 "peptide_DE"=peptide_DE)
writexl::write_xlsx(df_to_save,paste0(dirOutput,subfold_Tab,"differential_expression.xlsx"))

remove(deps_df,toPrint,deps_pep_df,toPrint_pep,df_to_save, protein_DE, peptide_DE)
message("Differentation analysis DONE.")

```

```{r number_deps, warning=FALSE, echo=FALSE, results='asis', eval=eval_single_Cond, fig.height=max(min(20,length(unique(deps_l_df$comp))*0.75),2)}
shiny::setProgress(0.60, detail = "Count DEPs...")
cat("In the plot are represented graphically the number of DEPs for each contrast. Tab **Proteins** for the differentially expressed proteins, **Peptides** for the number of the differentially expressed peptides. \n \n")
cat(" \n \n")
cat("#### 2.2. Number of differentially expressed proteins and peptides for each comparison {.tabset}  \n")
#Execute only if found at least one gene differentiated
if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  lolli_df <- data.table("comp"=deps_l_df$comp[which(deps_l_df$class == "+" | deps_l_df$class == "-")], 
                         "class"=factor(deps_l_df$class[which(deps_l_df$class == "+" | deps_l_df$class == "-")]))
  lolli_df <- lolli_df[ , .(N = .N), by=c("comp","class")]
  lolli_df$id <- str_c(lolli_df$comp, lolli_df$class, sep="_")
  
  col_vec<-as.vector(t(color_constrast))
  names(col_vec)[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]]<-paste0(lolli_df$comp[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]], "_+")
  names(col_vec)[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 0]]<-paste0(lolli_df$comp[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]], "_-")
  
  pDEPs<-deps_b2b_lollipop(input_df=lolli_df, break_vec=seq(0,plyr::round_any(max(lolli_df$N)*1.2, if(max(lolli_df$N)>90){100}else{10}, f = ceiling),
                                                            round((plyr::round_any(max(lolli_df$N)*1.2, if(max(lolli_df$N)>90){100}else{10}, f = ceiling))/5, 0)), 
                           fill_vec = col_vec, color_vec = col_vec, char_max = 30, position_dodge = if(length(unique(deps_l_df$comp))>1){0.08}else{0.05})
  
  cat("##### Proteins \n")
  print(pDEPs)
  cat(" \n \n")

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_expr,"DE_protein_barplot.pdf"), pDEPs, device=cairo_pdf, units = c("in")))
  remove(pDEPs,cmd,mds_cmdscale)
}else{
  message("No gene differentiated discovered.")
  cat("No gene differentiated discovered.")
}
#Peptides
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat(" \n \n")
  lolli_df <- data.table("comp"=deps_pep_l_df$comp[which(deps_pep_l_df$class == "+" | deps_pep_l_df$class == "-")], 
                         "class"=factor(deps_pep_l_df$class[which(deps_pep_l_df$class == "+" | deps_pep_l_df$class == "-")]))
  lolli_df <- lolli_df[ , .(N = .N), by=c("comp","class")]
  lolli_df$id <- str_c(lolli_df$comp, lolli_df$class, sep="_")
  
  col_vec<-as.vector(t(color_constrast))
  names(col_vec)[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]]<-paste0(lolli_df$comp[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]], "_+")
  names(col_vec)[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 0]]<-paste0(lolli_df$comp[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]], "_-")
  
  pDEPs<-deps_b2b_lollipop(input_df=lolli_df, break_vec=seq(0,plyr::round_any(max(lolli_df$N)*1.2, if(max(lolli_df$N)>90){100}else{10}, f = ceiling),
                                                            round((plyr::round_any(max(lolli_df$N)*1.2, if(max(lolli_df$N)>90){100}else{10}, f = ceiling))/5, 0)), 
                           fill_vec = col_vec, color_vec = col_vec, char_max = 30, position_dodge = if(length(unique(deps_l_df$comp))>1){0.08}else{0.05})

  cat("##### Peptides \n")
  print(pDEPs)
  cat(" \n \n")

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_expr,"DE_peptide_barplot.pdf"), pDEPs, device=cairo_pdf, units = c("in")))
  remove(pDEPs,cmd,mds_cmdscale)
}else{
  message("No gene differentiated discovered.")
  cat("No gene differentiated discovered.")
}
```

```{r volcano_protein, fig.height=6, fig.width=6, warning=FALSE, echo=FALSE, results='asis', eval=(eval_single_Cond & (deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0))}
cat(" \n \n")
shiny::setProgress(0.63, detail = "Perform volcano plot...")
if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat("#### 2.3. Volcano plots  \n")
  cat("Differentially expressed proteins/peptides are displayes according to the thresholds set in the input. \n \n ")
  cat(" - \"+\" up-regulated protein/peptìde \n ")
  cat(" - \"-\" down-regulated protein/peptìde \n ")
  cat(" - \"=\" invariant protein/peptìde \n \n ")
  cat("Top enriched proteins/peptides are labeled. \n")
  cat(" \n \n")
  
  plotlist = list()
  
  for(comp in unique(deps_l_df$comp)){
    col <- if(pval_fdr){"p_adj"}else{"p_val"}
    input_df <- deps_l_df[which(deps_l_df$comp == comp),]
    input_df$log2_FC <- round(input_df$log2_FC, digits = 2)
    input_df[,col] <- round(-log10(input_df[,col]), digits = 2)
    
    cmd<-ggplot(data=input_df, aes(x=log2_FC, y=if(pval_fdr){p_adj}else{p_val}, col=class, text = paste('</br>Gene: ', id,
                                                                                                        '</br>Class: ', class,
                                                                                                        '</br>Log2_FC: ', log2_FC,
                                                                                                        '</br>',if(pval_fdr){"P_adj"}else{"P_val"},': ',if(pval_fdr){p_adj}else{p_val}))) +
      geom_point(pch=20,cex=2) +
      geom_hline(yintercept=-log10(pval_thr), col="black") +
      geom_vline(xintercept=c(-fc_thr, fc_thr), col="black") +
      ggtitle(paste0("Volcano Plot of ",comp)) +
      ylab(if(pval_fdr){"-log10(fdr)"}else{"-log10(p_val)"}) +
      scale_color_manual(values=c("+"=color_constrast[comp,"color_constrast"], "-"=color_constrast[comp,"color_constrast_dark"],"="= "grey70")) +
      scale_x_continuous(limits = c(min(-max(abs(input_df$log2_FC)),-3), max(max(abs(input_df$log2_FC)),3))) +
      scale_y_continuous(limits = c(0, max(max(abs((if(pval_fdr){input_df$p_adj}else{input_df$p_val}))),4))) +
      theme_bw(base_size = bs, base_family = bf)
    
    col <- if(pval_fdr){"p_adj"}else{"p_val"}
    labels <- c((input_df %>% filter(class == '+'))[order(-(input_df %>% filter(class == '+'))[,"log2_FC"], (input_df %>% filter(class == '+'))[,col]),][1:5,"id"],
                (input_df %>% filter(class == '-'))[order((input_df %>% filter(class == '-'))[,"log2_FC"], (input_df %>% filter(class == '-'))[,col]),][1:5,"id"])
    
    a <- list()
    for (i in seq_len(length(labels))) {
      m <- labels[i]
      a[[i]] <- list(
        x = input_df[which(input_df$id %in% m),"log2_FC"],
        y = (input_df[which(input_df$id %in% m), col]),
        text = m,
        xref = "x",
        yref = "y",
        showarrow = TRUE,
        arrowhead = 0.5,
        ax = 20,
        ay = -40
      )
    }
    plotlist[[comp]] = ggplotly(cmd, tooltip = c("text"))
  }
}

cat("#### 2.3.1. Volcano plots of Proteins {.tabset}  \n")
cat(" \n \n")
in_tabs(plotlist, labels = names(plotlist), level = 4L)
cat(" \n \n")

```

```{r volcano_pep, fig.height=6, fig.width=6, warning=FALSE, echo=FALSE, results='asis', eval=(eval_single_Cond & (deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0))}
cat(" \n \n")
shiny::setProgress(0.65, detail = "Perform volcano plot...")
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  
  plotlist = list()
  
  for(comp in unique(deps_pep_l_df$comp)){
    input_df <- na.omit((deps_pep_l_df[which(deps_pep_l_df$comp == comp),])[order(deps_pep_l_df$id),])
    pos<-lapply(str_match_all(str_split(psm_peptide_table$`Position in Master Proteins`,";",n=1),"\\[(.*?)\\]"), function(x){x[,1][1]})
    labels<-str_c(psm_peptide_table$GeneName,pos,sep="_")
    input_df$id<-labels
    input_df$log2_FC <- round(input_df$log2_FC, digits = 2)
    input_df[,col] <- round(-log10(input_df[,col]), digits = 2)
    
    cmd<-ggplot(data=input_df, aes(x=log2_FC, y=if(pval_fdr){p_adj}else{p_val}, col=class, text = paste('</br>Gene: ', id,
                                                                                                        '</br>Class: ', class,
                                                                                                        '</br>Log2_FC: ', log2_FC,
                                                                                                        '</br>',if(pval_fdr){"P_adj"}else{"P_val"},': ',if(pval_fdr){p_adj}else{p_val}))) +
      geom_point(pch=20,cex=2) +
      geom_hline(yintercept=-log10(pval_thr), col="black") +
      geom_vline(xintercept=c(-fc_thr, fc_thr), col="black") +
      ggtitle(paste0("Volcano Plot of ",comp)) +
      ylab(if(pval_fdr){"-log10(fdr)"}else{"-log10(p_val)"}) +
      scale_color_manual(values=c("+"=color_constrast[comp,"color_constrast"], "-"=color_constrast[comp,"color_constrast_dark"], "="="grey70")) +
      scale_x_continuous(limits = c(min(-max(abs(input_df$log2_FC)),-3), max(max(abs(input_df$log2_FC)),3))) +
      scale_y_continuous(limits = c(0, max(max(abs((if(pval_fdr){input_df$p_adj}else{input_df$p_val}))),4))) +
      theme_bw(base_size = bs, base_family = bf)
    
    col <- if(pval_fdr){"p_adj"}else{"p_val"}
    labels <- c((input_df %>% filter(class == '+'))[order(-(input_df %>% filter(class == '+'))[,"log2_FC"], (input_df %>% filter(class == '+'))[,col]),][1:5,"id"],
                (input_df %>% filter(class == '-'))[order((input_df %>% filter(class == '-'))[,"log2_FC"], (input_df %>% filter(class == '-'))[,col]),][1:5,"id"])
    
    a <- list()
    for (i in seq_len(length(labels))) {
      m <- labels[i]
      a[[i]] <- list(
        x = input_df[which(input_df$id %in% m),"log2_FC"],
        y = (input_df[which(input_df$id %in% m), col]),
        text = m,
        xref = "x",
        yref = "y",
        showarrow = TRUE,
        arrowhead = 0.5,
        ax = 20,
        ay = -40
      )
    }
    plotlist[[comp]] = ggplotly(cmd, tooltip = c("text"))
  }
}

cat("#### 2.3.2. Volcano plot of Peptides {.tabset}  \n")
cat(" \n \n")
in_tabs(plotlist, labels = names(plotlist), level = 4L)
cat(" \n \n")

```

```{r MDS_prot_deps, warning=F, message=F, echo=F, results='asis', eval=eval_single_Cond}
  shiny::setProgress(0.67, detail = "Perform MDS...")
if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat("#### 2.4. MDS based on differentially expressed proteins and peptides {.tabset}  \n " )
  cat("Multidimensional scaling (MDS) are performed on normalized abundances of differentially expressed Proteins and Peptides. \n")
  cat(" \n \n")  #Select only genes that are differentiated and print PCA of samples
  deps_vec_all<- deps_l_df %>% dplyr::filter(class!="=") %>% pull(id) %>% unique() %>% sort()
  
  sample_data<-t(dat_gene[(deps_vec_all),])
  sample_distances <- dist(sample_data, method = "euclidean")
  
  mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
  colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
  mds_cmdscale$sample <- rownames(mds_cmdscale)
  
  mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno))
  #Take correct order of color
  cc<-mds_cmdscale$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
    names(cc)<-unique(mds_cmdscale$condition)
  } else{
    names(cc)<-mds_cmdscale$condition
  }
  cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
    geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
    geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
    scale_colour_manual(values=cc[unique(names(cc))]) +
    theme_bw(base_size = bs, base_family = bf) +
    theme(legend.position = "right", panel.grid.minor=element_blank())
  
  cat("##### Proteins \n")
  print(cmd)
  cat(" \n \n")
  
  ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"DE_mds_protein.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in"))
  
}

cat(" \n \n")
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  #Select only genes that are differentiated and print PCA of samples
  deps_vec_all<- deps_pep_l_df %>% dplyr::filter(class!="=") %>% pull(id) %>% unique() %>% sort()
  sample_data<-t(dat_pep[(deps_vec_all),])
  sample_distances <- dist(sample_data, method = "euclidean")
  
  mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
  colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
  mds_cmdscale$sample <- rownames(mds_cmdscale)
  
  mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno))
  #Take correct order of color
  cc<-mds_cmdscale$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
    names(cc)<-unique(mds_cmdscale$condition)
  } else{
    names(cc)<-mds_cmdscale$condition
  }
  cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
    geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
    geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
    scale_colour_manual(values=cc[unique(names(cc))]) +
    theme_bw(base_size = bs, base_family = bf) +
    theme(legend.position = "right", panel.grid.minor=element_blank())
  
  cat("##### Peptides \n")
  print(cmd)
  cat(" \n \n")
  
  ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"DE_mds_peptide.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in"))
  
  shiny::setProgress(0.69, detail = "Perform MDS...")
}

```

```{r pca_deps, warning=F, message=F, echo=F, results='asis', eval=eval_single_Cond}
if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){  
  
  shiny::setProgress(0.70, detail = "Perform PCA...")
  cat(" \n \n")
  cat("#### 2.5. PCA based on differentially expressed proteins and peptides {.tabset}  \n")
  cat("Principal component analysis (PCA) are performed on normalized abundances of differentially expressed Proteins and Peptides. \n")
  cat(" \n \n")
  
  deps_vec_all<- deps_l_df %>% dplyr::filter(class!="=") %>% pull(id) %>% unique() %>% sort()
  
  # sample_data<-t(dat_gene[toupper(deps_vec_all),])
  sample_data<-t(dat_gene[(deps_vec_all),])
  apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
  pc <- apca_prot$x[,1:2]
  
  pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
  pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
  pc<- merge(pc, c_anno, by = 0)
  pc$condition <- as.factor(pc$condition)
  
  ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
  ve <- ve[c(1, 2)]
  labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")
  
  #Take correct order of color
  cc<-pc$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(pc$condition))]
    names(cc)<-unique(pc$condition)
  } else{
    names(cc)<-pc$condition
  }
  #ggplot method
  p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
    geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
    geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
    scale_colour_manual(values=cc[unique(names(cc))]) +
    theme_bw(base_size = bs, base_family = bf) +
    theme(legend.position = "right", panel.grid.minor=element_blank()) +
    xlab(labs[1]) +
    ylab(labs[2])
  
  cat("##### Proteins \n")
  print(p1)
  cat(" \n \n")
  
  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"DE_pca_protein.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))
  
  remove(sample_data,sample_distances,mds_cmdscale,cmd)
}


cat(" \n \n")
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  #Peptides
  deps_vec_all<- deps_pep_l_df %>% dplyr::filter(class!="=") %>%
    pull(id) %>% unique() %>% sort()
  
  sample_data<-t(dat_pep[(deps_vec_all),])
  apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
  pc <- apca_prot$x[,1:2]
  
  pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
  pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
  pc<- merge(pc, c_anno, by = 0)
  pc$condition <- as.factor(pc$condition)
  
  ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
  ve <- ve[c(1, 2)]
  labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")
  
  #Take correct order of color
  cc<-pc$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(pc$condition))]
    names(cc)<-unique(pc$condition)
  } else{
    names(cc)<-pc$condition
  }
  #ggplot method
  p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
    geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
    geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
    scale_colour_manual(values=cc[unique(names(cc))]) +
    theme_bw(base_size = bs, base_family = bf) +
    theme(legend.position = "right", panel.grid.minor=element_blank()) +
    xlab(labs[1]) +
    ylab(labs[2])
  
  cat("##### Peptides \n")
  print(p1)
  cat(" \n \n")
  
  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"DE_pca_peptide.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))
  remove(sample_data,sample_distances,mds_cmdscale,p1)
}

```


```{r enrichment_universe,message=F, warning=F,echo=F, eval=run_enrich_universe, results='asis'}
shiny::setProgress(0.75, detail = "Enrichment in progress whole Universe in background... \n Can require several minutes...")

message("Enrichment in progress whole Universe in background... \n Can require several minutes...")
#Perform enriched analysis with EnrichR
dbs<-NULL
if(enrichR_DB){
  dbs<-enrich_filter_DBs
}

p = callr::r_bg(
  func = function(g, pval_fdr_enrich, pval_enrich_thr,overlap_size_enrich_thr,dbs) {
    source("functions_2021.R")
    enrichRfnc_universe(g, pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr,dbs)
  },
  args = list(unique(psm_anno_df$symbol), pval_fdr_enrich, pval_enrich_thr,overlap_size_enrich_thr,dbs),
  stdout = "|",
  stderr = "|",
  error = getOption("callr.error", "error")
)

```

```{r enrichment_sms,message=F, warning=F,echo=F, eval=run_enrich, results='asis'}
shiny::setProgress(0.75, detail = "Enrichment in progress... \n Can require several minutes...")
cat(" \n \n")
cat("## 3. Functional enrichment analysis \n")
cat("Annotation enrichment analysis is performed using the web-based application [EnrichR](https://maayanlab.cloud/Enrichr/), against an updated collection of 98 databases covering Transcription, Pathways, Ontologies, Diseases, Drugs, Cell Types, Experimental Datasets. \n \n ")
cat("For each comparison enrichment is calculate over up-regulated proteins (UP), down-regulated proteins (DOWN), and their union (ALL). \n")
cat(" \n")
cat(paste0("- Statistical significance threshold: p.val < ",pval_enrich_thr," "))
cat(" \n")
cat(paste0("- Overlap size threshold for enrichment analysis: OverlapSize > ",overlap_size_enrich_thr," "))
cat(" \n")
if(run_enrich_universe){cat("- Execution of the enrichmentalso on all detected proteins.")}
def_val_height=  knitr::opts_chunk$get("fig.height")
message("Enrichment step with EnrichR in proress...")

```

```{r enrichment,message=F, warning=F,echo=F, eval=run_enrich, results='hide'}
doNextChunk <- tryCatch({
  dbs<-NULL
  if(enrichR_DB){
    dbs<-enrich_filter_DBs
  }
  #Perform enriched analysis with EnrichR
  enr_df<-enrichRfnc(in_df = deps_l_df, pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr, dbs)
  #Save in RData for possible further analysis
  enrich_df<-enr_df[which(enr_df$Significant == "TRUE" & enr_df$overlap_size>=overlap_size_enrich_thr),c(1:13)]
  save(enrich_df, file=paste0(dirOutput,subfold_Dat,"enrichment_DE.RData"))
  
  #Prepare the README
  readme_sheet <- data.frame("INFO"=c(NA,
                                      "Excel file containing a selection of enrichment results starting from differentially expressed proteins. 
                                Terms are selected according to significance thresholds specified in the input (Default: adj.P.Value < 0.05, Overlap Size >= 5)",
                                NA,
                                "Enrichment columns:",
                                "1. *input_name*: comparison name,",
                                "2. *anno_name*: enriched name term,",
                                "3. *anno_class*: dataset,",
                                "4. *overlap_sive*: DEPs in term,",
                                "5. *p_value*: p-value,",
                                "6. *fdr*: adjusted p-value (FDR after BH correction),",
                                "7. *odds_ratio*: ",
                                "8. *combined_score*: combined score provide by EnrichR,",
                                "9. *input_size*: DEPs of the comparison,",
                                "10. *anno_size*: number protein of the term,",
                                "11. *overlap_input_ratio*: overlap_size/input_size",
                                "12. *overlap_anno_ratio*: overlap_size/anno_size",
                                "13. *overlap_ids*: gene symbols identified in the term"
  ))
  writexl::write_xlsx(enrich_df,
                      path = paste0(dirOutput,subfold_Tab,"enrichment_DE.xlsx"))
  remove(enrich_df)
  
  dir.create(file.path(dirOutput,subfold_Fig,subfold_enrich), showWarnings = FALSE)
  dirOutput_enr=paste0(dirOutput,subfold_Fig,subfold_enrich)
  #LOAD category EnrichR
  dbs_default <- read_tsv("dbs_enrichR.txt", col_names = FALSE) %>% as.data.frame()
  dbs_category <- dbs_default %>% split(f = as.factor(.$X2))
  TRUE
},
error=function(cond){
  print("\n ERROR: An error occur when connect to EnrichR. \n ")
  FALSE
})
message("Enrichment DONE.")
shiny::setProgress(0.77, detail = "Done Enrichment...")
knitr::opts_chunk$set(comment = NA)
```


```{r enrichment_plots_all, echo=F, message=F, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  #Select DEPs in the DBs of interest
  annos<- enrich_filter_DBs
  
  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)
  
  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  
  #Select the ALL column (UP union DOWN)
  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
}
```

```{r enrichment_plots_all_2, echo=F, message=FALSE, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% intersect(unique(enr_sele_df$anno_class), enrich_filter_DBs))})

  col_vec<-as.vector((color_constrast))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                             size_col="log2_OR",
                                             color_col="input_name",
                                             color_vec=col_vec,
                                             shape_vec=c(16,21),
                                             shape_col = "Significant",
                                             fill_col = "Significant",
                                             char_max=60) +guides(color=F, shape = guide_legend(override.aes = list(size=4)))
    }
  }    
  
  tryCatch({
    cat("#### 3.1. Top enrichments in selected annotation databases (ALL). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
    cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
    cat("**Differentially expressed proteins (ALL)** \n ")
    cat(" \n \n")
    
    for(db in names(plotlist)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), "anno_name"]))*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist)){
      name_list[db]<-paste0(dirOutput_enr,"enr_DE_keysources_",db,".pdf")
      ggsave(name_list[db], plotlist[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_DE_keysources.pdf"))
    unlink(name_list)
    remove(plotlist, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.77, detail = "Plotting enrichment results...")
```

```{r enrichment_plots, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  #Select DEPs in the DBs of interest
  #Filter the DEPs taking only the ones from the desired DBs
  annos<- enrich_filter_DBs
  
  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  !str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)
  
  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  
  #Select the results divided in up and down
  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
}
```

```{r enrichment_plots_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  #Print the plot
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% intersect(unique(enr_sele_df$anno_class), enrich_filter_DBs))})

  col_vec<-as.vector(t(color_constrast))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist2 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      
      plotlist2[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                              size_col="log2_OR",
                                              color_col="input_name",
                                              color_vec = col_vec,
                                              shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                                              shape_col = "Group",
                                              fill_col = "Significant",
                                              char_max=60) + 
        guides(color=F, shape = guide_legend(override.aes = list(shape = c(16,21),size=4), title = "Significant"), fill=F)
    }
  }
  

  tryCatch({
    cat("#### 3.2. Top enrichments in selected annotation databases (UP,DOWN). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
    cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
    cat("**Up-regulated and down-regulated proteins (UP,DOWN)** \n ")
    cat(" \n \n")
    for(db in names(plotlist2)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist2[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), "anno_name"]))*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist2)){
      name_list[db]<-paste0(dirOutput_enr,"enr_updown_keysources_",db,".pdf")
      ggsave(name_list[db], plotlist2[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_updown_keysources.pdf"))
    unlink(name_list)
    remove(plotlist2, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.79, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_all_terms, echo=F, message=F, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  lookup_words<-enrich_filter_term
  
  enr_sele_names<-NULL
  #For each pattern search in DEPs name
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }
  
  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_terms_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% unique(enr_sele_df$anno_class))})

  col_vec<-as.vector((color_constrast))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist3 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist3[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                              size_col="log2_OR",
                                              color_col="input_name",
                                              color_vec=col_vec,
                                              shape_vec=c(16,21),
                                              shape_col = "Significant",
                                              fill_col = "Significant",
                                              char_max=60) + guides(color=F, shape = guide_legend(override.aes = list(size=4)))
    }
  }
  tryCatch({
    cat("#### 3.3. Top enrichments based on selected keywords (ALL). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
    cat("The dot plots shows the top significant terms containing selected keywords. \n")
    cat("Differentially expressed proteins (ALL) \n")
    cat("**List of terms to search:**")
    cat(" \n")
    cat(paste(enrich_filter_term, collapse=", "))
    
    cat(" \n \n")
    for(db in names(plotlist3)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist3[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), c("anno_name","anno_class")])[,"anno_name"])*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist3)){
      name_list[db]<-paste0(dirOutput_enr,"enr_DE_keywords_",db,".pdf")
      ggsave(name_list[db], plotlist3[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_DE_keywords.pdf"))
    unlink(name_list)
    remove(plotlist3, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
  
}

shiny::setProgress(0.82, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_terms, echo=F, message=F, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  lookup_words<-enrich_filter_term
  enr_sele_names<-NULL
  
  #For each patter we want, search in each DEPs name to find it
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        !str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }
  
  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_terms_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% unique(enr_sele_df$anno_class))})

  col_vec<-as.vector(t(color_constrast))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist4 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist4[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                              size_col="log2_OR",
                                              color_col="input_name",
                                              color_vec = col_vec,
                                              shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                                              shape_col = "Group",
                                              fill_col = "Significant",
                                              char_max=60)  + guides(color=F, shape = guide_legend(override.aes = list(shape = c(16,21),size=4), title = "Significant"), fill=F)
    }
  }
  tryCatch({
    cat("#### 3.4. Top enrichments based on selected keywords (UP,DOWN). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
    cat("The dot plots shows the top significant terms containing selected keywords \n")
    cat("Up-regulated and down-regulated proteins (UP,DOWN) \n")
    cat("**List of terms to search:**")
    cat(" \n")
    cat(paste(enrich_filter_term, collapse=", "))
    cat(" \n \n")
    for(db in names(plotlist4)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist4[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), c("anno_name","anno_class")])[,"anno_name"])*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist4)){
      name_list[db]<-paste0(dirOutput_enr,"enr_updown_keywords_",db,".pdf")
      ggsave(name_list[db], plotlist4[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_updown_keywords.pdf"))
    unlink(name_list)
    remove(plotlist4, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
  
}

shiny::setProgress(0.85, detail = "Plotting enrichment results...")
```


```{r enrichment_universe_get, message=F, warning=F,echo=F, eval=run_enrich_universe, results='asis'}
shiny::setProgress(0.77, detail = "Enrichment in progress whole Universe in background... \n Can require several minutes...")

#Wait 10 minutes. If do not end in 10 minutes, kill the process
hide_res<-p$read_output()
p$wait(30000)
for (i in 1:15) {
  p$read_output()
  p$wait(1000*60)  
}

if(p$is_alive() | is.null(p$get_result())){
  p$kill()
  print("\n ERROR: An error occur when connect to EnrichR for the enrichemnt of the whole universe of the experiment. \n ")
  run_enrich_universe <- FALSE
} else{
  enr_df_universe<-p$get_result()
  p$kill()
  #Save in RData for possible further analysis
  enrich_all_df <- (enr_df_universe %>% dplyr::filter(Significant == "TRUE", overlap_size>=overlap_size_enrich_thr))[,c(1:13)]
  save(enrich_all_df, file=paste0(dirOutput,subfold_Dat,"enrichment_allproteins.RData"))
  
  writexl::write_xlsx(enrich_all_df,
                      path = paste0(dirOutput,subfold_Tab,"enrichment_allproteins.xlsx"))
  remove(enrich_all_df)
  
  message("Enrichment whole universe DONE.")
}

shiny::setProgress(0.79, detail = "Done Enrichment of universe...")
```

```{r enrichment_plots_all_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}
if(length(enrich_filter_DBs) > 0){
  #Select DEPs in the DBs of interest
  annos<- enrich_filter_DBs
  
  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)
  
  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  
  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))
  
  #Select the ALL column (UP union DOWN)
  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_DBs) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% intersect(unique(enr_sele_df$anno_class), enrich_filter_DBs))})

  col_vec<-as.vector(c((color_constrast), "grey30", "grey70"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  col_vec["Universe_all"]<-"grey50"

  plotlist = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                             size_col="log2_OR",
                                             color_col="input_name",
                                             color_vec=col_vec,
                                             shape_vec=c(16,21),
                                             shape_col = "Significant",
                                             fill_col = "Significant",
                                             char_max=60) +guides(color=F, shape = guide_legend(override.aes = list(size=4)))
    }
  }    
  
  tryCatch({
    cat("#### 3.1. Top enrichments in selected annotation databases (ALL). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
    cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
    cat("**Differentially expressed proteins (ALL)** \n ")
    cat(" \n \n")
    
    for(db in names(plotlist)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), "anno_name"]))*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist)){
      name_list[db]<-paste0(dirOutput_enr,"enr_DE_keysources_",db,".pdf")
      ggsave(name_list[db], plotlist[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_DE_keysources.pdf"))
    unlink(name_list)
    remove(plotlist, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.79, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_DBs) > 0){
  annos<- enrich_filter_DBs
  
  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  !str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)
  
  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  
  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))
  
  #Select the results divided in up and down
  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all") | str_ends(input_name,"Universe_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_DBs) > 0){
  #Print the plot
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% intersect(unique(enr_sele_df$anno_class), enrich_filter_DBs))})

  col_vec<-as.vector(c(t(color_constrast), "grey50"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist2 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      
      plotlist2[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                              size_col="log2_OR",
                                              color_col="input_name",
                                              color_vec = col_vec,
                                              shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                                              shape_col = "Group",
                                              fill_col = "Significant",
                                              char_max=60) + 
        guides(color=F, shape = guide_legend(override.aes = list(shape = if("Universe_all" %in% enr_sele_df$input_name){c(17,24,16)}else{c(17,24)},size=4), title = "Significant"), fill=F)
    }
  }
  
  tryCatch({
    cat("#### 3.2. Top enrichments in selected annotation databases (UP,DOWN). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
    cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
    cat("**Up-regulated and down-regulated proteins (UP,DOWN)** \n ")
    cat(" \n \n")
    for(db in names(plotlist2)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist2[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), "anno_name"]))*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist2)){
      name_list[db]<-paste0(dirOutput_enr,"enr_updown_keysources_",db,".pdf")
      ggsave(name_list[db], plotlist2[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_updown_keysources.pdf"))
    unlink(name_list)
    remove(plotlist2, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.79, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_all_terms_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}
if(length(enrich_filter_term) > 0){

  lookup_words<-enrich_filter_term
  
  enr_sele_names<-NULL
  #For each pattern search in DEPs name
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }
  
  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))
  
  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_terms_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_term) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% intersect(unique(enr_sele_df$anno_class), enrich_filter_DBs))})

  col_vec<-as.vector(c((color_constrast), "grey30", "grey70"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  col_vec["Universe_all"]<-"grey50"
  plotlist3 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist3[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                              size_col="log2_OR",
                                              color_col="input_name",
                                              color_vec=col_vec,
                                              shape_vec=c(16,21),
                                              shape_col = "Significant",
                                              fill_col = "Significant",
                                              char_max=60) + guides(color=F, shape = guide_legend(override.aes = list(size=4)))
    }
  }
  tryCatch({
    cat("#### 3.3. Top enrichments based on selected keywords with Universe background (ALL). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
    cat("The dot plots shows the top significant terms containing selected keywords. \n")
    cat("Differentially expressed proteins (ALL) \n")
    cat("**List of terms to search:**")
    cat(" \n")
    cat(paste(enrich_filter_term, collapse=", "))
    
    cat(" \n \n")
    for(db in names(plotlist3)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist3[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), c("anno_name","anno_class")])[,"anno_name"])*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist3)){
      name_list[db]<-paste0(dirOutput_enr,"enr_DE_keywords_",db,".pdf")
      ggsave(name_list[db], plotlist3[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_DE_keywords.pdf"))
    unlink(name_list)
    remove(plotlist3, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
  
}

shiny::setProgress(0.82, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_terms_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_term) > 0){

  lookup_words<-enrich_filter_term
  
  enr_sele_names<-NULL
  
  #For each patter we want, search in each DEPs name to find it
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        !str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }
  
  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))
  
  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all") | str_ends(input_name,"Universe_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_terms_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_term) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% unique(enr_sele_df$anno_class))})

  col_vec<-as.vector(c(t(color_constrast), "grey50"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist4 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist4[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                              size_col="log2_OR",
                                              color_col="input_name",
                                              color_vec = col_vec,
                                              shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                                              shape_col = "Group",
                                              fill_col = "Significant",
                                              char_max=60)  + guides(color=F, 
                                                                     shape = guide_legend(override.aes = list(shape = if("Universe_all" %in% enr_sele_df$input_name){c(17,24,16)}else{c(17,24)},size=4), 
                                                                     title = "Significant"), fill=F)
    }
  }
  tryCatch({
    cat("#### 3.4. Top enrichments based on selected keywords with Universe background (UP,DOWN). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
    cat("The dot plots shows the top significant terms containing selected keywords \n")
    cat("Up-regulated and down-regulated proteins (UP,DOWN) \n")
    cat("**List of terms to search:**")
    cat(" \n")
    cat(paste(enrich_filter_term, collapse=", "))
    cat(" \n \n")
    for(db in names(plotlist4)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist4[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), c("anno_name","anno_class")])[,"anno_name"])*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist4)){
      name_list[db]<-paste0(dirOutput_enr,"enr_updown_keywords_",db,".pdf")
      ggsave(name_list[db], plotlist4[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_updown_keywords.pdf"))
    unlink(name_list)
    remove(plotlist4, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
  
}

shiny::setProgress(0.85, detail = "Plotting enrichment results...")
```


```{r selection_genes, echo=F, message=F, warning=F, eval=run_STRING, results='asis'}
shiny::setProgress(0.90, detail = "Network analysis in progress... \n Can require several minutes...")
cat(" \n \n")
cat("## 4. Protein-protein interaction network analysis of differentially expressed proteins \n")
cat(paste0("Protein-protein interactions (PPIs) are crucial for understanding cell physiopathology. PPI analysis of differentially expressed proteins is based on the [STRING](https://string-db.org/) database. Only interactions with score > 600 are considered for building the network. Communities within the network are identified with the Clauset-Newman-Moore (CNM) algorithm. \n \n"))
cat("For a better visualization of the network, only the top 500 differential proteins are considered for each contrast.")
#Reset of height of plots
if(run_enrich){knitr::opts_chunk$set(fig.height = def_val_height)}

#Select up- down- regualted genes, if 0 genes are find, the all network analysis is skipped
g_sel_comp<-list()
doComp<-list()
for (comp in unique(deps_l_df$comp)){
  tmp_deps<-deps_l_df[(deps_l_df$class != "=" & deps_l_df$comp == comp), ]
  genes<-(tmp_deps[order(tmp_deps$p_val),])[1:min(500, nrow(tmp_deps)),"id"]
  if(length(genes)>0){g_sel_comp[[comp]]<-genes}else{g_sel_comp[[comp]]<-list()}
  if(length(g_sel_comp[[comp]])!=0){doComp[comp]=TRUE}
}
if(length(doComp)==0 | all(doComp==F)){
  doNextChunk_STRING<-FALSE
  print("WARNING: Not possible to continue with the STRING network evaluation. No protein up- or down-regulated.\n")
}else{
  doNextChunk_STRING<-TRUE
  dir.create(file.path(dirOutput,subfold_Fig,subfold_net), showWarnings = FALSE)
  dirOutput_net=paste0(dirOutput,subfold_Fig,subfold_net)
}

shiny::setProgress(0.93, detail = "Network analysis done... \n Can require several minutes...")
```

```{r network_string_communities, echo=F, message=F, warning=F, eval = doNextChunk_STRING, results='hide'}
message("Build PPI network with STRING in progress... \n Can require several minutes...")

rm(cluster_ext, cmd, comm, dat_psm,df_to_save,dt_links,edge_list,el,enr_sele_df,enr_sele_names, matches, mds_cmdscale, psm_anno_df, 
   sample_data, annos, colToKeep, comp, currentTime, dirOutput_1,dirOutput_2, doNextChunk,
   f, filenames, filt_genes, g_sel, genes, l, links, lookup_words, name_list, net_genes, now, res, sample_distances, word,
   batch_annotation,comBat_df_gene, comBat_df_pep, dat_gene_long,dat_pep_long,
   gene_name, input_df, pos, prot_intensity_long, deps_vec_all, i, labels, labels_down, labels_up, list.of.packages,
   list.of.packages.bio, new.packages, prot_find, template_files)
gc()
#Read STRINGdb edges for human
#Human id --> 9606
#Mouse id --> 10090
string_db <- STRINGdb$new(version="11.5", species=taxonomy_NCBI, score_threshold=500, input_directory="STRINGdb/")
gene_name<-unlist(g_sel_comp) %>% unique() %>% as.data.frame()
colnames(gene_name)<-c("gene_id")
string_mapped <- string_db$map(gene_name, "gene_id", removeUnmappedRows = TRUE)
links_string <- string_db$get_interactions(string_mapped$STRING_id)
links_string$from <- string_mapped$gene_id[match(links_string$from,string_mapped$STRING_id)]
links_string$to <- string_mapped$gene_id[match(links_string$to,string_mapped$STRING_id)]
string_gene_df<-data_frame("gene1"=links_string$from,"gene2"=links_string$to,"weigth"=links_string$combined_score)


if(nrow(string_gene_df) > 0){
  data_comms_df<-list()
  data_comms_list<-list()
  data_dt_links<-list()
  colour_vector<-list()
  #Cycle for each contrast
  for (comp in names(doComp)){
    # params ----
    thr_score <- 150 # define max strength of interaction
    #Select genes that are up or down regulated
    g_sel <- g_sel_comp[[comp]]
    if(all(unique(!grepl("[[:lower:]]",string_gene_df$gene1)))){
      g_sel<-toupper(g_sel)
    }else{
      g_sel<-str_to_title(g_sel)
    }
    #Find communities in STRING db
    comm <- suppressMessages(find_communities(g_sel, thr_score,string_gene_df))
    i_comms_df <- comm[["i_comms_df"]]
    data_comms_df[[comp]]<-i_comms_df
    i_comms_list <- comm[["i_comms_list"]]
    data_comms_list[[comp]]<-i_comms_list
    dt_links <- comm[["dt_links"]]
    data_dt_links[[comp]]<-dt_links
    
    colour_vector[[comp]] <- c(c(brewer.pal(n = 8, name = "Dark2")), color_base)
    colour_vector[[comp]] <- colour_vector[[comp]][1:length(i_comms_list)]
  }
  
  i_comms_df<-data_comms_df
  i_comms_list<-data_comms_list
  dt_links<-data_dt_links
  message("Network DONE.")
}else{
  print("WARNING: No strong interaction detected beetween the proteins. Usually too few proteins.")
  doNextChunk_STRING <- FALSE
  message("Network incomplete.")
}

shiny::setProgress(0.93, detail = "Generating network figures... \n Can require several minutes...")
```

```{r network_string, echo=F, message=F, warning=F, eval = doNextChunk_STRING, fig.width=12, results='asis'}
message("Plotting STRING network in progress...")
cat("#### 4.1. Size of protein communities within PPI networks  {.tabset}  \n")
cat(" \n \n")

for (comp in names(doComp)){
  scr_thr <-  200# visual
  links <- 2
  # Filter genes and links ----
  net_genes <- g_sel_comp[[comp]]
  if(all(unique(!grepl("[[:lower:]]",string_gene_df$gene1)))){
    net_genes<-toupper(net_genes)
  }else{
    net_genes<-str_to_title(net_genes)
  }
  net_edges <- subset(dt_links[[comp]], from%in%net_genes & to%in%net_genes) #select genes with weight>scr_thr
  net_edges<-net_edges[which(net_edges$weight > mean(net_edges$weight)*0.7),]
  
  gene_links<-table(c(net_edges$from,net_edges$to))
  filt_genes<-names(gene_links)[which(gene_links >= 2)] #remove isolated genes (leaves)
  net_edges<-subset(net_edges,from %in% filt_genes & to %in% filt_genes)
  
  net_edges$group_to<-"PP"
  net_edges<-unique(net_edges)
  # Vertices df ----
  gene_vertices<-data.frame(label=filt_genes)
  if(nrow(gene_vertices) != 0){
    rownames(gene_vertices)<-gene_vertices$label
    
    gene_vertices$Community<-(i_comms_df[[comp]])[as.character(gene_vertices$label),"comm_n"] #class=communities
    
    nc<-ggplot(gene_vertices, aes(x=Community, fill=Community)) +
      geom_bar(alpha=0.9, colour="white", width=0.4)+
      scale_x_discrete()+
      scale_fill_manual(values=colour_vector[[comp]], drop=FALSE)+
      theme_bw(base_size = bs) +
      labs(x = "Community", y = "# genes") +
      theme(legend.position = "none", 
            panel.grid.major.x = element_blank(),
            panel.grid.minor.x = element_blank(), 
            panel.grid.minor.y = element_blank())+
      ggtitle("Number of genes in each community", subtitle = paste0("Communities of condition: ",comp))
    
    cat("##### ",comp," \n")
    print(nc)
    cat(" \n \n")
    ggsave(paste0(dirOutput_net,gsub(comp, pattern = "\\/", replacement="vs"),"_communities_sizes.pdf"), nc, device=cairo_pdf, width = 4, height = 4, units = c("in"))
    
    write_tsv(data.frame("GeneSymbol"=gene_vertices$label, "Community"=gene_vertices$Community), 
              file = paste0(dirOutput_net,gsub(comp, pattern = "\\/", replacement="vs"),"_communities_sizes.txt"))
    
    # #BUILD NETWORK
    tb = tibble(v = c(net_edges$from, net_edges$to))
    d = as.vector(table(tb$v))
    nodes = mutate(gene_vertices, Degree = d)
    
    g <- graph_from_data_frame(net_edges, directed=TRUE, vertices=nodes)
    
    layouts <- if(length(nodes$label) > 400){c("kk")}else{c("fr","kk")}
    p = callr::r_bg(
      func = function(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts) {
        source("functions_2021.R")
        plot_networks(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts)
      },
      args = list(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts),
      stdout = "|",
      stderr = "|",
      error = getOption("callr.error", "error")
    )
    p$wait()
  
    cat(" \n \n")
    rm(net_genes, net_edges, gene_links, filt_genes, net_edges, gene_vertices, nc, net_net, 
       node_list_from, node_list_to, node_list, edge_list, g, name_list, l_list)
    gc()
  }
}

net_pdf<-list.files(dirOutput_net, pattern = "network.pdf", full.names = T)
if(length(net_pdf) > 0){
  cat("\n \n")
  message("Networking with STRING DONE")
  cat("\n \n")
  cat("#### 4.2. Network plots \n ")
  cat("\n \n Results inside folder: *network*")
  cat("\n")
  cat("\n \n The networks are not reported in this report. For each comparison, a 2-page pdf file is created inside the network folder. \n \n \n ")
  cat("Below is reported an example of the first comparison written in the *Design* file with layout Kamada-Kawai (KK)")
  cat(" \n \n")
  image_read_pdf(net_pdf[1], pages = pdf_info(net_pdf[1])$pages)
}else{
  cat("\n \n")
  cat("WARNING: Cannot be possible generate networks \n ")
}
message("Cleaning...")

shiny::setProgress(0.98, detail = "Network figures generated...")
```

```{r save_df, echo=F, message=F, warning=F, results='hide'}
tryCatch(unlink("enrich_plot.html"))
if(!(eval_single_Cond)){
  save(c_anno,
       dat_gene,
       dat_pep,
       psm_peptide_table,
       expr_avgse_df,
       expr_avgse_pep_df,
       formule_contrast,
       colour_vec,
       bf,
       bs,
       fc_thr, pval_thr, pval_enrich_thr, overlap_size_enrich_thr,
       file = paste0(dirOutput,subfold_Dat,"protn_env.RData"))
}else{
  save(c_anno,
       dat_gene,
       dat_pep,
       psm_peptide_table,
       deps_l_df,
       deps_pep_l_df,
       expr_avgse_df,
       expr_avgse_pep_df,
       formule_contrast,
       colour_vec,
       bf,
       bs,
       fc_thr, pval_thr, pval_enrich_thr, overlap_size_enrich_thr,
       file = paste0(dirOutput,subfold_Dat,"protn_env.RData"))
}
remove(list = ls()[-1])
gc()

shiny::setProgress(1, detail = "Saving RData...")
```
