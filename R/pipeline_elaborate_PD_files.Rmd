---
author: "Gabriele Tom√®, Toma Tebaldi"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  rmdformats::readthedown:
    css: custom_theme_report.css
    df_print: paged
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: true
params:
  doc_title: "Report of integrative pipeline for proteomics analysis"
  description: NA
  readPD_files: NA
  readMQ_files: NA
  file_input: NA
  file_prot: NA
  file_pep: NA
  filt_absent_value: "1"
  pval_fdr: NA
  signal_thr: "inf"
  fc_thr: "0.75"
  pval_thr: "0.05"
  batch_corr_exe: NA
  contr_design: NA
  prot_boxplot: NA
  run_enrich: NA
  run_enrich_universe: NA
  run_STRING: NA
  pval_fdr_enrich: NA
  pval_enrich_thr: "0.05"
  overlap_size_enrich_thr: 5
  enrich_filter_term: NA
  enrich_filter_DBs: NA
  enrichR_DB: NA
  dirOutput: NA
---

```{r settings, message=F, warning=F, echo=F,results='hide'}
shiny::setProgress(0, detail = "Initialize...")  # set progress to 50%
# require("knitr")
# library("rstudioapi")
# library(stringr)
# #find and set the home directory depending on the position of the current Rmd
# PATH_R_FILE<-paste(str_split(getSourceEditorContext()$path, "/")[[1]][1:(length(str_split(getSourceEditorContext()$path, "/")[[1]])-2)],collapse = "/")
# opts_knit$set(root.dir = PATH_R_FILE,
#               dev="cairo.pdf")
# setwd(PATH_R_FILE)
#
# #Create the output directory
# dirOutput_2="../outputResults/"
# dir.create(file.path("./",dirOutput_2), showWarnings = FALSE)
# currentTime = gsub(".*?([0-9]+).*?", "\\1", Sys.time())
# dirOutput_1=paste(currentTime,"/",sep = "")
# dir.create(file.path(dirOutput_2, dirOutput_1), showWarnings = FALSE)
# dirOutput=paste(dirOutput_2,dirOutput_1,sep = "")

dirOutput = params$dirOutput
#Auto-install needed library
list.of.packages <- c("ggrepel","tidyr","ggraph","graphlayouts","RColorBrewer",
                      "scales","igraph","data.table","qpdf","devtools",
                      "corrplot", "data.table", "ggplot2", "ggfortify","lazyeval",
                      "lubridate", "pheatmap", "reshape2","readr", "rlang", "rmdformats",
                      "tibble", "dplyr", "tidyr", "wesanderson","WGCNA","ggbeeswarm","ggthemes",
                      "extrafont","pdftools","magick")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) suppressMessages(suppressWarnings({install.packages(new.packages, dependencies = T)}))
list.of.packages.bio <- c("biomaRt","DEqMS","STRINGdb",
                          "GO.db", "impute", "preprocessCore", "pvca","sva")
new.packages <- list.of.packages.bio[!(list.of.packages.bio %in% installed.packages()[,"Package"])]
if(length(new.packages)) {
  if (!require("BiocManager", quietly = TRUE))
      install.packages("BiocManager")
  suppressMessages(suppressWarnings({BiocManager::install(new.packages)}))
}
list.of.packages <- c("proBatch", "PhosR")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) {
  suppressMessages(suppressWarnings({devtools::install_github("symbioticMe/proBatch", dependencies = T)}))
  suppressMessages(suppressWarnings({devtools::install_github("PYangLab/PhosR", dependencies = T)}))
}

#Load functions
suppressMessages(suppressWarnings({
  source("functions_2021.R") # new functions 2021
  #Library needed
  library('biomaRt')
  library('PhosR')
  library('DEqMS')
  library(ggrepel) # graphics
  library(tidyr)
  library(dplyr)
  library(tibble)
  library(ggraph)
  library(graphlayouts)
  library(RColorBrewer) # Color palettes
  library(scales) # heatmap colors scales
  library(geomnet) # network plots
  library(igraph) # Network analysis
  library(data.table)
  library(qpdf)
  library(STRINGdb)
  library("proBatch")
  library(ggbeeswarm)
  library(parallel)
  library(readr)
  library(stringi)
  library(stringr)
  library(pdftools)
  library(magick)
  library(extrafont)
}))

options(dplyr.summarise.inform = FALSE)

#Set font and size
loadfonts(quiet=T)
bs<-11      # point sizes in ggplot
bf<-"Arial" # font family in ggplot

# Color definition
color_base<-c("dodgerblue2", "#E31A1C", # red
              "green4", "#6A3D9A", # purple
              "#FF7F00", # orange
              "black", "gold1", "skyblue2", "#FB9A99", # lt pink
              "palegreen2","#CAB2D6", #lt purple
              "#FDBF6F", #lt orange
              "#9af7c9","#c0a0e6","#f5939a","#5fefee","#e8d388","#8abdff","#e3bf7a","#48c0f6","#ccb86f","#fafeaf",
              "#04bfe4","#ea92a8","#25cfe9","#ffbb97","#62e8ff","#ffd29b","#8fcbff","#aec87f","#b2c6ff","#aedf9b",
              "#ffb3c8","#81b97c","#ffcef0","#54bcae","#ffcab3","#7dd7ff","#ffe4ad","#81b0da","#ebffc5","#a7a8d5",
              "#bdffd0","#d6d2ff","#9fb282","#a5d8ff","#c9a395","#9bfff7","#ffcbce","#70b6ca","#faffdd","#88b3bc",
              "#d6ffdf","#a3e5ff","#b1ac8f","#ccffff","#b4bb9f","#7eb7a5","#c5dbc3","#a8b9ff","#74dfbc","#f2ace7")
colour_vec<-color_base

all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- difftime(Sys.time(), now)
      # return a character string to show the time
      all_times[[options$label]] <<- res
    }
  }
}))
knitr::opts_chunk$set(time_it = TRUE)

subfold_Fig <- "figures/"
subfold_Dat <- "data/"
subfold_Tab <- "tables/"
subfold_MDSPCA <- "PCA_MDS/"
subfold_expr <- "Expression/"
subfold_enrich <- "Enrichment/"
subfold_net <- "Network/"

shiny::setProgress(0.01, detail = "Initialize...")  # set progress to 50%
```

```{r load_settings, warning=FALSE, echo=F, message=FALSE, results='hide'}
message("Reading options")
# tpm<-getwd()
#Load the excel file with  the basic settings
# input_settings <- tryCatch({suppressMessages({readxl::read_excel("options.xlsx", col_names = F)})},
#                            error=function(cond){stop("Error: \'options.xlsx\' not present in the current folder. Follow the instruction in the README.")})
# input_settings <- input_settings[rowSums(is.na(input_settings)) != ncol(input_settings), ]
# #Read title and description
# bindingIsLocked("params", env = .GlobalEnv)
# unlockBinding("params", env = .GlobalEnv)
# if(!is.na(input_settings$...2[1])){params$doc_title<-input_settings$...2[1]}
description<-params$description
# input_settings<-input_settings[3:nrow(input_settings),]
#Read Platform of previuos quantification
# sw_analysis <-input_settings$...2[1]
# readPD_files <- readMQ_files <- FALSE
# if(sw_analysis == "PD"){ readPD_files <- TRUE
# }else if(sw_analysis == "MQ"){ readMQ_files <- TRUE
# }else { stop("Error: Incorrect plaftorm of quantification inserted. Write \'PD\' for Protein Discovery or \'MQ\' for MaxQuant.")}
readPD_files <- params$readPD_files
readMQ_files <- params$readMQ_files
#Read input directory
# dir_file_input<-input_settings$...2[2]
filenames<-list(params$file_input, params$file_pep, params$file_prot)
filt_absent_value=suppressWarnings(parse_double(params$filt_absent_value))
if(is.na(filt_absent_value)){
  message("Warning: parse error for the number of acceptable missing condition. Set default paramenter to 0\n")
  filt_absent_value <- 0
}
#Read input parameters for Limma
signal_thr=suppressWarnings(parse_double(params$signal_thr))
if(is.na(signal_thr)){signal_thr<- -Inf}
fc_thr=suppressWarnings(parse_double(params$fc_thr))
if(is.na(fc_thr)){
  message("Warning: parse error for Fold Change threshold. Set default paramenter to 0.75\n")
  fc_thr <- 0.75
}
pval_thr=suppressWarnings(parse_double(params$pval_thr))
if(is.na(pval_thr)){
  message("Warning: parse error for P.Value threshold. Set default paramenter to 5%\n")
  pval_thr <- 0.05
}
batch_corr_exe<-as.logical(params$batch_corr_exe)

# save(signal_thr, fc_thr, pval_thr, batch_corr_exe, readMQ_files, readPD_files, file="tmp.RData")
message(params$contr_design)
#Read the design
input_settings<-read_excel_allsheets(params$contr_design)[[1]]
contr_design<-data.frame(t(input_settings[1:nrow(input_settings),]))
contr_design<-data.frame(contr_design[,colSums(is.na(contr_design)) != nrow(contr_design) ])
if(ncol(contr_design) > 0){
  if(any(is.na(contr_design[3,]))){
    contr_design[3,]<-color_base[1:ncol(contr_design)]
  }
  contr_design<-data.frame(t(fill(contr_design, names(contr_design), .direction = "down")))
  contr_design[,2]<-unlist(lapply(contr_design[,2], function(x){ if("-" %in% x){str_replace_all(x,"-","_")}else{x}}))
  formule_contrast<-(contr_design[,1])
  names(formule_contrast)<-contr_design[,2]
  color_constrast<-contr_design[,3]
  names(color_constrast)<-contr_design[,2]

  darker.col = function(color, how.much = 50){
    colorRampPalette(c(color, "black"))(100)[how.much]
  }
  color_constrast_dark<-c()
  for(col in names(color_constrast)){
    color_constrast_dark[col]<-darker.col(color_constrast[col])
  }
  color_constrast<-cbind(color_constrast,color_constrast_dark)
}else{
  stop("Error: At least one contrast design is required for the analysis.")
}

#Read Proteins List for control boxplot
prot_boxplot<-na.omit(strsplit(params$prot_boxplot, split = "\\;|\\,|\\ |\\; |\\, ")[[1]])
boxplot_prot_exe <- FALSE
if(length(prot_boxplot)>0){ boxplot_prot_exe<-TRUE }
#Read enrich parameter
doNextChunk_STRING <- doNextChunk <- run_enrich <- run_STRING <- run_enrich_universe <- pval_fdr <- enrichR_DB <- FALSE
pval_fdr_enrich <- TRUE
pval_fdr <- as.logical(params$pval_fdr)
pval_fdr_enrich <- as.logical(params$pval_fdr_enrich)
run_enrich <- as.logical(params$run_enrich)
run_enrich_universe <- as.logical(params$run_enrich_universe)
enrichR_DB <- as.logical(params$enrichR_DB)
run_STRING <- as.logical(params$run_STRING)
# save(params, file = "tmp.RData")
pval_enrich_thr <- if(is.null(params$pval_enrich_thr)){0.05
                   }else if(is.double(params$pval_enrich_thr)){params$pval_enrich_thr
                   }else{parse_double(params$pval_enrich_thr)}
if(is.na(pval_enrich_thr)){
  message("Warning: parse error for p-value enrichment threshold. Set default paramenter to 0.05\n")
  pval_enrich_thr <- 0.05
}
overlap_size_enrich_thr=if(is.null(params$overlap_size_enrich_thr)){5
                         }else if(is.integer(params$overlap_size_enrich_thr)){params$overlap_size_enrich_thr
                         }else{parse_double(params$overlap_size_enrich_thr)}
if(is.na(overlap_size_enrich_thr)){
  message("Warning: parse error for Overlap size enrichment threshold. Set default paramenter to 5\n")
  overlap_size_enrich_thr <- 5
}

enrich_filter_term<-if(is.null(params$enrich_filter_term)){list()
}else if(params$enrich_filter_term == ""){list()
}else{na.omit(strsplit(params$enrich_filter_term, split = "\\;|\\,|\\; |\\, ")[[1]])}
enrich_filter_DBs<-if(is.null(params$enrich_filter_DBs)){list()
}else if(is.character(params$enrich_filter_DBs)){ na.omit(params$enrich_filter_DBs)
}else{list()}

remove(input_settings,contr_design,color_constrast_dark)
shiny::setProgress(0.05, detail = "Reading setting...")  # set progress to 50%
```


---
title: `r if(params$doc_title==""){"Report of integrative pipeline for proteomics analysis"}else{params$doc_title}`
---

`r description`

The following report summarizes the results obtained by the proTN integrative pipeline for proteomics analysis. Full results can be found in the output folder.

## Description of the output files

- ```protn_report.html```: complete report of the analysis with all pics and results of the enrichment.
- [**Data** folder](Data)
  - ```protn_env.RData```: RData object containing the essential variables and data for additional analyses in R.
```{r print_descr_enrich_dat, warning=FALSE, echo=F, message=FALSE, eval=run_enrich, results='asis'}
  cat("  - ```enrichment_DE.RData```: RData object containing enrichment results based on differentially expressed proteins \n")
```
```{r print_descr_enrich_uni_dat, warning=FALSE, echo=F, message=FALSE, eval=run_enrich_universe, results='asis'}
  cat("  - ```enrichment_allproteins.RData```: RData object containing enrichment results based on all detected proteins \n")
```

- [**Tables** folder](Tables) 
  - ```normalised_abundances.xlsx```: excel file containing abundance values generated by proTN. abundances are log2 transformed, normalized, imputed (and batch corrected). The file is organized in the following sheets:
    - **protein_per_sample**: protein abundances per sample.
    - **peptide_per_sample**: peptide abundances per sample.
    - **protein_per_condition**: protein abundances per condition (average & standard deviation), as defined in the Sample Annotation.
    - **peptide_per_condition**: peptide abundances per condition (average & standard deviation), as defined in the Sample Annotation.
    
  - ```differential_expression.xlsx```: excel file containing the results of differential analysis, according to the contrasts defined in the Design file. The file is organized in the following sheets:
    - **protein_DE**: protein differential expression results protein abundances per sample.
    - **peptide_DE**: peptide differential expression results.
    Annotation columns:
    - **Accession**: protein UniprotID
    - **Description**: protein description
    - **GeneName**: Gene Symbol
    - **Peptide_Sequence**: peptide sequence
    - **Peptide_Modifications**: peptide modifications
    - **Peptide_Position**: start and end position of the peptide within the protein sequence, defined UniprotID
    - **Peptide_Tryptic**: peptide tryptic digestion status (fully tryptic, N-semi tryptic, C-semi tryptic, non tryptic)
    - Columns for each contrast:
      - **class**: defined according to the fold change, p-value and abundance thresholds specified in the input
        - *+* up-regulated protein/peptide
        - *-* down-regulated protein/peptide
        - *=* invariant protein/peptide
      - **log2_FC**: protein/peptide log2 transformed fold change
      - **p_val**: protein/peptide contrast p-value
      - **p_adj**: protein/peptide adjusted p-value (FDR after BH correction)
      - **log2_expr**: protein/peptide log2 average abundance

```{r print_descr_enrich_tab, warning=FALSE, echo=F, message=FALSE, eval=run_enrich, results='asis'}
  cat("  - ```enrichment_DE.xlsx```: excel file containing a selection of enrichment results starting from differentially expressed proteins. Terms are selected according to significance thresholds specified in the input (Default: adj.P.Value < 0.05, Overlap Size >= 5) \n")
```
```{r print_descr_enrich_uni_tab, warning=FALSE, echo=F, message=FALSE, eval=run_enrich_universe, results='asis'}
  cat("  - ```enrichment_allproteins.xlsx```: excel file containing a selection of enrichment results starting from all the detected proteins. Terms are selected according to significance thresholds specified in the input (Default: adj.P.Value < 0.05, Overlap Size >= 5) \n")
```
- [**Figures** folder](Figures)
  - ```PCA_MDS``` directory: Directory containing (Multidimensional scaling) and PCA (Principal component analysis) plots of samples.
    - **mds_proteins.pdf**: MDS, based on protein abundances.
    - **mds_peptides.pdf**: MDS of the samples by peptides.
    - **pca_protein.pdf**: PCA of the samples by proteins.
    - **pca_peptides.pdf**: PCA of the samples by peptides.
    - **DE_mds_protein.pdf**: MDS based on differentially expressed proteins.
    - **DE_mds_peptide.pdf**: MDS based on differentially expressed peptides.
    - **DE_pca_protein.pdf**: PCA based on differentially expressed proteins.
    - **DE_pca_peptide.pdf**: PCA based on differentially expressed peptides.

  - ```Expression``` directory: Directory containing figures related to expression analyses.
```{r print_descr_control, warning=FALSE, echo=F, message=FALSE, eval=prot_boxplot, results='asis'}
cat("    - **selected_protein_plot.pdf**: plot displaying the abundances of selected proteins \n")
```
    - **DE_protein_barplot.pdf**: number of differentially expressed proteins found in each contrast.
    - **DE_peptide_barplot.pdf**: number of differentially expressed peptides found in each contrast.

```{r print_descr_enrich_fig_global, warning=FALSE, echo=F, message=FALSE, eval=run_enrich, results='asis'}
cat("  - ```Enrichment``` directory: Directory containing figures from functional annotation enrichment analysi \n")  
```
```{r print_descr_enrich_fig, warning=FALSE, echo=F, message=FALSE, eval=run_enrich&(!run_enrich_universe), results='asis'}
cat("    - **enr_updown_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins, divided in up- and down-regulated. Terms are filtered for key source datasets selected in the advanced options. \n")
cat("    - **enr_updown_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins, divided in up- and down-regulated. Terms are filtered for keywords defined in the advanced options. \n")
cat("    - **enr_DE_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins. Terms are filtered for key source datasets selected in the advanced options. \n")
cat("    - **enr_DE_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins. Terms are filtered for keywords defined in the advanced options. \n")

shiny::setProgress(0.10, detail = "Settings...")
```

```{r print_descr_enrich_uni_fig, warning=FALSE, echo=F, message=FALSE, eval=run_enrich_universe, results='asis'}
cat("      - **enr_updown_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins, divided in up- and down-regulated. Terms are filtered for key source datasets selected in the advanced options. \n")
cat("      - **enr_updown_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins, divided in up- and down-regulated. Terms are filtered for keywords defined in the advanced options. \n")
cat("    - **enr_DE_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins. Terms are filtered for key datasets selected in the advanced options. \n")
cat("    - **enr_DE_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins. Terms are filtered for keywords defined in the advanced options. \n")

shiny::setProgress(0.10, detail = "Settings...")
```

```{r print_descr_STRING, warning=FALSE, echo=F, message=FALSE, eval=run_STRING, results='asis'}
cat("  - ```Network``` directory: Directory with figures from network analysis of differentially expressed proteins, based on STRINGdb protein-protein interactions. For each contrast, two files are generated: \n")
cat("    - **communities_sizes.pdf**: histogram representing the number of protein in each network community. \n")
cat("    - **ppi_network.pdf**: network representation in two layouts: Fruchterman Reingold (*fr*) and Kamada Kawai (*kk*). \n")
```


## Summary of input parameters and thresholds

```{r print_settings, warning=FALSE, echo=F, message=FALSE, results='asis'}
cat(" \n \n")
#Print summary of filter and contrast design
if(readPD_files){
  cat("**Source files:** Proteome Discoverer")
  cat(" \n")
} else{
  cat("**Source files:** MaxQuant")
  cat(" \n")
}
cat(" \n \n")
if(batch_corr_exe){
  cat("**Pipeline** \n ")
  cat(" \n")
  cat("- Execution of batch effect correction.")
}
cat(" \n \n ")
cat("**Differential expression** \n ")
cat(" \n")
cat(paste0("- Fold Change threshold: log2_FC > ",fc_thr," (+), log2_FC < -",fc_thr," (-) "))
cat(" \n")
cat(paste0("- Statistica significance threshold: p.val < ",pval_thr," "))
cat(" \n")
if(signal_thr != -Inf){cat(paste0("- Signal log2 intesity threshold: signal > ",signal_thr," "))}
cat(" \n \n ")
if(run_enrich){
  cat("**Enrichment analysis** \n ")
  cat(" \n")
  cat(paste0("- Statistical significance threshold: p.val < ",pval_enrich_thr," "))
  cat(" \n")
  cat(paste0("- Overlap size threshold for enrichment analysis: OverlapSize > ",overlap_size_enrich_thr," "))
  cat(" \n")
  if(run_enrich_universe){cat("- Execution of the enrichmentalso on all detected proteins.")}
  cat(" \n \n ")
}
cat(" \n \n ")
if(run_STRING){
  cat("**Network analysis** \n ")
  cat(" \n")
  cat("- Execution of PPI network analysis with STRINGdb.")
}


shiny::setProgress(0.18, detail = "Reading files...")
```


## 1. Sample Annotation
The table summarize the input samples read in the **Sample_Annotation** file. Each case has:

- a sample name in column **sample**,
- the associated condition of study in column **condition**,
- the color of that sample in column **color**.


```{r load_data_from_PD, eval=readPD_files,echo=F, message=F, warning=F, results='asis'}
message("Reading files from MS...")
#Read all files in the input folder
template_files=c("Input","pep","prot")
filenames <- list("Input"=params$file_input,"prot"=params$file_prot,"pep"=params$file_pep)
input_files<-list("FILES")
for (f in template_files){
  input_files[f] <- tryCatch({
    read_excel_allsheets(filenames[f][[1]])
    # read_excel_allsheets(paste0(dir_file_input,filenames[which(grepl(f,filenames) & !grepl('~', filenames))]))
  }, error=function(cond){
    stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
  })
}
names(input_files)<-c("dir","Input","PEP","PROT")
message("Data acquired")


#Clean files and merge
colToKeep<-intersect(colnames(input_files$Input), c("File ID","File Name","Condition","Color","Sample","MS_batch"))
input_files$Input <- input_files$Input[,colToKeep]
if(!("Condition" %in% colnames(input_files$Input))){ stop("Error: \'Condition\' column missin in \'Input\' file.") }
if(batch_corr_exe & !("MS_batch" %in% colnames(input_files$Input))){ stop("Error: \'MS_batch\' column missin in \'Input\' file with batch correction activated") }
if("Sample" %in% colnames(input_files$Input)){input_files$Input$`File Name` <- input_files$Input$Sample}
input_files$Input$`File Name`<- lapply(input_files$Input$`File Name`,
                                                   function(x){tail(unlist(strsplit(x,"\\",fixed=T)),n=1)})

input_files$Input$`File Name`<-mf(unlist(input_files$Input$`File Name`),"_")
if(any(str_starts(input_files$Input$Condition, "[0-9]"))){
  name<-names(formule_contrast)
  formule_contrast <- lapply(unique(input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))]), 
                             function(x){
                               str_replace_all(formule_contrast,
                                               x,
                                               str_c("X.", x))
                             })[[1]]
  names(formule_contrast) <- name
  input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))] <- str_c("X.",
                                                                                         input_files$Input$Condition[(str_starts(input_files$Input$Condition,
                                                                                                                                 "[0-9]"))])
}
#Prepare PROT table with only column Accession and Dscription, extract fro Description the GeneName and remove contaminants
if(is_empty(which(grepl("Keratin|keratin",input_files$PROT$Description) |
                  grepl("CON_",input_files$PROT$Accession)))){
  input_files$PROT <- na.omit(input_files$PROT[,c("Accession","Description")])
}else{
  input_files$PROT <- na.omit(input_files$PROT[-which(grepl("Keratin|keratin",input_files$PROT$Description) |
                                              grepl("CON_",input_files$PROT$Accession))
                                       ,c("Accession","Description")])
}
input_files$PROT$GeneName<-lapply(input_files$PROT$Description, function(x){gsub(".*GN=(.+) PE=.*", "\\1", x)}) %>% unlist()
taxonomy_NCBI<-lapply(input_files$PROT$Description, function(x){gsub(".*OX=(.+) GN=.*", "\\1", x)}) %>% unlist()
taxonomy_NCBI<-strtoi(names(sort(table(taxonomy_NCBI), decreasing = T))[1])
#Mantain only the first UNIPROT code
input_files$PEP$`Master Protein Accessions`<-lapply(input_files$PEP$`Master Protein Accessions`,
                                                                function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()
#Verify if the Abundance start in 5 column in PEP table, if not remove extra column
if(!grepl("Abundance",colnames(input_files$PEP)[5])){
  input_files$PEP<-input_files$PEP[,c("Annotated Sequence",if("Modifications" %in% colnames(input_files$PEP)){"Modifications"}else{"Modifications in Master Proteins"},
                                      "Master Protein Accessions","Positions in Master Proteins",
                                      colnames(input_files$PEP)[which(grepl("Abundance",colnames(input_files$PEP)))])]
}

#merge by uniprot the prot description and the pep table
uniprot_to_take<-merge(input_files$PROT, input_files$PEP, by.x = "Accession", by.y = "Master Protein Accessions")
input_files$PD_PEP_matrix<-merge(input_files$PROT[which(input_files$PROT$Accession %in% uniprot_to_take$Accession),],
                                 input_files$PEP, by.x = "Accession", by.y = "Master Protein Accessions")
input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,c(c("Accession","Description","GeneName","Annotated Sequence",
                                                          if("Modifications" %in% colnames(input_files$PEP)){"Modifications"}else{"Modifications in Master Proteins"},
                                                          "Positions in Master Proteins"),
                                                        lapply(input_files$Input$`File ID`, function(x){
                                                          colnames(input_files$PD_PEP_matrix)[grepl(str_c(x,":"), colnames(input_files$PD_PEP_matrix))]
                                                          }) %>% unlist())]
if("TRUE" %in% grepl("\\.", colnames(input_files$PD_PEP_matrix))){
  input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,-which(colnames(input_files$PD_PEP_matrix) %in%
                                                               c(colnames(input_files$PD_PEP_matrix)[grepl("\\.",
                                                                                            colnames(input_files$PD_PEP_matrix))]))]
}
colnames(input_files$PD_PEP_matrix)<-c(c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins"),
                                        unlist(lapply(colnames(input_files$PD_PEP_matrix), function(x){
                                           lapply(input_files$Input$`File ID`, function(y){if(str_detect(x,paste0(y,":"))){
                                               input_files$Input$`File Name`[which(input_files$Input$`File ID` %in% y)]
                                           }})
                                       })))
# input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1] %>% toupper()
input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1]
#Maintain only the new complete matrix of abundance
psm_sig_raw<-input_files$PD_PEP_matrix
c_anno<-input_files$Input
if(!("Sample" %in% colnames(c_anno))){
  colnames(c_anno)[2]<-"sample"
}else{
  colnames(psm_sig_raw)<-c(c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins"),
                           c_anno$Sample)
}
colnames(c_anno)<-tolower(colnames(c_anno))

rownames(c_anno)<-c_anno$sample
if("color" %in% colnames(c_anno)){
  colour_vec<-na.omit(c_anno[colnames(psm_sig_raw),]$color)
  names(colour_vec)<-na.omit(c_anno[colnames(psm_sig_raw),]$sample)
}else{
  c_anno<-left_join(c_anno,
                    data.frame("color"=colour_vec[match(sort(c_anno$condition),unique(sort(c_anno$condition)))],
                               "sample"=c_anno[order(c_anno$condition), "sample"]))
}
rownames(c_anno)<-c_anno$sample

remove(uniprot_to_take,input_files)
#Print Annotation table
# kable(c_anno)

shiny::setProgress(0.23, detail = "Files correctly read...")
```

```{r load_data_from_MQ, eval=readMQ_files,echo=F, message=F, warning=F, results='asis'}
message("Reading files from MS...")
#Read all files in the input folder
template_files=c("Input","pep","prot")
filenames <- list("Input"=params$file_input,"prot"=params$file_prot,"pep"=params$file_pep)
input_files<-list("FILES"="in_files")
# save(template_files, filenames, input_files, file = "tmp.RData")
for (f in template_files){
  if(f == template_files[1]){
    input_files[f] <- tryCatch({
      read_excel_allsheets(filenames[f][[1]])
      # read_excel_allsheets(paste0(dir_file_input,filenames[which(grepl(f,filenames) & !grepl('~', filenames))]))
    }, error=function(cond){
      stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
    })
  }else{
    input_files[f] <- tryCatch({
      list(read_tsv(filenames[f][[1]]))

      # list(read_tsv(paste0(dir_file_input,filenames[which(grepl(f,filenames) & !grepl('~', filenames))])))
    }, error=function(cond){
      stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
    })
  }
}
names(input_files)<-c("dir","Input","PEP","PROT")
message("Data acquired")


#Clean files and merge
colToKeep<-intersect(colnames(input_files$Input), c("Condition","Color","Sample"))
input_files$Input <- input_files$Input[,colToKeep]
if(!("Condition" %in% colnames(input_files$Input))){ stop("Error: \'Condition\' column missin in \'Input\' file.") }
if(!("Sample" %in% colnames(input_files$Input))){ stop("Error: \'Sample\' column missin in \'Input\' file.") }
if(batch_corr_exe & !("MS_batch" %in% colnames(input_files$Input))){ stop("Error: \'MS_batch\' column missin in \'Input\' file with batch correction activated") }

if(any(str_starts(input_files$Input$Condition, "[0-9]"))){
  name<-names(formule_contrast)
  formule_contrast <- lapply(unique(input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))]), 
                             function(x){
                               str_replace_all(formule_contrast,
                                               x,
                                               str_c("X.", x))
                             })[[1]]
  names(formule_contrast) <- name
  input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))] <- str_c("X.",
                                                                                         input_files$Input$Condition[(str_starts(input_files$Input$Condition,
                                                                                                                                 "[0-9]"))])
}
# save(list = ls(all.names = TRUE), file = "tmp_3.RData")
#Prepare PROT table with only column Accession and Dscription, extract fro Description the GeneName and remove contaminants
input_files$PROT <- input_files$PROT[-which(grepl("Keratin|keratin",input_files$PROT$`Fasta headers`) |
                                            grepl("CON_",input_files$PROT$`Majority protein IDs`))
                                     ,c("Majority protein IDs","Fasta headers")]
input_files$PROT$GeneName<-lapply(input_files$PROT$`Fasta headers`, function(x){gsub(".*GN=(.+) PE=.*", "\\1", x)}) %>% unlist()
input_files$PROT$GeneName[which(str_detect(input_files$PROT$GeneName,";"))] <- lapply(
                                                                        input_files$PROT$GeneName[which(str_detect(input_files$PROT$GeneName,";"))],
                                                                                  function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()

taxonomy_NCBI<-lapply(input_files$PROT$`Fasta headers`, function(x){gsub(".*OX=(.+) GN=.*", "\\1", x)}) %>% unlist()
taxonomy_NCBI<-strtoi(names(sort(table(taxonomy_NCBI), decreasing = T))[1])
if(is.na(taxonomy_NCBI)){
  taxonomy_NCBI<-9606
}
#Mantain only the first UNIPROT code
# input_files$PEP$`Master Protein Accessions`<-lapply(input_files$PEP$`Master Protein Accessions`,
#                                                                 function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()
input_files$PEP<-input_files$PEP[,c("Proteins","Sequence","Start position","End position",
                                    colnames(input_files$PEP)[which(grepl("Intensity ",colnames(input_files$PEP)))])]


#merge by uniprot the prot description and the pep table
input_files$PD_PEP_matrix<-merge(input_files$PROT, input_files$PEP, by.x = "Majority protein IDs", by.y = "Proteins")

input_files$PD_PEP_matrix$`End position` <- str_c(input_files$PD_PEP_matrix$GeneName,input_files$PD_PEP_matrix$`Start position`, input_files$PD_PEP_matrix$`End position`, sep = "_")
input_files$PD_PEP_matrix$`Start position` <- c(NA)

colnames(input_files$PD_PEP_matrix)<-c(c("Accession","Description","GeneName",
                                         "Annotated Sequence","Modifications","Position in Master Proteins"),
                                        unlist(lapply(colnames(input_files$PD_PEP_matrix), function(x){ if(str_detect(x,"Intensity")){
                                               str_split(x," ")[[1]][2]
                                           }})
                                       ))
# input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1] %>% toupper()
input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1]
#Maintain only the new complete matrix of intensity
psm_sig_raw<-input_files$PD_PEP_matrix
c_anno<-input_files$Input
colnames(c_anno)<-tolower(colnames(c_anno))

rownames(c_anno)<-c_anno$sample
if("color" %in% colnames(c_anno)){
  colour_vec<-na.omit(c_anno[colnames(psm_sig_raw),]$color)
  names(colour_vec)<-na.omit(c_anno[colnames(psm_sig_raw),]$sample)
}else{
  c_anno<-left_join(c_anno,
                    data.frame("color"=colour_vec[match(sort(c_anno$condition),unique(sort(c_anno$condition)))],
                               "sample"=c_anno[order(c_anno$condition), "sample"]))
}
rownames(c_anno)<-c_anno$sample
remove(uniprot_to_take,input_files)
#Print Annotation table
# kable(c_anno)


shiny::setProgress(0.23, detail = "Files correctly read...")
```

```{r peptide_annotation, message=F, warning=F, echo=F, eval=T}
psm_sig_raw$`Position in Master Proteins`<-gsub(" ", "_", psm_sig_raw$`Position in Master Proteins`)
psm_sig_raw$Modifications<-gsub(" ", "_", psm_sig_raw$Modifications)

if(readPD_files){
  #For peptides analysis
  # psm_anno_raw <- data.frame("accession"=psm_sig_raw$Accession,
  #                            "symbol"=psm_sig_raw$GeneName,
  #                            "sequence"=psm_sig_raw$`Annotated Sequence`,
  #                            "modifications"=psm_sig_raw$Modifications)
  #For protein groups analysis
  psm_anno_raw <- data.frame("symbol"=psm_sig_raw$GeneName,
                             "sequence"=psm_sig_raw$`Annotated Sequence`,
                             "modifications"=psm_sig_raw$Modifications)
  psm_anno_raw$id<-paste(psm_anno_raw$symbol,psm_anno_raw$sequence,psm_anno_raw$modifications,sep="_")
}else{
  psm_anno_raw <- data.frame("symbol"=psm_sig_raw$GeneName,
                             "sequence"=psm_sig_raw$`Annotated Sequence`,
                             "modifications"=psm_sig_raw$Modifications)
  psm_anno_raw$id<-paste(psm_anno_raw$symbol,psm_anno_raw$sequence,psm_anno_raw$modifications,sep="_")
}


rownames(psm_sig_raw)<-rownames(psm_anno_raw)<-paste(psm_anno_raw$symbol,seq(1:nrow(psm_anno_raw)),sep="_")
psm_anno_raw$old_id<-rownames(psm_anno_raw)

# create peptide names linked to symbols
psm_anno_raw$row <- seq(1,nrow(psm_anno_raw))
psm_anno_raw <- psm_anno_raw %>% dplyr::group_by(symbol) %>% dplyr::mutate("min"=min(row),"card"=n()) %>% ungroup()
psm_anno_raw$rank<- psm_anno_raw$row - psm_anno_raw$min +1
psm_anno_raw$id<- paste(psm_anno_raw$symbol,psm_anno_raw$rank,psm_anno_raw$card,sep="_")

psm_sig_raw<-psm_sig_raw[psm_anno_raw$old_id,]
rownames(psm_sig_raw)<-psm_anno_raw$id

psm_anno_raw<-as.data.frame(psm_anno_raw)
rownames(psm_anno_raw)<- psm_anno_raw$id

#Divide the table info from the matrix of peptide intensity
psm_peptide_table<-psm_sig_raw[,c(1:6)]
rownames(psm_peptide_table)<-make.names(paste(psm_peptide_table$`Position in Master Proteins`,
						psm_peptide_table$Modifications,
                                              psm_peptide_table$`Annotated Sequence`,sep = "_"), 
                                        unique = T)
psm_sig_prot_raw<-psm_sig_raw[,c(7:ncol(psm_sig_raw))]
psm_sig_pet_raw<-psm_sig_raw[,c(7:ncol(psm_sig_raw))]
rownames(psm_sig_pet_raw)<-rownames(psm_peptide_table)

#For Peptide analysis
# rownames(psm_sig_raw)<-make.names(psm_anno_raw$accession,unique=T)
# rownames(psm_table_info)<-make.names(psm_table_info$Accession,unique=T)
# rownames(psm_anno_raw)<-make.names(psm_anno_raw$accession,unique=T)

shiny::setProgress(0.27, detail = "Annotate proteins/peptides...")

```

```{r preprocess_sig_raw, echo=F, message=F, warning=F}
n_prot_preFILT <- length(unique(psm_anno_raw$symbol))
n_pep_pre_FILT <- length(psm_peptide_table$Accession)
#Preprocess Protein intensities
psm_sig_prot_raw[psm_sig_prot_raw == 0] <- NA # transform 0s into NAs

sig_thr<-filt_absent_value # NA threshold

psm_long_df <- psm_sig_prot_raw %>% mutate(id=as.factor(rownames(psm_sig_prot_raw)))
psm_long_df <- psm_long_df %>% pivot_longer(-id, names_to = "sample", values_to = "counts")
psm_long_df <- suppressMessages(left_join(psm_long_df,c_anno))


psm_filter_df <- psm_long_df %>% dplyr::group_by(id,condition, .drop=FALSE) %>% dplyr::summarise("min_c"=sum(is.na(counts))) %>% ungroup()

psm_filter_df <- psm_filter_df %>% dplyr::group_by(id,.drop=FALSE) %>% dplyr::summarise("passes_c"= sum(min_c <= sig_thr)) %>% ungroup()

filter_id <- as.character(psm_filter_df %>% dplyr::filter(passes_c > 0) %>% pull(id))
psm_sig_prot_df <-psm_sig_prot_raw[filter_id,]
psm_anno_df <- psm_anno_raw[filter_id,]

#Log2
psm_log_prot_df <- psm_sig_prot_df
psm_log_prot_df <- psm_sig_prot_df %>% log2()


#Filter proteins with only 1 peptides
filter_df_single_pep<-psm_anno_df %>% dplyr::group_by(symbol) %>% dplyr::summarise(N=n()) %>% ungroup() %>% filter(N > 1)
filter_df_single_pep <- left_join(filter_df_single_pep, psm_anno_df) %>% pull(id)
psm_log_prot_df <-psm_log_prot_df[intersect(rownames(psm_log_prot_df), filter_df_single_pep),]
psm_anno_df <- psm_anno_df[intersect(rownames(psm_anno_df), filter_df_single_pep),]
# psm_table_info <- psm_table_info[filter_id,]
#Clean old variables
remove(psm_anno_raw,psm_sig_prot_raw,psm_long_df,psm_filter_df,filter_id,sig_thr)

#Preprocess peptide intensities
psm_sig_pet_raw[psm_sig_pet_raw == 0] <- NA # transform 0s into NAs
sig_thr<-filt_absent_value # NA threshold

psm_long_df <- psm_sig_pet_raw %>% mutate(id=as.factor(rownames(psm_sig_pet_raw)))
psm_long_df <- psm_long_df %>% pivot_longer(-id, names_to = "sample", values_to = "counts")
psm_long_df <- suppressMessages(left_join(psm_long_df,c_anno))

psm_filter_df <- psm_long_df %>% dplyr::group_by(id,condition, .drop=FALSE) %>% dplyr::summarise("min_c"=sum(is.na(counts))) %>% ungroup()
psm_filter_df <- psm_filter_df %>% dplyr::group_by(id,.drop=FALSE) %>% dplyr::summarise("passes_c"= sum(min_c <= sig_thr)) %>% ungroup()
filter_id <- as.character(psm_filter_df %>% dplyr::filter(passes_c > 0) %>% pull(id))

psm_sig_pet_df <-psm_sig_pet_raw[filter_id,]
psm_peptide_table<-psm_peptide_table[filter_id,]



#Determine column tryptic
peptides_df <- psm_peptide_table[,c("Accession", "Annotated Sequence")]
peptides_df$preAA <- str_sub(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,1], regex("\\[\\w+\\]")),
                             2,
                             str_length(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."),
                                                                    n = 3)[,1], regex("\\[\\w+\\]")))-1)

peptides_df$endAA <- str_sub(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,2], -1, -1)
peptides_df$postAA <- str_sub(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,3], regex("\\[\\w+\\]")),
                              2,
                              str_length(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."),
                                                                     n = 3)[,3], regex("\\[\\w+\\]")))-1)

peptides_df$fully_TRI = (peptides_df$preAA %in% c("K","R") &
                           peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$NSEMI_TRI = (peptides_df$preAA %in% c("K","R") &
                           !peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$CSEMI_TRI = (!peptides_df$preAA %in% c("K","R") &
                           peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$non_TRI = (!peptides_df$fully_TRI & !peptides_df$NSEMI_TRI & !peptides_df$CSEMI_TRI)

peptides_df$tryptic_cond[peptides_df$fully_TRI] <- "fully tryptic"
peptides_df$tryptic_cond[peptides_df$NSEMI_TRI] <- "N-semi tryptic"
peptides_df$tryptic_cond[peptides_df$CSEMI_TRI] <- "C-semi tryptic"
peptides_df$tryptic_cond[peptides_df$non_TRI] <- "non tryptic"

psm_peptide_table$tryptic_cond <- peptides_df$tryptic_cond

#Log2
psm_log_pet_df <- psm_sig_pet_df
psm_log_pet_df <- psm_sig_pet_df %>% log2()

#Filter proteins with only 1 peptides
filter_df_single_pep<-psm_anno_df %>% dplyr::group_by(symbol) %>% dplyr::summarise(N=n()) %>% ungroup() %>% filter(N > 1)
filter_df_single_pep <- left_join(filter_df_single_pep, psm_anno_df) %>% pull(symbol)
filter_df_single_pep <- rownames(psm_peptide_table[which(psm_peptide_table$GeneName %in% filter_df_single_pep),])
psm_log_pet_df <-psm_log_pet_df[intersect(rownames(psm_log_pet_df), filter_df_single_pep),]
psm_peptide_table <- psm_peptide_table[intersect(rownames(psm_peptide_table), filter_df_single_pep),]

remove(psm_sig_pet_raw,psm_sig_raw,psm_long_df,psm_filter_df,filter_id,sig_thr)

shiny::setProgress(0.29, detail = "Filtering abundance matrix...")
```


## 1. Analysis

### 1.1. Sample annotation
The sample table below annotates the samples of the study as in the **Sample_Annotation** file. Important columns for the analysis:

- **Sample**: sample name used in the results,
- **Condition**: condition of the sample used in study desgin and differential analyses,
- **Color**: the color of the sample in figures.

```{r print_sample, warning=FALSE, echo=F, message=FALSE, results='asis'}
cat(" \n")
kable(c_anno, row.names = F, col.names = str_to_title(colnames(c_anno)))
cat(" \n")

```


Raw abundances are determined from the area under the peak (m/z, time, number of events) for each PSM (Peptide-to-Spectrum Match).

Initial filtering removes the following peptides:

-   Low/missing abundance: PSMs not consistently present in all replicates of at least one condition are removed.
-   Contaminants.

After filtering, raw abundances are log2 transformed

#### Number of identified peptides/proteins
```{r stat_proteomic, echo=F, message=F, warning=F, results='asis'}
df_stat <- data.frame("number" = c(n_prot_preFILT, n_pep_pre_FILT, length(unique(psm_anno_df$symbol)), nrow(psm_anno_df)), 
                      row.names = c("Proteins (raw):", "Peptides (raw):", "Proteins (after filter):", "Peptides (after filter):"))
kable(df_stat)
```

#### 1.1. Distributions of log2 raw abundances
Violin plot showing sample distributions of log2 raw abundances of peptides.

```{r raw_distributions, message=F, warning=F, echo=F}

psm_long_df <- psm_log_prot_df[,c_anno[order(c_anno$condition),"sample"]] %>% mutate(id=as.factor(rownames(psm_log_prot_df[,c_anno[order(c_anno$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2 raw abundance")
psm_long_df <- suppressMessages(left_join(psm_long_df,c_anno))

hs<-ggplot(data=psm_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`log2 raw abundance`,fill=sample,colour=sample))+
  #geom_hline(yintercept = 0, lty=2)+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F,colour=NA)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = T)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank()) +
  # labs(x = "Log2 Intensity") +
  scale_fill_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

hs

shiny::setProgress(0.32, detail = "Calculate distributions...")
```

#### 1.2. Percentage of quantified peptides per sample
Barplot showing the percentage of peptides with available abundancies for each sample.

```{r numeric_numbers, echo=F, message=F, warning=F}

numeric_df<- c_anno[c_anno[order(c_anno$condition),"sample"],]
numeric_df$numeric_values<-colSums(is.na(psm_sig_prot_df))
numeric_df$numeric_percentage<- 100-(numeric_df$numeric_values/nrow(psm_sig_prot_df)*100)
setnames(numeric_df,"numeric_percentage","% of available abundances")
hs<-ggplot(data=numeric_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`% of available abundances`,fill=sample,colour=sample))+
  #geom_hline(yintercept = 0, lty=2)+
  coord_flip()+
  geom_bar(stat="identity",width=.7,alpha=.8)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  # labs(x = "Percentage of known intensity (%)") +
  scale_fill_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

hs

remove(hs,numeric_df)

shiny::setProgress(0.34, detail = "Doing normalizations...")
```


#### 1.3. Normalization, peptide-to-protein summarization, imputation 

**Peptides** abundances are normalized with the equalMedianNormalization function from the Bioconductor package [DEqMS](<https://www.bioconductor.org/packages/release/bioc/html/DEqMS.html>) (equal medians in all samples). 

**Protein** normalized abundancies were calculated with the medianSweeping function from the Bioconductor package [DEqMS](<https://www.bioconductor.org/packages/release/bioc/html/DEqMS.html>).

```{r pep_in_proteins, echo=F, message=F, warning=F}

numeric_df <- as.data.table(table(psm_anno_df$symbol))
numeric_df[which(numeric_df$N > 20), "N"] <- 20
numeric_df <- numeric_df[order(numeric_df$N) , .(NPeptides = .N), by = c("N")]
numeric_df$N <- factor(str_sort(str_replace(as.character(numeric_df$N), pattern = "20", replacement = "20+"), numeric = T), levels = c(2:19, "20+"))

# numeric_df$numeric_values<-colSums(is.na(psm_sig_prot_df))
# numeric_df$numeric_percentage<- 100-(numeric_df$numeric_values/nrow(psm_sig_prot_df)*100)
# setnames(numeric_df,"numeric_percentage","% of available abundancies")
hs<-ggplot(data=numeric_df, aes(x=N,y=NPeptides, color = NPeptides, fill = NPeptides))+
  # geom_hline(yintercept = 0, lty=2)+
  # coord_flip()+
  geom_bar(stat="identity",width=.7,alpha=.8)+
  theme_bw()+
  theme(legend.position = "none")+
  labs(x = "# peptides per protein", y = "# protein") +
  # scale_fill_manual(values=brewer.pal(29, name = )) +
  # scale_colour_manual(values="dodgerblue2") +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank(),panel.grid.major.x = element_blank())

hs

remove(hs,numeric_df)

shiny::setProgress(0.34, detail = "Doing normalizations...")
```


**Imputation** is performed on peptide and protein abundancies with the Bioconductor package [PhosR](https://www.sciencedirect.com/science/article/pii/S221112472100084X). Round imputation is performed in absence of replicates. ProTN uses two function of PhosR for the imputation, the first impute the missing values for a peptide across replicates within a single condition, the second is a tail-based imputation approach as implemented in Perseus.



```{r prot_summarization, warning=F, message=F, echo=F}
message("Median normalization in progress...")
# gene_anno_df <- psm_anno_df %>% dplyr::select(symbol) %>% unique()

dat_psm <- cbind(psm_anno_df[,c("id","symbol")],psm_log_prot_df)
#For peptides analysis
# dat_psm <- cbind(rownames(psm_anno_df),rownames(psm_anno_df),psm_log_df)

# 4 methods to summarise peptides into proteins:
# medianSweeping (also correct intensities so that the median of all proteins is 0)
# medianSummary
# medpolishSummary
# farmsSummary

#Summarize into proteins and normalize by median
dat_gene = DEqMS::medianSweeping(dat_psm,group_col = 2)
# remove(gene_anno_df)

# Median centering log2 table for peptides
dat_pep = DEqMS::equalMedianNormalization(psm_log_pet_df)

message("Normalization DONE.")

shiny::setProgress(0.38, detail = "Doing imputation...")
```


```{r imputation, echo=F, message=F, warning=F, results='asis'}
message("Imputation of intensity matrix in progress...")
dat_gene<-tryCatch(
  {
    #Imputation with Phospho
    ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(dat_gene)))
    #Mantieni ordine
    grps <- as.factor(c_anno[colnames(dat_gene), "condition"])
    ppe <- scImpute(ppe, 0.6, grps)
    ppe <- tImpute(ppe, assay = "imputed")
    dat_gene[is.na(dat_gene)]<-ppe@assays@data@listData$imputed[is.na(dat_gene)]
    # cat("##### Done the *PhosR* imputation for proteins \n")
    dat_gene
  },
  error=function(cond){
    # Rounds of imputation
    mat_i <- dat_gene
    col_sele<-colnames(mat_i)

    vec_all<-unlist(mat_i[,col_sele]) # convert to vector
    vec_numeric<-vec_all[-which(is.na(vec_all))] # remove NAs
    orig_stats<-c(mean(vec_numeric),sd(vec_numeric)) # calculate mean and sd
    imp_stats<-c(orig_stats[1]-(orig_stats[2]*1.8),orig_stats[2]*0.3) # imputed mean = mean-1.8*sd, imputed sd = sd*0.3

    set.seed(42)
    imp_matrix<-matrix(rnorm(length(vec_all), mean = imp_stats[1], sd = imp_stats[2]), ncol=ncol(mat_i)) # create matrix of imputed values
    dat_gene[is.na(dat_gene)]<-imp_matrix[is.na(dat_gene)]
    # cat("##### Done *round* imputation for proteins \n")
    dat_gene
  }
)

remove(ppe,grps)

dat_pep<-tryCatch(
  {
    #Imputation with Phospho
    ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(dat_pep)))
    grps <- as.factor(c_anno[colnames(dat_gene), "condition"])
    ppe <- scImpute(ppe, 0.6, grps)
    ppe <- tImpute(ppe, assay = "imputed")
    dat_pep[is.na(dat_pep)]<-ppe@assays@data@listData$imputed[is.na(dat_pep)]
    # cat("##### Done the *PhosR* imputation for peptides \n")
    dat_pep
  },
  error=function(cond){
    # Rounds of imputation
    mat_i <- dat_pep
    col_sele<-colnames(mat_i)

    vec_all<-unlist(mat_i[,col_sele]) # convert to vector
    vec_numeric<-vec_all[-which(is.na(vec_all))] # remove NAs
    orig_stats<-c(mean(vec_numeric),sd(vec_numeric)) # calculate mean and sd
    imp_stats<-c(orig_stats[1]-(orig_stats[2]*1.8),orig_stats[2]*0.3) # imputed mean = mean-1.8*sd, imputed sd = sd*0.3

    set.seed(42)
    imp_matrix<-matrix(rnorm(length(vec_all), mean = imp_stats[1], sd = imp_stats[2]), ncol=ncol(mat_i)) # create matrix of imputed values
    dat_pep[is.na(dat_pep)]<-imp_matrix[is.na(dat_pep)]
    # cat("##### Done *round* imputation for peptides \n")
    dat_pep
  }
)

remove(ppe,grps)

shiny::setProgress(0.42, detail = "Done normalization and imputation...")
```

```{r batch_correction, warning=F, message=F, echo=F, eval=batch_corr_exe, results='asis'}
cat("#### 1.3.1. Batch correction {.tabset}  \n")
cat("A batch effect correction is applied to the datased using the proBatch package. \n")
cat(" \n \n")

batch_annotation <- c_anno
batch_annotation$order<-c(1:nrow(batch_annotation))

dat_pep_long <- matrix_to_long(dat_pep) %>% setnames("FullRunName","sample")
# loess_fit_df_pep <- adjust_batch_trend_df(dat_pep_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
comBat_df_pep <- correct_with_ComBat_df(dat_pep_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
dat_pep = as.data.frame(long_to_matrix(comBat_df_pep, sample_id_col = "sample"))

dat_gene_long <- matrix_to_long(dat_gene) %>% setnames("FullRunName","sample")
# loess_fit_df_gene <- adjust_batch_trend_df(dat_gene_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
comBat_df_gene <- correct_with_ComBat_df(dat_gene_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
dat_gene = as.data.frame(long_to_matrix(comBat_df_gene, sample_id_col = "sample"))

# setnames(c_anno,"FullRunName","sample")

###################
# sample_data<-(t(dat_gene))
# sample_distances <- dist(sample_data, method = "euclidean")
# 
# mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
# colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
# mds_cmdscale$sample <- rownames(mds_cmdscale)
# 
# mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno))
# 
# #Take correct order of color
# cc<-mds_cmdscale$color
# if(is.null(cc)){
#   cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
#   names(cc)<-unique(mds_cmdscale$condition)
# } else{
#   names(cc)<-mds_cmdscale$condition
# }
# 
# cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
#   geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
#   geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
#   scale_colour_manual(values=cc[unique(names(cc))]) +
#   theme_bw(base_size = bs, base_family = bf) +
#   theme(legend.position = "right", panel.grid.minor=element_blank())
# 
# cat("##### Proteins \n")
# print(cmd)
# cat(" \n \n")
# 
# suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"corrected_mds_proteins.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in")))
# 
# remove(sample_data,sample_distances,mds_cmdscale,cmd)
# 
# #Peptides
# sample_data<-(t(dat_pep))
# sample_distances <- dist(sample_data, method = "euclidean")
# 
# mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
# colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
# mds_cmdscale$sample <- rownames(mds_cmdscale)
# 
# mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno))
# 
# #Take correct order of color
# cc<-mds_cmdscale$color
# if(is.null(cc)){
#   cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
#   names(cc)<-unique(mds_cmdscale$condition)
# } else{
#   names(cc)<-mds_cmdscale$condition
# }
# 
# cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
#   geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
#   geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
#   scale_colour_manual(values=cc[unique(names(cc))]) +
#   theme_bw(base_size = bs, base_family = bf) +
#   theme(legend.position = "right", panel.grid.minor=element_blank())
# 
# cat("##### Peptides \n")
# print(cmd)
# cat(" \n \n")
# 
# suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"corrected_mds_peptides.pdf"), cmd, device=cairo_pdf, width = 4, height = 3, units = c("in")))
# 
# remove(sample_data,sample_distances,mds_cmdscale,cmd)

shiny::setProgress(0.53, detail = "Perfom Batch effect correction...")
```


```{r sig_tables, message=F, warning=F, echo=F, results='hide'}

#Save proteins table
expr_mat<-as.data.table(dat_gene)
expr_mat$gene <- rownames(dat_gene)

expr_l_df <- melt(expr_mat)
colnames(expr_l_df) <- c("id","sample","expr")
expr_l_df <- expr_l_df[c_anno, on = "sample"]

expr_cond_df <- expr_l_df[ , .(N = .N, avg = mean(expr), sd=sd(expr), CV=sd(expr)/mean(expr), se = sd(expr)/sqrt(.N)), by = c("condition","id")]

expr_avg_df <- dcast(expr_cond_df[,c("id","condition","avg")], id ~ condition)
colnames(expr_avg_df)[-1]<-paste0(colnames(expr_avg_df)[-1],"_avg")
expr_se_df <- dcast(expr_cond_df[,c("id","condition","se")], id ~ condition)
colnames(expr_se_df)[-1]<-paste0(colnames(expr_se_df)[-1],"_se")
expr_cv_df <- dcast(expr_cond_df[,c("id","condition","CV")], id ~ condition)
colnames(expr_cv_df)[-1]<-paste0(colnames(expr_cv_df)[-1],"_Coef_Variant_(%)")

expr_avgse_df <- Reduce(merge,list(expr_avg_df,expr_se_df,expr_cv_df))

toPrint<-expr_avgse_df
colnames(toPrint)[1]<-"symbol"

n_pep_prot <- unique(merge.data.table(as.data.table(psm_peptide_table[,c("Accession","Description","GeneName")]), as.data.table(psm_anno_df)[ , .(Num.Peptide = .N), by = symbol], by.x = "GeneName", by.y = "symbol"))
colnames(n_pep_prot)[1]<-"symbol"
toPrint_datGene<-as.data.table(dat_gene)
toPrint_datGene$symbol<-rownames(dat_gene)

df_to_save<-list("protein_per_sample"=merge.data.table(n_pep_prot,toPrint_datGene),
                 "protein_per_condition"=merge.data.table(n_pep_prot,toPrint))
# expr_mat<-(dat_gene)
# expr_l_df <- expr_mat %>% mutate(id=rownames(expr_mat)) %>% pivot_longer(-id, names_to = "sample", values_to = "expr")
# expr_l_df <- suppressMessages(left_join(expr_l_df,c_anno))
# 
# #Add Standard Deviation column and average
# expr_cond_df<-expr_l_df %>% dplyr::group_by(condition,id) %>%
#             dplyr::summarise(N=n(),avg=mean(expr),sd=sd(expr),CV=sd(expr)/mean(expr)) %>% ungroup() %>% mutate("se"=sd/sqrt(N))
# 
# expr_avg_df <- expr_cond_df %>% dplyr::select(id,condition,avg) %>% pivot_wider(names_from = condition, values_from = avg)
# colnames(expr_avg_df)[-1]<-paste0(colnames(expr_avg_df)[-1],"_avg")
# 
# expr_se_df <- expr_cond_df %>% dplyr::select(id,condition,se) %>% pivot_wider(names_from = condition, values_from = se)
# colnames(expr_se_df)[-1]<-paste0(colnames(expr_se_df)[-1],"_se")
# 
# expr_cv_df <- expr_cond_df %>% dplyr::select(id,condition,CV) %>% pivot_wider(names_from = condition, values_from = CV)
# colnames(expr_cv_df)[-1]<-paste0(colnames(expr_cv_df)[-1],"_Coef_Variant_(%)")
# 
# expr_avgse_df<- suppressMessages(left_join(left_join(expr_avg_df,expr_se_df),expr_cv_df))
# rownames(expr_avgse_df) <- expr_avgse_df$id
# toPrint<-expr_avgse_df
# colnames(toPrint)[1]<-"symbol"
# 
# n_pep_prot <- psm_anno_df %>% dplyr::group_by(symbol, .drop=FALSE) %>% dplyr::summarise("Num. Peptides"=n_distinct(row)) %>% ungroup()
# n_pep_prot <- left_join(psm_peptide_table, n_pep_prot, by = c("GeneName" = "symbol"))
# colnames(n_pep_prot)[3]<-"symbol"
# toPrint_datGene<-dat_gene
# toPrint_datGene$symbol<-rownames(dat_gene)

#Export table with SE e MEAN
# df_to_save<-list("protein_per_sample"=merge.data.table(n_pep_prot,toPrint_datGene),
#                  "protein_per_condition"=merge.data.table(n_pep_prot,toPrint))
# writexl::write_xlsx(df_to_save,paste0(dirOutput,"normalised_intensities.xlsx"))
# remove(expr_mat,expr_l_df,expr_cond_df,expr_se_df,expr_avg_df,toPrint)


#Save peptides table
expr_mat<-as.data.table(dat_pep)
expr_mat$gene <- rownames(dat_pep)

expr_l_df <- melt(expr_mat)
colnames(expr_l_df) <- c("id","sample","expr")
expr_l_df <- expr_l_df[c_anno, on = "sample"]

expr_cond_df <- expr_l_df[ , .(N = .N, avg = mean(expr), sd=sd(expr), CV=sd(expr)/mean(expr), se = sd(expr)/sqrt(.N)), by = c("condition","id")]

expr_avg_pet_df <- dcast(expr_cond_df[,c("id","condition","avg")], id ~ condition)
colnames(expr_avg_pet_df)[-1]<-paste0(colnames(expr_avg_pet_df)[-1],"_avg")
expr_se_pet_df <- dcast(expr_cond_df[,c("id","condition","se")], id ~ condition)
colnames(expr_se_pet_df)[-1]<-paste0(colnames(expr_se_pet_df)[-1],"_se")
expr_cv_pep_df <- dcast(expr_cond_df[,c("id","condition","CV")], id ~ condition)
colnames(expr_cv_pep_df)[-1]<-paste0(colnames(expr_cv_pep_df)[-1],"_Coef_Variant_(%)")

expr_avgse_pep_df <- Reduce(merge,list(expr_avg_pet_df,expr_se_pet_df,expr_cv_pep_df))

toPrint<-expr_avgse_pep_df
# colnames(toPrint)[1]<-"symbol"

# expr_mat<-dat_pep

# expr_l_df <- expr_mat %>% mutate(id=rownames(expr_mat)) %>% pivot_longer(-id, names_to = "sample", values_to = "expr")
# expr_l_df <- suppressMessages(left_join(expr_l_df,c_anno))

#Add Standard Deviation column and average
# expr_cond_df<-expr_l_df %>% dplyr::group_by(condition,id) %>%
#             dplyr::summarise(N=n(),avg=mean(expr),sd=sd(expr),CV=sd(expr)/mean(expr)) %>% ungroup() %>% mutate("se"=sd/sqrt(N))
# 
# expr_avg_pet_df <- expr_cond_df %>% dplyr::select(id,condition,avg) %>% pivot_wider(names_from = condition, values_from = avg)
# colnames(expr_avg_pet_df)[-1]<-paste0(colnames(expr_avg_pet_df)[-1],"_avg")
# 
# expr_se_pet_df <- expr_cond_df %>% dplyr::select(id,condition,se) %>% pivot_wider(names_from = condition, values_from = se)
# colnames(expr_se_pet_df)[-1]<-paste0(colnames(expr_se_pet_df)[-1],"_se")
# 
# expr_cv_pep_df <- expr_cond_df %>% dplyr::select(id,condition,CV) %>% pivot_wider(names_from = condition, values_from = CV)
# colnames(expr_cv_pep_df)[-1]<-paste0(colnames(expr_cv_pep_df)[-1],"_Coef_Variant_(%)")
# 
# expr_avgse_pep_df<- suppressMessages(left_join(left_join(expr_avg_pet_df,expr_se_pet_df)
#                                                ,expr_cv_pep_df))
# rownames(expr_avgse_pep_df) <- expr_avgse_pep_df$id
# toPrint<-expr_avgse_pep_df

#Prepare the README
readme_sheet <- data.frame("INFO"=c(   NA,
                                "Excel file containing abundance values generated by proTN. Abundances are log2 transformed, normalized, imputed (and batch corrected). The file is organized in the following sheets",
                                NA,
                                "Sheet *protein_per_sample*: protein abundances per sample.",
                                "Sheet *peptide_per_sample*: peptide abundances per sample.",
                                "Sheet *protein_per_condition*: protein abundances per condition (average & standard deviation), as defined in the Sample Annotation.",
                                "Sheet *peptide_per_condition*: peptide abundances per condition (average & standard deviation), as defined in the Sample Annotation."
                              ))

#Export table with SE e MEAN
df_to_save<-list("README"=readme_sheet,
                 "protein_per_sample"=df_to_save$`protein_per_sample`,
                 "peptide_per_sample"=merge(psm_peptide_table, dat_pep, by=0)[,-c(1)],
                 "protein_per_condition"=df_to_save$`protein_per_condition`,
                 "peptide_per_condition"=merge.data.table(as.data.table(rownames_to_column(psm_peptide_table)), toPrint, by.x = "rowname", by.y = "id")[,-c(1)])

writexl::write_xlsx(df_to_save,paste0(dirOutput,subfold_Tab,"normalised_abundances.xlsx"))
remove(expr_mat,expr_l_df,expr_cond_df,expr_se_pet_df,expr_avg_pet_df,toPrint)

shiny::setProgress(0.45, detail =  "Save normalized data...")
```


```{r norm_distributions, message=F, warning=F, echo=F, results='asis'}
cat(" \n \n")
cat("#### 1.4. Distributions of normalized abundancies {.tabset}  \n")
cat("Violin plot showing sample distributions of log2 normalized and imputed abundancies. \n \n ")

cat(" \n \n")
pg_long_df <- dat_gene[,c_anno[order(c_anno$condition),"sample"]] %>% mutate(id=as.factor(rownames(dat_gene[,c_anno[order(c_anno$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2 normalized abundance")
pg_long_df <- suppressMessages(left_join(pg_long_df,c_anno))


hs<-ggplot(data=pg_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`log2 normalized abundance`,fill=sample,colour=sample))+
  # ggtitle("Normalized samples")+
  #geom_hline(yintercept = 0, lty=2)+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F,colour=NA)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = F)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  # labs(x = "Log2 Intensity") +
  scale_fill_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Proteins \n")
print(hs)
cat(" \n \n")

pg_long_df <- dat_pep[,c_anno[order(c_anno$condition),"sample"]] %>% mutate(id=as.factor(rownames(dat_pep[,c_anno[order(c_anno$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2 normalized abundance")
pg_long_df <- suppressMessages(left_join(pg_long_df,c_anno))


hs<-ggplot(data=pg_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`log2 normalized abundance`,fill=sample,colour=sample))+
  # ggtitle("Normalized samples")+
  #geom_hline(yintercept = 0, lty=2)+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F,colour=NA)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = F)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  # labs(x = "Log2 Intensity") +
  scale_fill_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno$color), c_anno$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Peptides \n")
print(hs)
cat(" \n \n")


remove(hs, pg_long_df)

shiny::setProgress(0.47, detail =  "Calculate post-norm distribution...")


```

```{r check_number_sample, warning=FALSE, echo=F, message=FALSE}
#TODO: better control
design = model.matrix(~0+c_anno$condition) 
colnames(design) = levels(as.factor(c_anno$condition))
rownames(design)<-c_anno$sample
filt_contro_list <- list()
for (i in 1:length(formule_contrast)) {
 if(all(str_extract_all(formule_contrast[i], "\\[a-zA-Z]+")[[1]] %in% colnames(design))){
   filt_contro_list<-c(filt_contro_list,i)
 }
}
contro_list<-formule_contrast[unlist(filt_contro_list)]
if(length(contro_list) == 0){ stop("Error: No valid contrast design given. Check the match between the spell of Condition and contrast design.")}
contrast =  limma::makeContrasts(contrasts=contro_list,levels=design)
colnames(contrast)<-names(contro_list)
   
unique_cond <- colSums(design) == 1
unique_cond <- sort(names(unique_cond[unique_cond]))
res<-lapply(colnames(contrast), function(i){all(sort(names((contrast[,i] != 0)[contrast[,i] != 0])) %in% unique_cond)}) %>% unlist()
formule_contrast<- contro_list[!res]

eval_single_Cond <- if(all(res)){FALSE}else{TRUE}
if(!eval_single_Cond | length(formule_contrast) > 0){
  cat("*WARNING*: Some comparisons cannot be done since have only two samples. The comparison are removed.")
}
```


```{r mds_counts, warning=F, message=F, echo=F, results='asis', eval=eval_single_Cond}
cat(" \n \n")
cat("#### 1.5. Multi-dimensional scaling {.tabset}  \n")
cat("Multidimensional scaling (MDS) takes a set of dissimilarities and returns a set of points such that the distances between the points are approximately equal to the dissimilarities. Classical multidimensional scaling is also known as principal coordinates analysis. \n \n ")
cat("MDS analysis is performed on normalized **Protein** and **Peptide** abundances. \n")
cat(" \n \n")

sample_data<-(t(dat_gene))
sample_distances <- dist(sample_data, method = "euclidean")

mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
mds_cmdscale$sample <- rownames(mds_cmdscale)

mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno))

#Take correct order of color

cc<-mds_cmdscale$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
  names(cc)<-unique(mds_cmdscale$condition)
} else{
  names(cc)<-mds_cmdscale$condition
}


cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
  geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  scale_colour_manual(values=cc[unique(names(cc))]) +
  theme_bw(base_size = bs, base_family = bf) +
  theme(legend.position = "right", panel.grid.minor=element_blank())

cat("##### Proteins \n")
print(cmd)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"mds_proteins.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,cmd)

#Peptides
sample_data<-(t(dat_pep))
sample_distances <- dist(sample_data, method = "euclidean")

mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
mds_cmdscale$sample <- rownames(mds_cmdscale)

mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno))

#Take correct order of color

cc<-mds_cmdscale$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
  names(cc)<-unique(mds_cmdscale$condition)
} else{
  names(cc)<-mds_cmdscale$condition
}


cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
  geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  scale_colour_manual(values=cc[unique(names(cc))]) +
  theme_bw(base_size = bs, base_family = bf) +
  theme(legend.position = "right", panel.grid.minor=element_blank())

cat("##### Peptides \n")
print(cmd)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"mds_peptides.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,cmd)

shiny::setProgress(0.49, detail = "Calculate MDS...")
```

```{r pca_norm, warning=F, message=F, echo=F, results='asis', eval=eval_single_Cond}
cat(" \n \n")
cat("#### 1.6. Principal Component Analysis {.tabset}  \n")
cat("Principal component analysis (PCA) is performed on normalized Protein and Peptide abundances. \n \n ")
cat(" \n \n")


sample_data<-(t(dat_gene))
apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
pc <- apca_prot$x[,1:2]

pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
pc<- merge(pc, c_anno, by = 0)
pc$condition <- as.factor(pc$condition)

ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
ve <- ve[c(1, 2)]
labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

#Take correct order of color
cc<-pc$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(pc$condition))]
  names(cc)<-unique(pc$condition)
} else{
  names(cc)<-pc$condition
}

#ggplot method
p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
      geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
      geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
      scale_colour_manual(values=cc[unique(names(cc))]) +
      theme_bw(base_size = bs, base_family = bf) +
      theme(legend.position = "right", panel.grid.minor=element_blank()) +
      xlab(labs[1]) +
      ylab(labs[2])

cat("##### Proteins \n")
print(p1)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"pca_protein.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,cmd)

#Peptides
sample_data<-(t(dat_pep))
apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
pc <- apca_prot$x[,1:2]

pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
pc<- merge(pc, c_anno, by = 0)
pc$condition <- as.factor(pc$condition)

ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
ve <- ve[c(1, 2)]
labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

#Take correct order of color
cc<-pc$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(pc$condition))]
  names(cc)<-unique(pc$condition)
} else{
  names(cc)<-pc$condition
}

#ggplot method
p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
      geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
      geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
      scale_colour_manual(values=cc[unique(names(cc))]) +
      theme_bw(base_size = bs, base_family = bf) +
      theme(legend.position = "right", panel.grid.minor=element_blank()) +
      xlab(labs[1]) +
      ylab(labs[2])

cat("##### Peptides \n")
print(p1)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"pca_peptides.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,p1)

shiny::setProgress(0.51, detail = "Calculate PCA...")
```


```{r boxplot_proteins, warning=F, message=F, echo=F, eval=boxplot_prot_exe, results='asis'}
prot_find<-unique(c(intersect(prot_boxplot,rownames(dat_gene)),
                    intersect(str_to_title(prot_boxplot),rownames(dat_gene)),
                    intersect(str_to_upper(prot_boxplot),rownames(dat_gene)),
                    intersect(str_to_lower(prot_boxplot),rownames(dat_gene))))

if(length(prot_find)>0){
  cat("#### 1.7. Abundances of selected proteins {.tabset}  \n")
  cat("Normalized log2 abundancies are displayed for proteins selected in the input. Abundances are grouped per condition. \n \n ")
  cat("Selected proteins with available abundancies: \n")
  cat(paste(prot_find, sep = ", "))
  cat(" \n")
  cat(" \n \n")

  prot_intensity_long <- proBatch::matrix_to_long(dat_gene[prot_find,]) %>%
                              data.table::setnames(new = c("Protein","Condition","Intensity"))
  prot_intensity_long <- unique((left_join(prot_intensity_long,
                                             c_anno[prot_intensity_long$Condition, c("sample","condition")],
                                             by=c("Condition"="sample")))[,-c(2)])  %>%
                              data.table::setnames(new = c("Protein","Intensity","Condition"))
    

  avg_df = expr_avg_df %>% dplyr::filter(id %in% prot_find) %>% dplyr::select(colnames(expr_avg_df)[-c(1)])
  se_df = expr_se_df %>% dplyr::filter(id %in% prot_find) %>% dplyr::select(colnames(expr_se_df)[-c(1)])
  prot_avg_long <- proBatch::matrix_to_long(avg_df) %>% data.table::setnames(new = c("Protein","Condition","avg"))
  prot_avg_long$Protein<-(expr_avg_df %>% dplyr::filter(id %in% prot_find))$id[as.integer(prot_avg_long$Protein)]
  prot_se_long <- proBatch::matrix_to_long(se_df) %>% data.table::setnames(new = c("Protein","Condition","se"))
  prot_se_long$Protein<-(expr_se_df %>% dplyr::filter(id %in% prot_find))$id[as.integer(prot_se_long$Protein)]
  prot_avg_se_long <- cbind(prot_avg_long,prot_se_long[3])
  prot_avg_se_long$Condition <- str_replace(prot_avg_se_long$Condition, "_avg", "")

    # save(prot_intensity_long, cc, bs, bf,cc, prot_avg_se_long, dat_gene, prot_find, c_anno, file = "tmp_2.RData")
  g<-ggplot(prot_avg_se_long,aes(Condition,avg,fill=Condition,colour=Condition))+
    geom_crossbar(aes(ymin=avg,ymax=avg),position = "dodge",width=.8,alpha=.9,fatten=1.5)+
    geom_errorbar(aes(ymin=(avg-se), ymax=(avg+se)), width=.4,position=position_dodge(),show.legend=F,alpha=.8)+
    geom_quasirandom(data=prot_intensity_long, aes(Condition,Intensity), alpha=.7,width=.1,shape=16,size=0.11*bs)+
    scale_fill_manual(name="Condition",values=cc[sort(unique(prot_intensity_long$Condition))]) +
    scale_colour_manual(name="Condition",values=cc[sort(unique(prot_intensity_long$Condition))])+
    # scale_y_continuous(limits=c(0,NA),expand = expand_scale(mult = c(.1, .25)))+
    theme_bw(base_size = bs, base_family = bf) +
    theme(axis.title.x=element_blank()) +
    theme(axis.text.x = element_text(angle = 30, hjust = 1, colour=cc[sort(unique(prot_intensity_long$Condition))]))+
    theme(panel.grid.major.x=element_blank(),
          panel.grid.minor.y=element_blank())+
    theme(legend.text = element_text(size = 0.7*bs),
          legend.key.size = unit((0.015*bs),"in"),
          legend.position="none",
          legend.title=element_blank(),
          legend.background = element_rect(fill = NA))+

    theme(strip.text=element_text(colour="white",face="bold"))+
    theme(panel.border=element_rect(colour=c("grey40"),size=0.03*bs))+
    theme(strip.background=element_rect(fill="grey40",colour="grey40",size=0.03*bs))+
    theme(plot.title = element_text(hjust = 0.5))+
    facet_wrap(~Protein, scales = "free",ncol = if(length(prot_find)>4){round(length(prot_find)/1.9)}else{4})+
    labs(y="Abundance")
  print(g)

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_expr,"selected_protein_plot.pdf"), g, device=cairo_pdf, 
                          width = ((if(length(prot_find)<4){((length(prot_find)-1/(length(prot_find)))^1.2)*0.9}else{(4*1.2)*0.9}))+(0.75*length(unique(prot_avg_se_long$Condition))), 
                          height = 4*(if(length(prot_find)>=4){(length(prot_find) %/% 4)+1}else{1}), units = c("in")))

}else{
  cat("##### Selected proteins in options file do not find in the normalised matrix. Check the spell of the proteins. \n")
  cat(" \n \n")
}

shiny::setProgress(0.56, detail = "Control boxplot proteins...")
```

## 2. Identification of Differentially Expressed Proteins and Peptides

Differentially expressed peptides are identified using the Limma Bioconductor package.

```{r print_error_diff_analysis, warning=FALSE, echo=F, message=FALSE, results='asis', eval=!(eval_single_Cond)}
cat(" \n \n")
#Print summary of filter and contrast design

cat("**WARNING:** differential analysis not executed since are identified only 1 sample for the two condition \n ")
cat(" \n")
run_enrich <- run_enrich_universe <- run_STRING <- FALSE
```


```{r print_settings_diff_analysis, warning=FALSE, echo=F, message=FALSE, results='asis', eval=eval_single_Cond}
cat(" \n \n")
#Print summary of filter and contrast design

cat("**Thresholds used:** \n ")
cat(" \n")
cat(paste0("- Fold Change threshold: log2_FC > ",fc_thr," (+), log2_FC < -",fc_thr," (-) "))
cat(" \n")
cat(paste0("- Statistica significance threshold: p.val < ",pval_thr," "))
cat(" \n")
if(signal_thr != -Inf){cat(paste0("- Signal log2 intesity threshold: signal > ",signal_thr," "))}
cat(" \n")

```


### 2.1. Differential expression contrasts
The following table contains the names and the formulas of the contrasts considered for differential expression analysis.

```{r print_settings_design, warning=FALSE, echo=F, message=FALSE, results='asis', eval=eval_single_Cond}
cat("**Contrast design formula are:** ")
cat(" \n")
kable(data.frame("Name"=names(formule_contrast), "Formula"=formule_contrast, "Color"=color_constrast[names(formule_contrast), "color_constrast"]), row.names = F)
cat(" \n")

```

```{r diff_analysis,  warning=F, message=F, echo=F, eval=eval_single_Cond}
shiny::setProgress(0.58, detail = "Differential Analysis in progress...")
message("Differentiation analysis in progress...")
#Execution of differentiation analysis using DEqMS for proteins
psm_count_table = as.data.frame(table(dat_psm$symbol))
deps_df <- limmafnc("PROT",c_anno,dat_gene,psm_count_table,formule_contrast,as.data.frame(expr_avgse_df),signal_thr,fc_thr, pval_thr, pval_fdr)
deps_l_df<-deps_df$degs_l_df
deps_w_df<-deps_df$degs_w_df
toPrint<-deps_w_df
colnames(toPrint)[1]<-"GeneSymbol"

#Execution of differentiation analysis using DEqMS for proteins
psm_count_table<-as.data.frame(table(rownames(dat_pep)))
deps_pep_df <- limmafnc("PEP",c_anno,dat_pep,psm_count_table,formule_contrast,as.data.frame(expr_avgse_pep_df),signal_thr,fc_thr, pval_thr, pval_fdr)
deps_pep_l_df<-deps_pep_df$degs_l_df
deps_pep_w_df<-deps_pep_df$degs_w_df
toPrint_pep<-deps_pep_w_df

#Prepare the README
readme_sheet <- data.frame("INFO"=c(   NA,
                                "Excel file containing the results of differential analysis, according to the contrasts defined in the Design file. The file is organized in the following sheets:",
                                "protein_DE: protein differential expression results protein abundances per sample.",
                                "peptide_DE: peptide differential expression results. ",
                                NA,
                                "Annotation columns:",
                                "1. *Accession*: protein UniprotID,",
                                "2. *Description*: protein description,",
                                "3. *GeneName*: Gene Symbol,",
                                "4. *Peptide_Sequence*: peptide sequence,",
                                "5. *Peptide_Modifications*: peptide modifications,",
                                "6. *Peptide_Position*: start and end position of the peptide within the protein sequence, defined UniprotID,",
                                "7. *Peptide_Tryptic*: peptide tryptic digestion status (fully tryptic, N-semi tryptic, C-semi tryptic, non tryptic)",
                                NA,
                                "And for each comparison:",
                                "8. *class*: defined according to the fold change, p-value and abundance thresholds specified in the input: \"+\" up-regulated protein/peptide, \"-\" down-regulated protein/peptide, \"=\" invariant protein/peptide",
                                "9. *log2_FC*: protein/peptide log2 transformed fold change",
                                "10. *p_val*: protein/peptide contrast p-value",
                                "11. *p_adj*: protein/peptide adjusted p-value (FDR after BH correction)",
                                "12. *log2_expr*: protein/peptide log2 average abundance"
                              ))

#Export table with SE e MEAN
prot_id <- unique(psm_peptide_table[,c("Accession","GeneName")]) %>% group_by(GeneName) %>% summarize_all(toString) %>% left_join(unique(psm_peptide_table[,c("Accession","Description","GeneName")]), 
                                                                                                                                  by = "GeneName", 
                                                                                                                                  multiple = "first",
                                                                                                                                  suffix = c(".id", ".old"))
protein_DE <- unique(left_join(prot_id[,c("Accession.id","Description","GeneName")], toPrint, by=c("GeneName" = "GeneSymbol")))
colnames(protein_DE)[1:7] <- c("Accession","Description","GeneName","Peptide_Sequence","Peptide_Modifications","Peptide_Position","Peptide_Tryptic")
peptide_DE <- left_join(rownames_to_column(psm_peptide_table), toPrint_pep, by=c("rowname" = "id"))[,-c(1)]
colnames(peptide_DE)[1:7] <- c("Accession","Description","GeneName","Peptide_Sequence","Peptide_Modifications","Peptide_Position","Peptide_Tryptic")
df_to_save<-list("README"=readme_sheet,
                 "protein_DE"=protein_DE,
                 "peptide_DE"=peptide_DE)
writexl::write_xlsx(df_to_save,paste0(dirOutput,subfold_Tab,"differential_expression.xlsx"))

remove(deps_df,toPrint,deps_pep_df,toPrint_pep,df_to_save, protein_DE, peptide_DE)
message("Differentation analysis DONE.")

```


In the plot are represented graphically the number of DEPs for each contrast. Tab **Proteins** for the differentially expressed proteins, **Peptides** for the number of the differentially expressed peptides.

```{r number_deps, warning=FALSE, echo=FALSE, results='asis', eval=eval_single_Cond}

# Plot DEPs barplot (as a double barplot)
#####
# plot_DEPs<-function(DEPs_df, # dataframe containing DEPs result
#                     contrast_col="comp", # Name of the column with contrast names
#                     class_col="class", # Name of the column with classes (+,-,= are expected)
#                     color_vec=c("#EAB364", "#84A298") # Colors for Up and Down regulated
#                      ){
#   res_mat<-DEPs_df %>% group_by(get(contrast_col),get(class_col),.drop=FALSE) %>% summarise("Number"=n()) %>% ungroup()
#   # get() to return the value of variable
#   # in this way we can assign the name of the column to a variable and keep the same script changing every time only the name of the column
#   # .drop=FALSE to keep the comparisons with zero-value classes (for example in the fdr df)
#   colnames(res_mat)<-c("Contrast","Class","Number")
#   res_df<-res_mat %>% filter(Class!="=")
# 
#   res_df$Class<-factor(res_df$Class,levels=c("+","-"))
#   res_df$Contrast<-as.factor(res_df$Contrast)
#   res_df$Number<-as.numeric(res_df$Number)
#   res_df$Number[which(res_df$Class=="-")]<-res_df$Number[which(res_df$Class=="-")]*(-1)
#   # *(-1) to assign to the total number of down-reg a - sign and put them on the left of the plot
# 
#   #Change ratio based on the number of comp
#   n_comp<-length(unique(res_df$Contrast))
#   # ratio<-1/((5/n_comp)+0.25)
#   bs<-11
#   bap<-ggplot(res_df,aes(x=Contrast,y=Number,fill=Class)) +
#     scale_fill_manual(name="",values=color_vec,labels=c("Up-Regulated","Down-Regulated"))+
#     geom_bar(stat="identity",position=position_nudge(),width=0.6,alpha=0.9) +
#     geom_text(aes(x=Contrast, y=Number, label=abs(Number), hjust=ifelse(res_df$Number>=0,1.1,-0.1)), colour="white",size=bs*0.4,fontface="plain") +
#     theme_bw(base_size = bs) +
#     theme(axis.title.y=element_blank()) +
#     theme(panel.border=element_blank()) +
#     theme(axis.ticks=element_blank()) +
#     theme(panel.grid=element_blank()) +
#     # theme(aspect.ratio = ratio) +
#     geom_hline(yintercept=0,col="grey30",lty=1,lwd=0.05*bs)+
#     theme(axis.text.y=element_text(colour="grey20")) +
#     theme(axis.text.x=element_blank()) +
#     theme(legend.position="bottom") +
#     #theme(legend.justification=c(1.05,1.05), legend.position=c(1,0.07)) +
#     theme(legend.title=element_blank())+
#     coord_flip()+
#     theme(legend.text = element_text(size = bs),
#           legend.key.size = unit((0.012*bs),"in"))+
#     labs(y="Number of DEPs")
#   return(bap)
# }
#####
cat(" \n \n")
cat("#### 2.2. Number of differentially expressed proteins and peptides for each comparison {.tabset}  \n")
#Execute only if found at least one gene differentiated
if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  heig<-unique(deps_l_df$comp)
  lolli_df <- data.table("comp"=deps_l_df$comp[which(deps_l_df$class == "+" | deps_l_df$class == "-")], 
                       "class"=factor(deps_l_df$class[which(deps_l_df$class == "+" | deps_l_df$class == "-")]))
  lolli_df <- lolli_df[ , .(N = .N), by=c("comp","class")]
  lolli_df$id <- str_c(lolli_df$comp, lolli_df$class, sep="_")
  
  col_vec<-as.vector(t(color_constrast))
  names(col_vec)[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]]<-paste0(lolli_df$comp[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]], "_+")
  names(col_vec)[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 0]]<-paste0(lolli_df$comp[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]], "_-")
  
  
  pDEPs<-deps_b2b_lollipop(input_df=lolli_df, break_vec=seq(0,max(lolli_df$N),round(max(lolli_df$N)/5, 0)), fill_vec = col_vec, color_vec = col_vec, char_max = 30)
  
  # pDEPs<-plot_DEPs(deps_l_df,
  #                   contrast_col="comp",
  #                   class_col="class",
  #                   color_vec=c("grey60", "grey40"))
  oldheig <- knitr::opts_chunk$get("fig.height")
  knitr::opts_chunk$set(fig.height = max(min(20,length(heig)*0.75),2))
  cat("##### Proteins \n")
  print(pDEPs)
  cat(" \n \n")
  knitr::opts_chunk$set(fig.height = oldheig)

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_expr,"DE_protein_barplot.pdf"), pDEPs, device=cairo_pdf, 
                          height = max(min(20,length(heig)*0.75),2), units = c("in")))
  remove(pDEPs,cmd,mds_cmdscale)
}else{
  message("No gene differentiated discovered.")
  cat("No gene differentiated discovered.")
}
#Peptides
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat(" \n \n")
  heig<-unique(deps_pep_l_df$comp)
  lolli_df <- data.table("comp"=deps_pep_l_df$comp[which(deps_pep_l_df$class == "+" | deps_pep_l_df$class == "-")], 
                       "class"=factor(deps_pep_l_df$class[which(deps_pep_l_df$class == "+" | deps_pep_l_df$class == "-")]))
  lolli_df <- lolli_df[ , .(N = .N), by=c("comp","class")]
  lolli_df$id <- str_c(lolli_df$comp, lolli_df$class, sep="_")
  
  col_vec<-as.vector(t(color_constrast))
  names(col_vec)[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]]<-paste0(lolli_df$comp[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]], "_+")
  names(col_vec)[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 0]]<-paste0(lolli_df$comp[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]], "_-")

  
  pDEPs<-deps_b2b_lollipop(input_df=lolli_df, break_vec=seq(0,max(lolli_df$N),round(max(lolli_df$N)/5, 0)), fill_vec = col_vec, color_vec = col_vec, char_max = 30)
  
  # pDEPs<-plot_DEPs(deps_pep_l_df,
  #                   contrast_col="comp",
  #                   class_col="class",
  #                   color_vec=c("grey60", "grey40"))
  
  oldheig <- knitr::opts_chunk$get("fig.height")
  knitr::opts_chunk$set(fig.height = max(min(20,length(heig)*0.75),2))
  cat("##### Peptides \n")
  print(pDEPs)
  cat(" \n \n")
  knitr::opts_chunk$set(fig.height = oldheig)

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_expr,"DE_peptide_barplot.pdf"), pDEPs, device=cairo_pdf, 
                          height = max(min(20,length(heig)*0.75),2), units = c("in")))
  remove(pDEPs,cmd,mds_cmdscale)
}else{
  message("No gene differentiated discovered.")
  cat("No gene differentiated discovered.")
}





shiny::setProgress(0.60, detail = "Count DEPs...")
```

```{r volcano_protein, fig.height=6, fig.width=6, warning=FALSE, echo=FALSE, results='asis', eval=eval_single_Cond}
cat(" \n \n")
if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat("#### 2.3. Volcano plots  \n")
  cat("Differentially expressed proteins/peptides are displayes according to the thresholds set in the input. \n \n ")
  cat(" - \"+\" up-regulated protein/pept√¨de \n ")
  cat(" - \"-\" down-regulated protein/pept√¨de \n ")
  cat(" - \"=\" invariant protein/pept√¨de \n \n ")
  cat("Top enriched proteins/peptides are labeled. \n")
  cat(" \n \n")
  
  cat("#### 2.3.1. Volcano plots of Proteins {.tabset}  \n")
  cat(" \n \n")
  

  for(comp in unique(deps_l_df$comp)){
    input_df <- deps_l_df[which(deps_l_df$comp == comp),]
    labels_up <- (input_df %>% filter(class == '+'))$id
    labels_down <- (input_df %>% filter(class == '-'))$id

    cmd<-ggplot(data=input_df, aes(x=log2_FC, y=-log10(if(pval_fdr){p_adj}else{p_val}), col=class, label=id)) +
      geom_point(pch=20,cex=2) +
      geom_hline(yintercept=-log10(pval_thr), col="black") +
      geom_vline(xintercept=c(-fc_thr, fc_thr), col="black") +
      # geom_text_repel(data = input_df %>% filter(id %in% labels),color="white") +
      geom_label_repel(data = input_df %>% filter(id %in% labels_up), label.padding = unit(0.1, "lines"), color="black",xlim = c(1.5, NA)) +
      geom_label_repel(data = input_df %>% filter(id %in% labels_down), label.padding = unit(0.1, "lines"), color="black",xlim = c(NA, -1.5)) +
      ggtitle(paste0("Volcano Plot of ",comp)) +
      ylab(if(pval_fdr){"-log10(fdr)"}else{"-log10(p_val"}) +
      scale_color_manual(values=c(color_constrast[comp,"color_constrast"], color_constrast[comp,"color_constrast_dark"], "grey70")) +
      scale_x_continuous(limits = c(min(-max(abs(input_df$log2_FC)),-3), max(max(abs(input_df$log2_FC)),3))) +
      scale_y_continuous(limits = c(0, max(max(abs(-log10(if(pval_fdr){input_df$p_adj}else{input_df$p_val}))),4))) +
      theme_bw(base_size = bs, base_family = bf)

    cat("##### ",comp," \n")
    print(cmd)
    cat(" \n \n")
  }
shiny::setProgress(0.63, detail = "Perform volcano plot...")
}

```

```{r volcano_pep, fig.height=6, fig.width=6, warning=FALSE, echo=FALSE, results='asis', eval=eval_single_Cond}
cat(" \n \n")
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){

  cat("#### 2.3.2. Volcano plot of Peptides {.tabset}  \n")
  cat(" \n \n")

  for(comp in unique(deps_pep_l_df$comp)){
    input_df <- na.omit((deps_pep_l_df[which(deps_pep_l_df$comp == comp),])[order(deps_pep_l_df$id),])
    pos<-lapply(str_match_all(str_split(psm_peptide_table$`Position in Master Proteins`,";",n=1),"\\[(.*?)\\]"), function(x){x[,1][1]})
    labels<-str_c(psm_peptide_table$GeneName,pos,sep="_")
    input_df$id<-labels
    labels_up <- (input_df %>% filter(class == '+'))$id
    labels_down <- (input_df %>% filter(class == '-'))$id

    cmd<-ggplot(data=input_df, aes(x=log2_FC, y=-log10(if(pval_fdr){p_adj}else{p_val}), col=class, label=id)) +
      geom_point(pch=20,cex=2) +
      geom_hline(yintercept=-log10(pval_thr), col="black") +
      geom_vline(xintercept=c(-fc_thr, fc_thr), col="black") +
      # geom_text_repel(data = input_df %>% filter(id %in% labels),color="white") +
      geom_label_repel(data = input_df %>% filter(id %in% labels_up, class == '+'),
                       label.padding = unit(0.1, "lines"), color="black",xlim = c(1.5, NA)) +
      geom_label_repel(data = input_df %>% filter(id %in% labels_down, class == '-'),
                       label.padding = unit(0.1, "lines"), color="black",xlim = c(NA, -1.5)) +
      ggtitle(paste0("Volcano Plot of ",comp)) +
      ylab(if(pval_fdr){"-log10(fdr)"}else{"-log10(p_val"}) +
      scale_color_manual(values=c(color_constrast[comp,"color_constrast"], color_constrast[comp,"color_constrast_dark"], "grey70")) +
      scale_x_continuous(limits = c(min(-max(abs(input_df$log2_FC)),-3), max(max(abs(input_df$log2_FC)),3))) +
      scale_y_continuous(limits = c(0, max(max(abs(-log10(if(pval_fdr){input_df$p_adj}else{input_df$p_val}))),4))) +
      theme_bw(base_size = bs, base_family = bf)

    cat("##### ",comp," \n")
    print(cmd)
    cat(" \n \n")
  }
shiny::setProgress(0.65, detail = "Perform volcano plot...")
}
```

```{r MDS_prot_deps, warning=F, message=F, echo=F, results='asis', eval=eval_single_Cond}
if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat("#### 2.4. MDS based on differentially expressed proteins and peptides {.tabset}  \n " )
  cat("Multidimensional scaling (MDS) are performed on normalized abundances of differentially expressed Proteins and Peptides. \n")
  cat(" \n \n")  #Select only genes that are differentiated and print PCA of samples
  deps_vec_all<- deps_l_df %>% dplyr::filter(class!="=") %>% pull(id) %>% unique() %>% sort()

  # sample_data<-t(dat_gene[toupper(deps_vec_all),])
  sample_data<-t(dat_gene[(deps_vec_all),])

  sample_distances <- dist(sample_data, method = "euclidean")

  mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
  colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
  mds_cmdscale$sample <- rownames(mds_cmdscale)

  mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno))
  #Take correct order of color
  cc<-mds_cmdscale$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
    names(cc)<-unique(mds_cmdscale$condition)
  } else{
    names(cc)<-mds_cmdscale$condition
  }
  cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
    # ggtitle("samples")+
    geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
    geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
    scale_colour_manual(values=cc[unique(names(cc))]) +
    theme_bw(base_size = bs, base_family = bf) +
    theme(legend.position = "right", panel.grid.minor=element_blank())

  cat("##### Proteins \n")
  print(cmd)
  cat(" \n \n")

  ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"DE_mds_protein.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in"))

  shiny::setProgress(0.67, detail = "Perform MDS...")

}

cat(" \n \n")
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  #Select only genes that are differentiated and print PCA of samples
  deps_vec_all<- deps_pep_l_df %>% dplyr::filter(class!="=") %>% pull(id) %>% unique() %>% sort()

  # sample_data<-t(dat_gene[toupper(deps_vec_all),])
  sample_data<-t(dat_pep[(deps_vec_all),])

  sample_distances <- dist(sample_data, method = "euclidean")

  mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
  colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
  mds_cmdscale$sample <- rownames(mds_cmdscale)

  mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno))
  #Take correct order of color
  cc<-mds_cmdscale$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
    names(cc)<-unique(mds_cmdscale$condition)
  } else{
    names(cc)<-mds_cmdscale$condition
  }
  cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
    # ggtitle("samples")+
    geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
    geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
    scale_colour_manual(values=cc[unique(names(cc))]) +
    theme_bw(base_size = bs, base_family = bf) +
    theme(legend.position = "right", panel.grid.minor=element_blank())

  cat("##### Peptides \n")
  print(cmd)
  cat(" \n \n")

  ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"DE_mds_peptide.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in"))

shiny::setProgress(0.69, detail = "Perform MDS...")
}

```


```{r pca_deps, warning=F, message=F, echo=F, results='asis', eval=eval_single_Cond}
if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){  

shiny::setProgress(0.70, detail = "Perform PCA...")
  cat(" \n \n")
  cat("#### 2.5. PCA based on differentially expressed proteins and peptides {.tabset}  \n")
  cat("Principal component analysis (PCA) are performed on normalized abundances of differentially expressed Proteins and Peptides. \n")
  cat(" \n \n")

  deps_vec_all<- deps_l_df %>% dplyr::filter(class!="=") %>% pull(id) %>% unique() %>% sort()

  # sample_data<-t(dat_gene[toupper(deps_vec_all),])
  sample_data<-t(dat_gene[(deps_vec_all),])
  apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
  pc <- apca_prot$x[,1:2]

  pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
  pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
  pc<- merge(pc, c_anno, by = 0)
  pc$condition <- as.factor(pc$condition)

  ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
  ve <- ve[c(1, 2)]
  labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

  #Take correct order of color
  cc<-pc$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(pc$condition))]
    names(cc)<-unique(pc$condition)
  } else{
    names(cc)<-pc$condition
  }
  #ggplot method
  p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
        geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
        geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
        scale_colour_manual(values=cc[unique(names(cc))]) +
        theme_bw(base_size = bs, base_family = bf) +
        theme(legend.position = "right", panel.grid.minor=element_blank()) +
        xlab(labs[1]) +
        ylab(labs[2])

  cat("##### Proteins \n")
  print(p1)
  cat(" \n \n")

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"DE_pca_protein.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

  remove(sample_data,sample_distances,mds_cmdscale,cmd)
}


cat(" \n \n")
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  #Peptides
  deps_vec_all<- deps_pep_l_df %>% dplyr::filter(class!="=") %>%
  pull(id) %>% unique() %>% sort()

  # sample_data<-t(dat_gene[toupper(deps_vec_all),])
  sample_data<-t(dat_pep[(deps_vec_all),])
  apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
  pc <- apca_prot$x[,1:2]

  pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
  pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
  pc<- merge(pc, c_anno, by = 0)
  pc$condition <- as.factor(pc$condition)

  ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
  ve <- ve[c(1, 2)]
  labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

  #Take correct order of color
  cc<-pc$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(pc$condition))]
    names(cc)<-unique(pc$condition)
  } else{
    names(cc)<-pc$condition
  }
  #ggplot method
  p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
        geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
        geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
        scale_colour_manual(values=cc[unique(names(cc))]) +
        theme_bw(base_size = bs, base_family = bf) +
        theme(legend.position = "right", panel.grid.minor=element_blank()) +
        xlab(labs[1]) +
        ylab(labs[2])

  cat("##### Peptides \n")
  print(p1)
  cat(" \n \n")

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"DE_pca_peptide.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

  remove(sample_data,sample_distances,mds_cmdscale,p1)
}

```


```{r enrichment_universe,message=F, warning=F,echo=F, eval=run_enrich_universe, results='asis'}
shiny::setProgress(0.75, detail = "Enrichment in progress whole Universe in background... \n Can require several minutes...")

message("Enrichment in progress whole Universe in background... \n Can require several minutes...")
#Perform enriched analysis with EnrichR
dbs<-NULL
if(enrichR_DB){
  dbs<-enrich_filter_DBs
}

p = callr::r_bg(
    func = function(g, pval_fdr_enrich, pval_enrich_thr,overlap_size_enrich_thr,dbs) {
      source("functions_2021.R")
      enrichRfnc_universe(g, pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr,dbs)
    },
    args = list(unique(psm_anno_df$symbol), pval_fdr_enrich, pval_enrich_thr,overlap_size_enrich_thr,dbs),
    stdout = "|",
    stderr = "|",
    error = getOption("callr.error", "error")
  )

```

```{r enrichment,message=F, warning=F,echo=F, eval=run_enrich, results='asis'}
shiny::setProgress(0.75, detail = "Enrichment in progress... \n Can require several minutes...")
cat(" \n \n")
cat("## 3. Functional enrichment analysis \n")
cat("Annotation enrichment analysis is performed using the web-based application [EnrichR](https://maayanlab.cloud/Enrichr/), against an updated collection of 98 databases covering Transcription, Pathways, Ontologies, Diseases, Drugs, Cell Types, Experimental Datasets. \n \n ")
cat("For each comparison enrichment is calculate over up-regulated proteins (UP), down-regulated proteins (DOWN), and their union (ALL). \n")
cat(" \n")
cat(paste0("- Statistical significance threshold: p.val < ",pval_enrich_thr," "))
cat(" \n")
cat(paste0("- Overlap size threshold for enrichment analysis: OverlapSize > ",overlap_size_enrich_thr," "))
cat(" \n")
if(run_enrich_universe){cat("- Execution of the enrichmentalso on all detected proteins.")}
def_val_height=  knitr::opts_chunk$get("fig.height")
message("Enrichment step with EnrichR in proress...")
doNextChunk <- tryCatch({
  dbs<-NULL
  if(enrichR_DB){
    dbs<-enrich_filter_DBs
  }
  #Perform enriched analysis with EnrichR
  enr_df<-enrichRfnc(deps_l_df, pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr, dbs)
  #Save in RData for possible further analysis
  enrich_df<-enr_df[which(enr_df$Significant == "TRUE" & enr_df$overlap_size>=overlap_size_enrich_thr),c(1:13)]
  save(enrich_df, file=paste0(dirOutput,subfold_Dat,"enrichment_DE.RData"))
  
  #Prepare the README
  readme_sheet <- data.frame("INFO"=c(   NA,
                                "Excel file containing a selection of enrichment results starting from differentially expressed proteins. 
                                Terms are selected according to significance thresholds specified in the input (Default: adj.P.Value < 0.05, Overlap Size >= 5)",
                                NA,
                                "Enrichment columns:",
                                "1. *input_name*: comparison name,",
                                "2. *anno_name*: enriched name term,",
                                "3. *anno_class*: dataset,",
                                "4. *overlap_sive*: DEPs in term,",
                                "5. *p_value*: p-value,",
                                "6. *fdr*: adjusted p-value (FDR after BH correction),",
                                "7. *odds_ratio*: ",
                                "8. *combined_score*: combined score provide by EnrichR,",
                                "9. *input_size*: DEPs of the comparison,",
                                "10. *anno_size*: number protein of the term,",
                                "11. *overlap_input_ratio*: overlap_size/input_size",
                                "12. *overlap_anno_ratio*: overlap_size/anno_size",
                                "13. *overlap_ids*: gene symbols identified in the term"
                              ))
  writexl::write_xlsx(enrich_df,
                      path = paste0(dirOutput,subfold_Tab,"enrichment_DE.xlsx"))
  remove(enrich_df)
    
  dir.create(file.path(dirOutput,subfold_Fig,subfold_enrich), showWarnings = FALSE)
  dirOutput_enr=paste0(dirOutput,subfold_Fig,subfold_enrich)
  TRUE
},
error=function(cond){
  print("\n ERROR: An error occur when connect to EnrichR. \n ")
  FALSE
})
message("Enrichment DONE.")
shiny::setProgress(0.77, detail = "Done Enrichment...")

```


```{r enrichment_plots_all, echo=F, message=F, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  cat("#### 3.1. Top enrichments in selected annotation databases (ALL).\n")
  cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
  cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
  cat("**Differentially expressed proteins (ALL)** \n ")
  #Select DEPs in the DBs of interest
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  #Select the ALL column (UP union DOWN)
  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='hide'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
    # col_vec<-color_base
    # if(length(as.vector(t(color_constrast)))>0){
    col_vec<-as.vector((color_constrast))
    names(col_vec)<-unique(enr_sele_df$input_name)
    # }
    el<- enrichment_dotmatrix(enr_sele_df,
                           size_col="log2_OR",
                           color_col="input_name",
                           color_vec=col_vec,
                           shape_vec=c(16,21),
                          shape_col = "Significant",
                          fill_col = "Significant",
                           char_max=60) +guides(color=F, shape = guide_legend(override.aes = list(size=4)))

  tryCatch({
    print(el +guides(color=F))
    ggsave(paste0(dirOutput_enr,"enr_DE_keysources.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.77, detail = "Plotting enrichment results...")
```

```{r enrichment_plots, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  cat("#### 3.2. Top enrichments in selected annotation databases (UP,DOWN).\n")
  cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
  cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
  cat("**Up-regulated and down-regulated proteins (UP,DOWN)** \n ")
  #Select DEPs in the DBs of interest
  #Filter the DEPs taking only the ones from the desired DBs
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  !str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  #Select the results divided in up and down
  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='hide'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  #Print the plot
  # col_vec<-color_base[sort(rep(c(1:length(color_base)),2))]
  # if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector(t(color_constrast))
  names(col_vec)<-unique(enr_sele_df$input_name)
  # }
  el<- enrichment_dotmatrix(enr_sele_df,
                           size_col="log2_OR",
                           color_col="input_name",
                           color_vec = col_vec,
                           shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                           shape_col = "Group",
                          fill_col = "Significant",
                           # color_vec=color_base[sort(rep(c(1:length(color_base)),2))],
                           char_max=60) + guides(color=F, shape = guide_legend(override.aes = list(shape = c(16,21),size=4), title = "Significant"), fill=F)
  
  
  tryCatch({
    print(el +guides(color=F))
    message(paste0(dirOutput_enr,"enr_updown_keysources.pdf"))
    ggsave(paste0(dirOutput_enr,"enr_updown_keysources.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.79, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_all_terms, echo=F, message=F, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  cat("#### 3.3. Top enrichments based on selected keywords (ALL). \n")
  cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
  cat("The dot plots shows the top significant terms containing selected keywords. \n")
  cat("Differentially expressed proteins (ALL) \n")
  cat("**List of terms to search:**")
  cat(" \n")
  cat(paste(enrich_filter_term, collapse=", "))

  lookup_words<-enrich_filter_term

  enr_sele_names<-NULL
  #For each pattern search in DEPs name
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  # write_tsv(enr_sele_df ,file=paste(dirOutput,dirOutput_ev,"enrich_myc_v1_all.txt",sep=""))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_terms_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='hide'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  # col_vec<-color_base
  #   if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector((color_constrast))
  names(col_vec)<-unique(enr_sele_df$input_name)
    # }
  el<- enrichment_dotmatrix(enr_sele_df,
                         size_col="log2_OR",
                         color_col="input_name",
                         color_vec=col_vec,
                         shape_vec=c(16,21),
                         shape_col = "Significant",
                          fill_col = "Significant",
                         char_max=60) + guides(color=F, shape = guide_legend(override.aes = list(size=4)))

  tryCatch({
    print(el)

    ggsave(paste0(dirOutput_enr,"enr_DE_keywords.pdf"), el, device=cairo_pdf, width = 7, height =
             max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })

}

shiny::setProgress(0.82, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_terms, echo=F, message=F, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  cat("#### 3.4. Top enrichments based on selected keywords (UP,DOWN). \n ")
  cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
  cat("The dot plots shows the top significant terms containing selected keywords \n")
  cat("Up-regulated and down-regulated proteins (UP,DOWN) \n")
  cat("**List of terms to search:**")
  cat(" \n")
  cat(paste(enrich_filter_term, collapse=", "))

  lookup_words<-enrich_filter_term

  enr_sele_names<-NULL

  #For each patter we want, search in each DEPs name to find it
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        !str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  # write_tsv(enr_sele_df ,file=paste(dirOutput,dirOutput_ev,"enrich_myc_v1_all.txt",sep=""))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
  # enr_sele_df$Group <- str_c(enr_sele_df$Significant, enr_sele_df$Group)
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_terms_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='hide'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  # col_vec<-color_base[sort(rep(c(1:length(color_base)),2))]
  # if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector(t(color_constrast))
  names(col_vec)<-unique(enr_sele_df$input_name)
  # }  
  el<- enrichment_dotmatrix(enr_sele_df,
                         size_col="log2_OR",
                         color_col="input_name",
                         color_vec = col_vec,
                           shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                           shape_col = "Group",
                           fill_col = "Significant",
                         char_max=60)  + guides(color=F, shape = guide_legend(override.aes = list(shape = c(16,21),size=4), title = "Significant"), fill=F)
  tryCatch({
    print(el)

    ggsave(paste0(dirOutput_enr,"enr_updown_keywords.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })

}

shiny::setProgress(0.85, detail = "Plotting enrichment results...")
```




```{r enrichment_universe_get, message=F, warning=F,echo=F, eval=run_enrich_universe, results='asis'}
shiny::setProgress(0.75, detail = "Enrichment in progress whole Universe in background... \n Can require several minutes...")

#Wait 10 minutes. If do not end in 10 minutes, kill the process
hide_res<-p$read_output()
p$wait(30000)
for (i in 1:10) {
  p$read_output()
  p$wait(1000*60)  
}

if(p$is_alive() | is.null(p$get_result())){
  p$kill()
  print("\n ERROR: An error occur when connect to EnrichR for the enrichemnt of the whole universe of the experiment. \n ")
  run_enrich_universe <- FALSE
} else{
  enr_df_universe<-p$get_result()
  p$kill()
  #Save in RData for possible further analysis
  enrich_all_df <- (enr_df_universe %>% dplyr::filter(Significant == "TRUE", overlap_size>=overlap_size_enrich_thr))[,c(1:13)]
  save(enrich_all_df, file=paste0(dirOutput,subfold_Dat,"enrichment_allproteins.RData"))
  
  writexl::write_xlsx(enrich_all_df,
                      path = paste0(dirOutput,subfold_Tab,"enrichment_allproteins.xlsx"))
  remove(enrich_all_df)

  dir.create(file.path(dirOutput,subfold_Fig,"enrich/"), showWarnings = FALSE)
  dirOutput_enr=paste0(dirOutput,subfold_Fig,"enrich/")
  message("Enrichment whole universe DONE.")
}
shiny::setProgress(0.75, detail = "Done Enrichment of universe...")
```

```{r enrichment_plots_all_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_DBs) > 0){
  cat("#### 3.1. Top enrichments in selected annotation databases with Universe background (ALL).\n")
  cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
  cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
  cat("**Differentially expressed proteins (ALL)** \n ")
  #Select DEPs in the DBs of interest
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  #Select the ALL column (UP union DOWN)
  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='hide'}

if(length(enrich_filter_DBs) > 0){
    # col_vec<-color_base
    # if(length(as.vector(t(color_constrast)))>0){
    col_vec<-as.vector(c((color_constrast), "grey30", "grey70"))
    names(col_vec)<-unique(enr_sele_df$input_name)
    col_vec["Universe_all"]<-"grey50"
    # }
    el<- enrichment_dotmatrix(enr_sele_df,
                           size_col="log2_OR",
                           color_col="input_name",
                           color_vec=col_vec,
                           shape_vec=c(16,21),
                         shape_col = "Significant",
                         fill_col = "Significant",
                           char_max=60) +guides(color=F, shape = guide_legend(override.aes = list(size=4)))

  tryCatch({
    print(el +guides(color=F))
    ggsave(paste0(dirOutput_enr,"enr_DE_keysources.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.77, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_DBs) > 0){
  cat("#### 3.2. Top enrichments in selected annotation databases with Universe background (UP,DOWN).\n")
  cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
  cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
  cat("**Up-regulated and down-regulated proteins (UP,DOWN)** \n ")
  
  #Filter the DEPs taking only the ones from the desired DBs
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  !str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  #Select the results divided in up and down
  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all") | str_ends(input_name,"Universe_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='hide'}

if(length(enrich_filter_DBs) > 0){
  #Print the plot
  # col_vec<-color_base[sort(rep(c(1:length(color_base)),2))]
  # if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector(c(t(color_constrast), "grey50"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  # }
  el<- enrichment_dotmatrix(enr_sele_df,
                           size_col="log2_OR",
                           color_col="input_name",
                           color_vec = col_vec,
                           shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                           shape_col = "Group",
                           fill_col = "Significant",
                           # color_vec=color_base[sort(rep(c(1:length(color_base)),2))],
                           char_max=60)  + guides(color=F, shape = guide_legend(override.aes = list(shape = if("Universe_all" %in% enr_sele_df$input_name){c(17,24,16)}else{c(17,24)},size=4), title = "Significant"), fill=F)

  tryCatch({
    print(el)
    message(paste0(dirOutput_enr,"enr_updown_keysources.pdf"))
    ggsave(paste0(dirOutput_enr,"enr_updown_keysources.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.79, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_all_terms_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_term) > 0){
  cat("#### 3.3. Top enrichments based on selected keywords with Universe background (ALL). \n")
  cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
  cat("The dot plots shows the top significant terms containing selected keywords. \n")
  cat("Differentially expressed proteins (ALL) \n")
  cat("**List of terms to search:**")
  cat(" \n")
  cat(paste(enrich_filter_term, collapse=", "))

  lookup_words<-enrich_filter_term

  enr_sele_names<-NULL
  #For each pattern search in DEPs name
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  # write_tsv(enr_sele_df ,file=paste(dirOutput,dirOutput_ev,"enrich_myc_v1_all.txt",sep=""))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_terms_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='hide'}

if(length(enrich_filter_term) > 0){
  # col_vec<-color_base
  #   if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector(c((color_constrast), "grey30", "grey70"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  col_vec["Universe_all"]<-"grey50"
    # }
  el<- enrichment_dotmatrix(enr_sele_df,
                         size_col="log2_OR",
                         color_col="input_name",
                         color_vec=col_vec,
                         shape_vec=c(16,21),
                         shape_col = "Significant",
                         fill_col = "Significant",
                         char_max=60) + guides(color=F, shape = guide_legend(override.aes = list(size=4)))

  tryCatch({
    print(el)

    ggsave(paste0(dirOutput_enr,"enr_DE_keywords.pdf"), el, device=cairo_pdf, width = 7, height =
             max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })

}

shiny::setProgress(0.82, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_terms_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_term) > 0){
  cat("#### 3.4. Top enrichments based on selected keywords with Universe background (UP,DOWN). \n ")
  cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
  cat("The dot plots shows the top significant terms containing selected keywords \n")
  cat("Up-regulated and down-regulated proteins (UP,DOWN) \n")
  cat("**List of terms to search:**")
  cat(" \n")
  cat(paste(enrich_filter_term, collapse=", "))

  lookup_words<-enrich_filter_term

  enr_sele_names<-NULL

  #For each patter we want, search in each DEPs name to find it
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        !str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  # write_tsv(enr_sele_df ,file=paste(dirOutput,dirOutput_ev,"enrich_myc_v1_all.txt",sep=""))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all") | str_ends(input_name,"Universe_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_terms_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='hide'}

if(length(enrich_filter_term) > 0){
  # col_vec<-color_base[sort(rep(c(1:length(color_base)),2))]
  # if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector(c(t(color_constrast), "grey50"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  # }  
  el<- enrichment_dotmatrix(enr_sele_df,
                         size_col="log2_OR",
                         color_col="input_name",
                         color_vec = col_vec,
                           shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                          shape_col = "Group",
                           fill_col = "Significant",
                           # color_vec=color_base[sort(rep(c(1:length(color_base)),2))],
                           char_max=60)  + guides(color=F, shape = guide_legend(override.aes = list(shape = if("Universe_all" %in% enr_sele_df$input_name){c(17,24,16)}else{c(17,24)},size=4), title = "Significant"), fill=F)
  tryCatch({
    print(el)

    ggsave(paste0(dirOutput_enr,"enr_updown_keywords.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })

}

shiny::setProgress(0.85, detail = "Plotting enrichment results...")
```





```{r selection_genes, echo=F, message=F, warning=F, eval=run_STRING, results='asis'}
shiny::setProgress(0.90, detail = "Network analysis in progress... \n Can require several minutes...")
cat(" \n \n")
cat("## 4. Protein-protein interaction network analysis of differentially expressed proteins \n")
cat(paste0("Protein-protein interactions (PPIs) are crucial for understanding cell physiopathology. PPI analysis of differentially expressed proteins is based on the [STRING](https://string-db.org/) database. Only interactions with score > 600 are considered for building the network. Communities within the network are identified with the Clauset-Newman-Moore (CNM) algorithm. \n \n"))
cat("For a better visualization of the network, in the few cases that a contrast has 500+ DEPs, the best 500 genes are taken.")
#Reset of height of plots
if(run_enrich){knitr::opts_chunk$set(fig.height = def_val_height)}

#Select up- down- regualted genes, if 0 genes are find, the all network analysis is skipped
g_sel_comp<-list()
doComp<-list()
for (comp in unique(deps_l_df$comp)){
  tmp_deps<-deps_l_df[(deps_l_df$class != "=" & deps_l_df$comp == comp), ]
  genes<-(tmp_deps[order(tmp_deps$p_val),])[1:min(500, nrow(tmp_deps)),"id"]
  if(length(genes)>0){g_sel_comp[[comp]]<-genes}else{g_sel_comp[[comp]]<-list()}
  if(length(g_sel_comp[[comp]])!=0){doComp[comp]=TRUE}
}
if(length(doComp)==0 | all(doComp==F)){
  doNextChunk_STRING<-FALSE
  print("WARNING: Not possible to continue with the STRING network evaluation. No protein up- or down-regulated.\n")
}else{
  doNextChunk_STRING<-TRUE
  dir.create(file.path(dirOutput,subfold_Fig,subfold_net), showWarnings = FALSE)
  dirOutput_net=paste0(dirOutput,subfold_Fig,subfold_net)
}

shiny::setProgress(0.93, detail = "Network analysis done... \n Can require several minutes...")
```

```{r network_string_communities, echo=F, message=F, warning=F, eval = doNextChunk_STRING, results='hide'}
message("Build PPI network with STRING in progress... \n Can require several minutes...")

rm(cluster_ext, cmd, comm, dat_psm,df_to_save,dt_links,edge_list,el,enr_sele_df,enr_sele_names, matches, mds_cmdscale, psm_anno_df, 
       sample_data, annos, colToKeep, comp, currentTime, dirOutput_1,dirOutput_2, doNextChunk,
       f, filenames, filt_genes, g_sel, genes, l, links, lookup_words, name_list, net_genes, now, res, sample_distances, word,
       batch_annotation,comBat_df_gene, comBat_df_pep, dat_gene_long,dat_pep_long,
       gene_name, input_df, pos, prot_intensity_long, deps_vec_all, i, labels, labels_down, labels_up, list.of.packages,
       list.of.packages.bio, new.packages, prot_find, template_files)
gc()
#Read STRINGdb edges for human
#Human id --> 9606
#Mouse id --> 10090
string_db <- STRINGdb$new(version="11.5", species=taxonomy_NCBI, score_threshold=600, input_directory="")
gene_name<-unlist(g_sel_comp) %>% unique() %>% as.data.frame()
colnames(gene_name)<-c("gene_id")
string_mapped <- string_db$map(gene_name, "gene_id", removeUnmappedRows = TRUE)
links_string <- string_db$get_interactions(string_mapped$STRING_id)
links_string$from <- string_mapped$gene_id[match(links_string$from,string_mapped$STRING_id)]
links_string$to <- string_mapped$gene_id[match(links_string$to,string_mapped$STRING_id)]
string_gene_df<-data_frame("gene1"=links_string$from,"gene2"=links_string$to,"weigth"=links_string$combined_score)


if(nrow(string_gene_df) > 0){
  # cat(" \n")
  # cat("#### 5.1. Number of proteins in each communities discovered \n")
  # cat("Each image is a different contrast analysis \n")
  data_comms_df<-list()
  data_comms_list<-list()
  data_dt_links<-list()
  colour_vector<-list()
  #Cycle for each contrast
  for (comp in names(doComp)){
    # params ----
    thr_score <- 150 # define max strength of interaction

    #Select genes that are up or down regulated
    g_sel <- g_sel_comp[[comp]]
    if(all(unique(!grepl("[[:lower:]]",string_gene_df$gene1)))){
      g_sel<-toupper(g_sel)
    }else{
      g_sel<-str_to_title(g_sel)
    }
    #Find communities in STRING db
    comm <- suppressMessages(find_communities(g_sel, thr_score,string_gene_df))
    i_comms_df <- comm[["i_comms_df"]]
    data_comms_df[[comp]]<-i_comms_df
    i_comms_list <- comm[["i_comms_list"]]
    data_comms_list[[comp]]<-i_comms_list
    dt_links <- comm[["dt_links"]]
    data_dt_links[[comp]]<-dt_links

    # colour_vector[[comp]] <- c(c(brewer.pal(n = 8, name = "Dark2")), "#680000", "#ae0001", "#eb8c00", "#680000", "#001080", "#999999", "#434343")
    colour_vector[[comp]] <- c(c(brewer.pal(n = 8, name = "Dark2")), color_base)
    colour_vector[[comp]] <- colour_vector[[comp]][1:length(i_comms_list)]

    cat("\n")
  }

  i_comms_df<-data_comms_df
  i_comms_list<-data_comms_list
  dt_links<-data_dt_links

  message("Network DONE.")
}else{
  print("WARNING: No strong interaction detected beetween the proteins. Usually too few proteins.")
  doNextChunk_STRING <- FALSE
  message("Network incomplete.")
}

shiny::setProgress(0.93, detail = "Generating network figures... \n Can require several minutes...")
```

```{r network_string, echo=F, message=F, warning=F, eval = doNextChunk_STRING, fig.width=12, results='asis'}
message("Plotting STRING network in progress...")
cat("#### 4.1. Size of protein communities within PPI networks  {.tabset}  \n")
cat(" \n \n")




for (comp in names(doComp)){
  scr_thr <-  200# visual
  links <- 2
  # Filter genes and links ----
  # net_genes <- toupper(g_sel_comp[[comp]])
  net_genes <- g_sel_comp[[comp]]
  if(all(unique(!grepl("[[:lower:]]",string_gene_df$gene1)))){
      net_genes<-toupper(net_genes)
    }else{
      net_genes<-str_to_title(net_genes)
    }
  net_edges <- subset(dt_links[[comp]], from%in%net_genes & to%in%net_genes) #select genes with weight>scr_thr
  net_edges<-net_edges[which(net_edges$weight > mean(net_edges$weight)*0.7),]

  # gene_links<-table(c(net_edges$from,net_edges$to))
  # filt_genes<-names(gene_links)[which(gene_links > links)] #select genes with link > links
  # net_edges<-subset(net_edges,from %in% filt_genes & to %in% filt_genes)

  gene_links<-table(c(net_edges$from,net_edges$to))
  filt_genes<-names(gene_links)[which(gene_links >= 2)] #remove isolated genes (leaves)
  net_edges<-subset(net_edges,from %in% filt_genes & to %in% filt_genes)

  net_edges$group_to<-"PP"
  net_edges<-unique(net_edges)
  # Vertices df ----
  gene_vertices<-data.frame(label=filt_genes)
  if(nrow(gene_vertices) != 0){
    rownames(gene_vertices)<-gene_vertices$label

    gene_vertices$Community<-(i_comms_df[[comp]])[as.character(gene_vertices$label),"comm_n"] #class=communities

    nc<-ggplot(gene_vertices, aes(x=Community, fill=Community)) +
        geom_bar(alpha=0.9, colour="white", width=0.4)+
        scale_x_discrete()+
        scale_fill_manual(values=colour_vector[[comp]], drop=FALSE)+
        theme_bw(base_size = bs) +
        labs(x = "Community", y = "# genes") +
        theme(legend.position = "none", panel.grid.major.x = element_blank(),
              panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank())+
        ggtitle("Number of genes in each community", subtitle = paste0("Communities of condition: ",comp))

    cat("##### ",comp," \n")
    print(nc)
    cat(" \n \n")
    ggsave(paste0(dirOutput_net,gsub(comp, pattern = "\\/", replacement="vs"),"_communities_sizes.pdf"), nc, device=cairo_pdf, width = 4, height = 4, units = c("in"))

    write_tsv(data.frame("GeneSymbol"=gene_vertices$label, "Community"=gene_vertices$Community), 
              file = paste0(dirOutput_net,gsub(comp, pattern = "\\/", replacement="vs"),"_communities_sizes.txt"))
    
    # #BUILD NETWORK
    tb = tibble(v = c(net_edges$from, net_edges$to))
    d = as.vector(table(tb$v))
    nodes = mutate(gene_vertices, Degree = d)
    
    g <- graph_from_data_frame(net_edges, directed=TRUE, vertices=nodes)
    
    layouts <- if(length(nodes$label) > 400){c("kk")}else{c("fr","kk")}
    p = callr::r_bg(
      func = function(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts) {
        source("functions_2021.R")
        plot_networks(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts)
      },
      args = list(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts),
      stdout = "|",
      stderr = "|",
      error = getOption("callr.error", "error")
    )
    
    p$wait()
    
    cat(" \n \n")
    rm(net_genes, net_edges, gene_links, filt_genes, net_edges, gene_vertices, nc, net_net, 
           node_list_from, node_list_to, node_list, edge_list, g, name_list, l_list)
    gc()
  }
}


cat("\n \n")
message("Networking with STRING DONE")
cat("\n \n")
cat("#### 4.2. Network plots \n ")
cat("\n \n Results inside folder: *network*")
cat("\n")
cat("\n \n The network are not reported in this report since for each comparison are generated 2 figures since we use 2 layouts for the nodes. For each comparison a 2-page pdf file is created. \n \n \n ")
cat("Below is reported an example of the first comparison written in the *Design* file with layout Kamada-Kawai (KK)")
cat(" \n \n")
image_read_pdf(paste0(dirOutput_net,names(doComp)[1],"_network.pdf"), pages = 2)

message("Cleaning...")

shiny::setProgress(0.98, detail = "Network figures generated...")
```

```{r save_df, echo=F, message=F, warning=F, results='hide'}
save(list = ls(), file="tmp.RData")
if(!(eval_single_Cond)){
save(c_anno,
     dat_gene,
     dat_pep,
     psm_peptide_table,
     expr_avgse_df,
     expr_avgse_pep_df,
     formule_contrast,
     colour_vec,
     file = paste0(dirOutput,subfold_Dat,"protn_env.RData"))
}else{
save(c_anno,
     dat_gene,
     dat_pep,
     psm_peptide_table,
     deps_l_df,
     deps_pep_l_df,
     expr_avgse_df,
     expr_avgse_pep_df,
     formule_contrast,
     colour_vec,
     file = paste0(dirOutput,subfold_Dat,"protn_env.RData"))
}
remove(list = ls()[-1])
gc()

shiny::setProgress(1, detail = "Saving RData...")
```
