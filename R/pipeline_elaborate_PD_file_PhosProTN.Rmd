---
author: "Gabriele Tomè, Toma Tebaldi"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  rmdformats::readthedown:
    css: custom_theme_report.css
    df_print: paged
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: true
params:
  doc_title: "Report of integrative pipeline for phospho-proteomics analysis"
  description: NA
  readPD_files: NA
  readMQ_files: NA
  file_input_prot: NA
  file_prot_prot: NA
  file_pep_prot: NA
  file_input_phos: NA
  file_prot_phos: NA
  file_pep_phos: NA
  file_psm_phos: NA
  taxonomy: NA
  filt_absent_value: "0"
  pval_fdr: NA
  phospho_thr: "75"
  signal_thr: "inf"
  fc_thr: "0.75"
  pval_thr: "0.05"
  batch_corr_exe: NA
  contr_design: NA
  prot_boxplot: NA
  run_enrich: NA
  run_enrich_universe: NA
  run_STRING: NA
  pval_fdr_enrich: NA
  run_kinaseTree: NA
  pval_enrich_thr: "0.05"
  overlap_size_enrich_thr: 5
  enrich_filter_term: NA
  enrich_filter_DBs: NA
  enrichR_DB: NA
  dirOutput: NA
---

<!--############################################################################
# ProTN: an integrative pipeline for complete analysis of proteomics           # 
# data from mass spectrometry                                                  #
# Laboratory of RNA and Disease Data Science, University of Trento             #
# Developer: Gabriele Tomè                                                     #
# Issue at: https://github.com/TebaldiLab/ProTN/issues                         #
# PI: Dr. Toma Tebaldi, PhD                                                    #
#############################################################################-->

```{r settings, message=F, warning=F, echo=F,results='hide'}
shiny::setProgress(0, detail = "Initialize...")  # set progress to 50%

dirOutput = params$dirOutput
#Auto-install needed library
list.of.packages <- c("ggrepel","tidyr","ggraph","graphlayouts","RColorBrewer",
                      "scales","igraph","data.table","qpdf","devtools","enrichR",
                      "corrplot", "data.table", "ggplot2", "ggfortify","lazyeval",
                      "lubridate", "pheatmap", "reshape2","readr", "rlang", "rmdformats","data.tree",
                      "tibble", "dplyr", "tidyr", "wesanderson","WGCNA","ggbeeswarm","ggthemes", 
                      "magick", "pdftools", "plotly", "svgPanZoom","rsvg","shinyWidgets","colourpicker")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) suppressMessages(suppressWarnings({install.packages(new.packages, dependencies = T)}))
list.of.packages.bio <- c("biomaRt","DEqMS","STRINGdb",
                          "GO.db", "impute", "preprocessCore", "pvca","sva")
new.packages <- list.of.packages.bio[!(list.of.packages.bio %in% installed.packages()[,"Package"])]
if(length(new.packages)) {
  if (!require("BiocManager", quietly = TRUE))
      install.packages("BiocManager")
  suppressMessages(suppressWarnings({BiocManager::install(new.packages)}))
}
list.of.packages <- c("proBatch", "PhosR")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) {
  suppressMessages(suppressWarnings({devtools::install_github("symbioticMe/proBatch", dependencies = T)}))
  suppressMessages(suppressWarnings({devtools::install_github("PYangLab/PhosR", dependencies = T)}))
}

#Load functions
suppressMessages(suppressWarnings({
  source("functions_2021.R") # new functions 2021
  #Library needed
  library('biomaRt')
  library('PhosR')
  library('DEqMS')
  library(ggrepel) # graphics
  library(tidyr)
  library(dplyr)
  library(tibble)
  library(ggraph)
  library(graphlayouts)
  library(RColorBrewer) # Color palettes
  library(scales) # heatmap colors scales
  library(igraph) # Network analysis
  library(data.table)
  library(qpdf)
  library(STRINGdb)
  library("proBatch")
  library(ggbeeswarm)
  library(parallel)
  library(readr)
  library(stringi)
  library(stringr)
  library(pdftools)
  library(magick)
  library(extrafont)
  library(plotly)
}))

options(dplyr.summarise.inform = FALSE)

#Set font and size
loadfonts(quiet=T)
bs<-11      # point sizes in ggplot
bf<-"Arial" # font family in ggplot

# Color definition
color_base<-c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A","#FF7F00",
              "black", "gold1", "skyblue2", "#FB9A99", "palegreen2","#CAB2D6", "#FDBF6F",
              "#9af7c9","#c0a0e6","#f5939a","#5fefee","#e8d388","#8abdff","#e3bf7a","#48c0f6","#ccb86f","#fafeaf",
              "#04bfe4","#ea92a8","#25cfe9","#ffbb97","#62e8ff","#ffd29b","#8fcbff","#aec87f","#b2c6ff","#aedf9b",
              "#ffb3c8","#81b97c","#ffcef0","#54bcae","#ffcab3","#7dd7ff","#ffe4ad","#81b0da","#ebffc5","#a7a8d5",
              "#bdffd0","#d6d2ff","#9fb282","#a5d8ff","#c9a395","#9bfff7","#ffcbce","#70b6ca","#faffdd","#88b3bc",
              "#d6ffdf","#a3e5ff","#b1ac8f","#ccffff","#b4bb9f","#7eb7a5","#c5dbc3","#a8b9ff","#74dfbc","#f2ace7")
colour_vec<-color_base

#Variables with subdirs
subfold_Fig <- "figures/"
subfold_Dat <- "data/"
subfold_Tab <- "tables/"
subfold_MDSPCA <- "PCA_MDS/"
subfold_expr <- "Expression/"
subfold_enrich <- "Enrichment/"
subfold_net <- "Network/"

shiny::setProgress(0.01, detail = "Initialize...")  # set progress to 50%
```

```{r load_settings, warning=FALSE, echo=F, message=FALSE, results='hide'}
message("Reading options")
#Load the excel file with  the basic settings
description<-params$description
#Read Platform of previuos quantification
readPD_files <- params$readPD_files
readMQ_files <- params$readMQ_files
#Read input parameters for Limma
phospho_thr=suppressWarnings(parse_double(params$phospho_thr))
if(is.na(phospho_thr)){
  message("Warning: parse error for Phosphorilation accuracy percentage threshold. Set default paramenter to 75%\n")
  phospho_thr <- 75
}
filt_absent_value=suppressWarnings(parse_double(params$filt_absent_value))
if(is.na(filt_absent_value)){
  message("Warning: parse error for the number of acceptable missing condition. Set default paramenter to 0\n")
  filt_absent_value <- 0
}
#Read input parameters for Limma
signal_thr=suppressWarnings(parse_double(params$signal_thr))
if(is.na(signal_thr)){signal_thr<- -Inf}
fc_thr=suppressWarnings(parse_double(params$fc_thr))
if(is.na(fc_thr)){
  message("Warning: parse error for Fold Change threshold. Set default paramenter to 0.75\n")
  fc_thr <- 0.75
}
pval_thr=suppressWarnings(parse_double(params$pval_thr))
if(is.na(pval_thr)){
  message("Warning: parse error for P.Value threshold. Set default paramenter to 5%\n")
  pval_thr <- 0.05
}
batch_corr_exe<-as.logical(params$batch_corr_exe)

message(params$contr_design)
#Read the design
input_settings<-read_excel_allsheets(params$contr_design)[[1]]
contr_design<-data.frame(t(input_settings[1:nrow(input_settings),]))
contr_design<-data.frame(contr_design[,colSums(is.na(contr_design)) != nrow(contr_design) ])
if(ncol(contr_design) > 0){
  if(any(is.na(contr_design[3,]))){
    contr_design[3,]<-color_base[1:ncol(contr_design)]
  }
  contr_design<-data.frame(t(fill(contr_design, names(contr_design), .direction = "down")))
  contr_design[,2]<-unlist(lapply(contr_design[,2], function(x){ if("-" %in% x){str_replace_all(x,"-","_")}else{x}}))
  formule_contrast<-(contr_design[,1])
  names(formule_contrast)<-contr_design[,2]
  color_constrast<-contr_design[,3]
  names(color_constrast)<-contr_design[,2]

  darker.col = function(color, how.much = 50){
    colorRampPalette(c(color, "black"))(100)[how.much]
  }
  color_constrast_dark<-c()
  for(col in names(color_constrast)){
    color_constrast_dark[col]<-darker.col(color_constrast[col])
  }
  color_constrast<-cbind(color_constrast,color_constrast_dark)
}else{
  stop("Error: At least one contrast design is required for the analysis.")
}

formule_CORAL <- formule_contrast

#Read Taxonomy
taxonomy_NCBI <- params$taxonomy
if(is.na(taxonomy_NCBI)){
  message("Warning: parse error for Taxonomy ID. Set default paramenter to Homo Sapiens\n")
  taxonomy_NCBI <- 9606
} else{
  codtax <- fread("NCBI_taxID/subset_tax.csv")
  taxonomy_NCBI <- codtax[name == taxonomy_NCBI, taxid]  
}

#Read Proteins List for control boxplot
prot_boxplot<-na.omit(strsplit(params$prot_boxplot, split = "\\;|\\,|\\ |\\; |\\, ")[[1]])
boxplot_prot_exe <- FALSE
if(length(prot_boxplot)>0){ boxplot_prot_exe<-TRUE }
#Read enrich parameter
doNextChunk_STRING <- doNextChunk <- run_enrich <- run_STRING <- run_enrich_universe <- run_kinaseTree <- pval_fdr <- enrichR_DB <- FALSE
pval_fdr_enrich <- TRUE
pval_fdr <- as.logical(params$pval_fdr)
pval_fdr_enrich <- as.logical(params$pval_fdr_enrich)
run_enrich <- as.logical(params$run_enrich)
run_enrich_universe <- as.logical(params$run_enrich_universe)
enrichR_DB <- as.logical(params$enrichR_DB)
run_STRING <- as.logical(params$run_STRING)
run_kinaseTree <- as.logical(params$run_kinaseTree)
pval_enrich_thr <- if(is.null(params$pval_enrich_thr)){0.05
                   }else if(is.double(params$pval_enrich_thr)){params$pval_enrich_thr
                   }else{parse_double(params$pval_enrich_thr)}
if(is.na(pval_enrich_thr)){
  message("Warning: parse error for p-value enrichment threshold. Set default paramenter to 0.05\n")
  pval_enrich_thr <- 0.05
}
overlap_size_enrich_thr=if(is.null(params$overlap_size_enrich_thr)){5
                         }else if(is.integer(params$overlap_size_enrich_thr)){params$overlap_size_enrich_thr
                         }else{parse_double(params$overlap_size_enrich_thr)}
if(is.na(overlap_size_enrich_thr)){
  message("Warning: parse error for Overlap size enrichment threshold. Set default paramenter to 5\n")
  overlap_size_enrich_thr <- 5
}
enrich_filter_term<-if(is.null(params$enrich_filter_term)){list()
}else if(params$enrich_filter_term == ""){list()
}else{na.omit(strsplit(params$enrich_filter_term, split = "\\;|\\,|\\; |\\, ")[[1]])}
enrich_filter_DBs<-if(is.null(params$enrich_filter_DBs)){list()
}else if(is.character(params$enrich_filter_DBs)){ na.omit(params$enrich_filter_DBs)
}else{list()}

remove(input_settings,contr_design,color_constrast_dark)
shiny::setProgress(0.05, detail = "Reading setting...")  # set progress to 50%
```

---
title: `r if(params$doc_title==""){"Report of integrative pipeline for phospho-proteomics analysis"}else{params$doc_title}`
---

`r description`

The following report summarizes the results obtained by the PhosProTN integrative pipeline for phospho-proteomics analysis. Full results can be found in the output folder.

```{r print_readme, warning=FALSE, echo=F, message=FALSE}

text_readme<- c("Description of the output files")

text_readme<- c(text_readme, "- **Data**",
"  - ```phosProTN_env_R.RData```: RData object containing the essential variables and data for additional analyses in R. The variables are:",
"    - *c_anno_phos*: dataframe with the description of the samples of the phosphoproteomic;",
"    - *c_anno*: dataframe with the description of the samples of the proteomic;",
"    - *color_constrast*: plot color of the comparison;",
"    - *dat_pep*: dataframe with the peptide normalized abundances of the phosphoproteomic;",
"    - *dat_complete*: dataframe with the peptide normalized abundances, of the phosphoproteomic merged with the proteomic protein;",
"    - *psm_peptide_table*: descriptive dataframe of the peptides;",
"    - *deps_pep_l_df*: dataframe of differential expressed peptides;",
"    - *expr_avgse_pep_df*: dataframe with average, standard error and covariance for each condition based on peptide abundances;",
"    - *expr_avgse_complete_df*: dataframe with average, standard error and covariance for each condition based on the merged peptides;",
"    - *formule_CORAL*: design for the differential analysis;",
"    - Settings: *colour_vec*: color list for the plot, *bf*: family text, *bs*: base text size; ",
"    - Thresholds: *fc_thr*: Fold Change threshold, *pval_thr*: P.value threshold, *pval_enrich_thr*: P.value threshold for Enrichment, *overlap_size_enrich_thr*: Overlap size threshold for enrichment.")

if(run_enrich){ text_readme<- c(text_readme, "  - ```enrichment_DE.RData```: RData object containing enrichment results based on differentially expressed proteins \n")}
if(run_enrich_universe){ text_readme<- c(text_readme, "  - ```enrichment_allproteins.RData```: RData object containing enrichment results based on all detected proteins \n")}


text_readme<- c(text_readme, "- **Tables**",
"  - ```normalised_abundances.xlsx```: excel file containing abundance values generated by proTN. abundances are log2 transformed, normalized, imputed (and batch corrected). The file is organized in the following sheets:",
"    - **protein_per_sample**: protein abundances per sample.",
"    - **peptide_per_sample**: peptide abundances per sample.",
"    - **protein_per_condition**: protein abundances per condition (average & standard deviation), as defined in the Sample Annotation.",
"    - **peptide_per_condition**: peptide abundances per condition (average & standard deviation), as defined in the Sample Annotation.",
"  - ```differential_expression.xlsx```: excel file containing the results of differential analysis, according to the contrasts defined in the Design file. The file is organized in the following sheets:",
"    - **protein_DE**: protein differential expression results protein abundances per sample.",
"    - **peptide_DE**: peptide differential expression results.",
"    Annotation columns:",
"    - **Accession**: protein UniprotID",
"    - **Description**: protein description",
"    - **GeneName**: Gene Symbol",
"    - **Peptide_Sequence**: peptide sequence",
"    - **Peptide_Modifications**: peptide modifications",
"    - **Peptide_Position**: start and end position of the peptide within the protein sequence, defined UniprotID",
"    - **Peptide_Tryptic**: peptide tryptic digestion status (fully tryptic, N-semi tryptic, C-semi tryptic, non tryptic)",
"    - Columns for each contrast:",
"    - **class**: defined according to the fold change, p-value and abundance thresholds specified in the input",
"      - *+* up-regulated protein/peptide",
"      - *-* down-regulated protein/peptide",
"      - *=* invariant protein/peptide",
"    - **log2_FC**: protein/peptide log2 transformed fold change",
"    - **p_val**: protein/peptide contrast p-value",
"    - **p_adj**: protein/peptide adjusted p-value (FDR after BH correction)",
"    - **log2_expr**: protein/peptide log2 average abundance")

if(run_enrich){ text_readme<- c(text_readme, "  - ```enrichment_DE.xlsx```: excel file containing a selection of enrichment results starting from differentially expressed proteins. Terms are selected according to significance thresholds specified in the input (Default: adj.P.Value < 0.05, Overlap Size >= 5) \n")}
if(run_enrich_universe){ text_readme<- c(text_readme, "  - ```enrichment_allproteins.xlsx```: excel file containing a selection of enrichment results starting from all the detected proteins. Terms are selected according to significance thresholds specified in the input (Default: adj.P.Value < 0.05, Overlap Size >= 5) \n")}

text_readme<- c(text_readme, "- **Figures**",
"  - ```PCA_MDS``` directory: Directory containing (Multidimensional scaling) and PCA (Principal component analysis) plots of samples.",
"    - **mds_proteins.pdf**: MDS, based on protein abundances.",
"    - **mds_peptides.pdf**: MDS of the samples by peptides.",
"    - **pca_protein.pdf**: PCA of the samples by proteins.",
"    - **pca_peptides.pdf**: PCA of the samples by peptides.",
"    - **DE_mds_protein.pdf**: MDS based on differentially expressed proteins.",
"    - **DE_mds_peptide.pdf**: MDS based on differentially expressed peptides.",
"    - **DE_pca_protein.pdf**: PCA based on differentially expressed proteins.",
"    - **DE_pca_peptide.pdf**: PCA based on differentially expressed peptides.")

text_readme<- c(text_readme, "  - ```Expression``` directory: Directory containing figures related to expression analyses.")

if(boxplot_prot_exe){text_readme<- c(text_readme, "    - **selected_protein_plot.pdf**: plot displaying the abundances of selected proteins \n")}

text_readme<- c(text_readme, "    - **DE_protein_barplot.pdf**: number of differentially expressed proteins found in each contrast.")
text_readme<- c(text_readme, "    - **DE_peptide_barplot.pdf**: number of differentially expressed peptides found in each contrast.")

if(run_enrich){
text_readme<- c(text_readme, "  - ```Enrichment``` directory: Directory containing figures from functional annotation enrichment analysi \n")  
}

if(run_enrich&(!run_enrich_universe)){
text_readme<- c(text_readme, "    - **enr_updown_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins, divided in up- and down-regulated. Terms are filtered for key source datasets selected in the advanced options. \n")
text_readme<- c(text_readme, "    - **enr_updown_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins, divided in up- and down-regulated. Terms are filtered for keywords defined in the advanced options. \n")
text_readme<- c(text_readme, "    - **enr_DE_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins. Terms are filtered for key source datasets selected in the advanced options. \n")
text_readme<- c(text_readme, "    - **enr_DE_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins. Terms are filtered for keywords defined in the advanced options. \n")
}

if(run_enrich_universe){
text_readme<- c(text_readme, "      - **enr_updown_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins, divided in up- and down-regulated. Terms are filtered for key source datasets selected in the advanced options. \n")
text_readme<- c(text_readme, "      - **enr_updown_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins, divided in up- and down-regulated. Terms are filtered for keywords defined in the advanced options. \n")
text_readme<- c(text_readme, "    - **enr_DE_keysources.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins. Terms are filtered for key datasets selected in the advanced options. \n")
text_readme<- c(text_readme, "    - **enr_DE_keywords.pdf**: dot plot of top enriched terms based on differentially expressed proteins compared to all detected proteins. Terms are filtered for keywords defined in the advanced options. \n")
}

if(run_STRING){
text_readme<- c(text_readme, "  - ```Network``` directory: Directory with figures from network analysis of differentially expressed proteins, based on STRINGdb protein-protein interactions. For each contrast, two files are generated: \n")
text_readme<- c(text_readme, "    - **communities_sizes.pdf**: histogram representing the number of protein in each network community. \n")
text_readme<- c(text_readme, "    - **ppi_network.pdf**: network representation in two layouts: Fruchterman Reingold (*fr*) and Kamada Kawai (*kk*). \n")
}

if(run_kinaseTree){
text_readme<- c(text_readme, "  - ```KinaseTree``` directory: Kinase tree generated with CORAL in svg and associated txt file with the activity of each kinase. \n")
}

write(text_readme, file = paste0(dirOutput,"README.txt"))

```


## Summary of input parameters and thresholds

```{r print_settings, warning=FALSE, echo=F, message=FALSE, results='asis'}
cat(" \n \n")
#Print summary of filter and contrast design
if(readPD_files){
  cat("**Source files:** Proteome Discoverer")
  cat(" \n")
} else{
  cat("**Source files:** MaxQuant")
  cat(" \n")
}
cat(" \n \n")
if(batch_corr_exe){
  cat("**Pipeline** \n ")
  cat(" \n")
  cat("- Execution of batch effect correction.")
}
cat(" \n \n ")
cat("**Differential expression** \n ")
cat(" \n")
cat(paste0("- Fold Change threshold: log2_FC > ",fc_thr," (+), log2_FC < -",fc_thr," (-) "))
cat(" \n")
cat(paste0("- Statistical significance threshold: p.val < ",pval_thr," "))
cat(" \n")
if(signal_thr != -Inf){cat(paste0("- Signal log2 intesity threshold: signal > ",signal_thr," "))}
cat(" \n")
if(filt_absent_value != 0){cat(paste0("- Threshold of acceptable missing values for condition = ",filt_absent_value," "))}
cat(" \n \n ")
if(run_enrich){
  cat("**Enrichment analysis** \n ")
cat(" \n")
  cat(paste0("- Statistical significance threshold: p.val < ",pval_enrich_thr," "))
cat(" \n")
  cat(paste0("- Overlap size threshold for enrichment analysis: OverlapSize > ",overlap_size_enrich_thr," "))
cat(" \n")
  if(run_enrich_universe){cat("- Execution of the enrichment also on all detected proteins.")}
  cat(" \n \n ")
}
cat(" \n \n ")
if(run_STRING){
  cat("**Network analysis** \n ")
cat(" \n")
  cat("- Execution of PPI network analysis with STRINGdb.")
}
cat(" \n \n ")
cat("**Phosphorylation analysis** \n ")
cat(" \n \n ")
cat(paste0("- Phosphorilation accuracy percentage threshold: phos_% > ",phospho_thr,"% "))
cat(" \n \n")
if(run_kinaseTree){cat("- Execution of Kinase Tree activation analysis with PhosR and CORAL.")}

shiny::setProgress(0.18, detail = "Reading files...")
```

```{r load_data_from_PD, eval=readPD_files,echo=F, message=F, warning=F, results='asis'}
message("Reading files from MS...")
read_input_files<-function(type, filenames){
  #Read all files in the input folder
  if(type=="PROT"){template_files=c("Input","pep","prot")}else{template_files=c("Input","pep","prot","psm")}
  input_files<-list("FILES")
  for (f in template_files){
    input_files[f] <- tryCatch({
      read_excel_allsheets(filenames[f][[1]])
    }, error=function(cond){
      stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
    })
  }
  if(type=="PROT"){names(input_files)<-c("dir","Input","PEP","PROT")}else{names(input_files)<-c("dir","Input","PEP","PROT","PSM")}
  message("Data acquired")
  
  #Clean files and merge
  colToKeep<-intersect(colnames(input_files$Input), c("File ID","File Name","Condition","Color","Sample","MS_batch"))
  input_files$Input <- input_files$Input[,colToKeep]
  if(!("Condition" %in% colnames(input_files$Input))){ stop("Error: \'Condition\' column missin in \'Input\' file.") }
  if(batch_corr_exe & !("MS_batch" %in% colnames(input_files$Input))){ stop("Error: \'MS_batch\' column missin in \'Input\' file with batch correction activated") }
  
  if(type == "PROT"){
    input_files$Input$Condition <- str_c(input_files$Input$Condition, "_i")
  } else{
    input_files$Input$Condition <- str_c(input_files$Input$Condition, "_p")
  }
  
  input_files$Input$`File Name`<- lapply(input_files$Input$`File Name`,
                                         function(x){tail(unlist(strsplit(x,"\\",fixed=T)),n=1)})
  
  input_files$Input$`File Name`<-mf(unlist(input_files$Input$`File Name`),"_")
  if(any(str_starts(input_files$Input$Condition, "[0-9]"))){
    name<-names(formule_contrast)
    formule_contrast <- lapply(unique(input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))]), 
                               function(x){
                                 str_replace_all(formule_contrast,
                                                 x,
                                                 str_c("X.", x))
                               })[[1]]
    names(formule_contrast) <- name
    input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))] <- str_c("X.",
                                                                                             input_files$Input$Condition[
                                                                                               (str_starts(input_files$Input$Condition, "[0-9]"))])
  }
  #Prepare PROT table with only column Accession and Dscription, extract fro Description the GeneName and remove contaminants
  if(is_empty(which(grepl("Keratin|keratin",input_files$PROT$Description) |
                    grepl("CON_",input_files$PROT$Accession)))){
    input_files$PROT <- na.omit(input_files$PROT[,c("Accession","Description")])
  }else{
    input_files$PROT <- na.omit(input_files$PROT[-which(grepl("Keratin|keratin",input_files$PROT$Description) |
                                                          grepl("CON_",input_files$PROT$Accession))
                                                 ,c("Accession","Description")])
  }
  input_files$PROT$GeneName<-lapply(input_files$PROT$Description, function(x){gsub(".*GN=(.+) PE=.*", "\\1", x)}) %>% unlist()
  # taxonomy_NCBI<-lapply(input_files$PROT$Description, function(x){gsub(".*OX=(.+) GN=.*", "\\1", x)}) %>% unlist()
  # taxonomy_NCBI<-strtoi(names(sort(table(taxonomy_NCBI), decreasing = T))[1])
  #Mantain only the first UNIPROT code
  input_files$PEP$`Master Protein Accessions`<-lapply(input_files$PEP$`Master Protein Accessions`,
                                                      function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()
  #Filter PHOS taking only phospho modifications
  if(type == "PHOS"){
    input_files$PEP <- input_files$PEP[grepl("Phospho",input_files$PEP$Modifications),]
    #Verify if the Abundance start in 5 column in PEP table, if not remove extra column
    if(!grepl("Abundance",colnames(input_files$PEP)[5])){
      input_files$PEP<-input_files$PEP[,c(colnames(input_files$PEP)[grepl(paste("Annotated Sequence",
                                                                                "Modifications",
                                                                                "Master Protein Accessions",
                                                                                "Positions in Master Proteins", sep = "|"), 
                                                                          colnames(input_files$PEP))],
                                          colnames(input_files$PEP)[which(grepl("Abundance",colnames(input_files$PEP)))])]
    }
    
    #Modify seqeunce to detect only active phosphosite
    pattern_sub <- lapply(str_extract_all(input_files$PEP$`Modifications in Master Proteins`, "\\(\\d+\\.\\d+|\\(\\d+"), 
                          function(x){(unlist(str_remove_all(unlist(x), "\\(")))})
    replacement <- lapply(str_extract_all(input_files$PEP$`Modifications in Master Proteins`, "\\(\\d+\\.\\d+|\\(\\d+"), 
                          function(x){as.integer(as.double(unlist(str_remove_all(unlist(x), "\\("))) > phospho_thr)})
    input_files$PEP$modif <- lapply(1:length(input_files$PEP$`Modifications in Master Proteins`), 
                                    function(x){
                                      stri_replace_all_regex(input_files$PEP$`Modifications in Master Proteins`[x], 
                                                             pattern_sub[[x]],
                                                             as.character(replacement[[x]]),
                                                             vectorize_all = F)}) %>% unlist()
    input_files$PEP$modif <- paste(input_files$PEP$`Master Protein Accessions`, input_files$PEP$modif, input_files$PEP$`Annotated Sequence`, sep="_")
    PEP_collapse <- input_files$PEP[,c(which(grepl("Abundance",colnames(input_files$PEP))), ncol(input_files$PEP))]
    PEP_collapse <- PEP_collapse %>% group_by(modif) %>% summarize_all(funs(sum(., na.rm = T))) 
    PEP_collapse <- right_join(input_files$PEP[,c("Annotated Sequence",
                                                  "Modifications in Master Proteins",
                                                  "Master Protein Accessions",
                                                  "Positions in Master Proteins",
                                                  "modif")], PEP_collapse, by ="modif")
    PEP_collapse <- PEP_collapse[!duplicated(PEP_collapse$modif),]
    #merge by uniprot the prot description and the pep table
    uniprot_to_take<-merge(input_files$PROT, PEP_collapse, by.x = "Accession", by.y = "Master Protein Accessions")
    input_files$PD_PEP_matrix<-merge(input_files$PROT[which(input_files$PROT$Accession %in% uniprot_to_take$Accession),],
                                     PEP_collapse, by.x = "Accession", by.y = "Master Protein Accessions")
    input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,c(colnames(input_files$PD_PEP_matrix)[grepl(paste(
      "Accession",
      "Description",
      "GeneName",
      "Annotated Sequence",
      "Modifications",
      "Positions in Master Proteins",
      "modif", sep = "|"), 
      colnames(input_files$PD_PEP_matrix))],
      lapply(input_files$Input$`File ID`, function(x){
        colnames(input_files$PD_PEP_matrix)[grepl(str_c(x,":"), colnames(input_files$PD_PEP_matrix))]
      }) %>% unlist())]
    if("TRUE" %in% grepl("\\.", colnames(input_files$PD_PEP_matrix))){
      input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,-which(colnames(input_files$PD_PEP_matrix) %in%
                                                                     c(colnames(input_files$PD_PEP_matrix)[grepl("\\.",
                                                                                                                 colnames(input_files$PD_PEP_matrix))]))]
    }
    colnames(input_files$PD_PEP_matrix)<-c(colnames(input_files$PD_PEP_matrix)[grepl(paste(
      "Accession",
      "Description",
      "GeneName",
      "Annotated Sequence",
      "Modifications",
      "Positions in Master Proteins",
      "modif", sep = "|"), 
      colnames(input_files$PD_PEP_matrix))],
      unlist(lapply(colnames(input_files$PD_PEP_matrix), function(x){
        lapply(input_files$Input$`File ID`, function(y){if(str_detect(x,paste0(y,":"))){
          input_files$Input$`File Name`[which(input_files$Input$`File ID` %in% y)]
        }})
      })))
    input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1]
    #Maintain only the new complete matrix of intensity
    psm_sig_raw<-as.data.frame(input_files$PD_PEP_matrix)
    c_anno<-input_files$Input
    if(!("Sample" %in% colnames(c_anno))){
      colnames(c_anno)[2]<-"sample"
    }else{
      colnames(psm_sig_raw)<-c(c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins","modif"),
                               c_anno$Sample)
    }
    colnames(c_anno)<-tolower(colnames(c_anno))
    
    rownames(c_anno)<-c_anno$sample
    if("color" %in% colnames(c_anno)){
      colour_vec<-na.omit(c_anno[colnames(psm_sig_raw),]$color)
      names(colour_vec)<-na.omit(c_anno[colnames(psm_sig_raw),]$sample)
    } else{
      c_anno<-left_join(c_anno,
                        data.frame("color"=colour_vec[match(sort(c_anno$condition),unique(sort(c_anno$condition)))],
                                   "sample"=c_anno[order(c_anno$condition), "sample"]))
    }
    
    # READ PSM
    # PSM ANALYSIS
    #Read PSM and manage the Phospho Percentage
    input_files[["PSM"]] <- input_files[["PSM"]][-which(input_files[["PSM"]]$`Annotated Sequence` %in% input_files[["PD_PEP_matrix"]]$`Annotated Sequence` |
                                                          !grepl(pattern = "Phospho", input_files[["PSM"]]$`ptmRS: Best Site Probabilities`) |
                                                          (is.na(input_files[["PSM"]]$`Precursor Abundance`))),]
    input_files[["PSM"]] <- input_files[["PSM"]][unlist(lapply(str_extract_all(input_files[["PSM"]]$`ptmRS: Best Site Probabilities`,
                                                                               "\\: \\d+\\.\\d+\\b|\\: \\d+\\b"),
                                                               function(x){any(as.double(unlist(str_remove_all(unlist(x), "\\: "))) > phospho_thr)})),]
    
    #Mantain only the first UNIPROT code
    input_files$PSM$`Master Protein Accessions`<-lapply(input_files$PSM$`Master Protein Accessions`,
                                                        function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()
    
    #Modify sequence to detect only the phosphorilated sites
    pattern_sub <- lapply(str_extract_all(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\: \\d+\\.\\d+\\b|\\: \\d+\\b"),
                          function(x){(unlist(str_remove_all(unlist(x), "\\: ")))})
    replacement <- lapply(str_extract_all(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\: \\d+\\.\\d+\\b|\\: \\d+\\b"),
                          function(x){as.integer(as.double(unlist(str_remove_all(unlist(x), "\\: "))) > phospho_thr)})
    input_files$PSM$modif <- lapply(1:length(input_files$PSM$`ptmRS: Best Site Probabilities`),
                                    function(x){
                                      stri_replace_all_regex(input_files$PSM$`ptmRS: Best Site Probabilities`[x],
                                                             pattern_sub[[x]],
                                                             as.character(replacement[[x]]),
                                                             vectorize_all = F)}) %>% unlist()
    input_files$PSM$`Annotated Sequence` <- str_to_upper(input_files$PSM$`Annotated Sequence`)
    
    id_pep_doubt <- psm_sig_raw[stri_detect_regex(psm_sig_raw$Modifications,"\\/"),c(1:7)]
    
    pattern<-input_files$PSM[,c("Annotated Sequence","Master Protein Accessions", "modif")] %>% filter(`Annotated Sequence` %in% id_pep_doubt$`Annotated Sequence` &
                                                                                                         `Master Protein Accessions` %in% id_pep_doubt$Accession)
    
    pattern$modif_split <- lapply(stri_split_regex(pattern$modif, ";"), 
                                  function(x){stri_c(unlist(lapply(stri_extract_all_regex(str_remove_all(x, "\\ "), "^.|.$"), 
                                                                   function(y){y[y[2] != "0"]})), collapse = "")}) %>% unlist()
    
    pattern2 <- left_join(pattern, id_pep_doubt, by = c("Annotated Sequence" = "Annotated Sequence", "Master Protein Accessions" = "Accession"))
    pattern2$phospo_PEP <- lapply(stri_extract_all_regex(pattern2$modif.y, "\\w\\d+\\(1"), 
                                  function(x){stri_c(unlist(stri_extract_all_regex(x, "^.|.$")), collapse = "")}) %>% unlist()
    #Chance doubt phosphosite with the most probable
    for(ids in unique(pattern2$modif.y)){
      test<-pattern2[(pattern2$modif.y == ids) & !(pattern2$modif_split == pattern2$phospo_PEP),]
      if(nrow(test) > 0){
        test$doubtSite<-lapply(1:nrow(test), function(x){str_remove(test$modif_split[x], test$phospo_PEP[x])})
        table_site <- table(unlist(test$doubtSite))
        site_to_take <- stri_extract_all_regex(names(table_site[which(table_site == max(table_site))])[1], "^.")[[1]]
        psm_sig_raw$Modifications[which(psm_sig_raw$modif == test$modif.y[1])]<- stri_replace_all_regex(test$modif.y[1], "\\w\\/\\w\\/\\w|\\w\\/\\w",paste0(site_to_take,"(1)"))
        psm_sig_raw$modif[which(psm_sig_raw$modif == test$modif.y[1])]<- stri_replace_all_regex(test$modif.y[1], "\\w\\/\\w\\/\\w|\\w\\/\\w",paste0(site_to_take,"(1)"))
      } else{
        table_site <- table(unlist(unique(pattern2$phospo_PEP[which(pattern2$modif.y == ids)])))
        site_to_take <- stri_extract_all_regex(names(table_site[which(table_site == max(table_site))])[1], "^.")[[1]]
        psm_sig_raw$Modifications[which(psm_sig_raw$modif == ids)]<- stri_replace_all_regex(ids, "\\w\\/\\w\\/\\w|\\w\\/\\w",paste0(site_to_take,"(1)"))      
        psm_sig_raw$modif[which(psm_sig_raw$modif == ids)]<- stri_replace_all_regex(ids, "\\w\\/\\w\\/\\w|\\w\\/\\w",paste0(site_to_take,"(1)"))
      }
    }
    input_files$PEP_info <- as.data.frame(unique(psm_sig_raw[, c("Accession","Description","GeneName","Annotated Sequence",
                                                                 "Modifications","Position in Master Proteins", "modif")]))
    colnames(input_files$PEP_info) <- c("Accession","Description","GeneName", "Annotated Sequence","Modifications", "Position in Master Proteins", "modif")
    rownames(input_files$PEP_info) <- input_files$PEP_info$ID_peptide
    rownames(psm_sig_raw) <- make.names(psm_sig_raw$modif, unique = T)
    psm_sig_raw <- psm_sig_raw[,-which(colnames(psm_sig_raw) 
                                       %in% 
                                         c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins", "modif"))]
  } else{
    #Verify if the Abundance start in 5 column in PEP table, if not remove extra column
    if(!grepl("Abundance",colnames(input_files$PEP)[5])){
      input_files$PEP<-input_files$PEP[,c(colnames(input_files$PEP)[grepl(paste("Annotated Sequence",
                                                                                "Modifications",
                                                                                "Master Protein Accessions",
                                                                                "Positions in Master Proteins", sep = "|"), 
                                                                          colnames(input_files$PEP))],
                                          colnames(input_files$PEP)[which(grepl("Abundance",colnames(input_files$PEP)))])]
    }
    input_files$PEP <- input_files$PEP %>% group_by(`Annotated Sequence` ,`Modifications in Master Proteins`,`Master Protein Accessions`,`Positions in Master Proteins`) %>% summarize_all(funs(sum(., na.rm = T))) 
    
    #merge by uniprot the prot description and the pep table
    uniprot_to_take<-merge(input_files$PROT, input_files$PEP, by.x = "Accession", by.y = "Master Protein Accessions")
    input_files$PD_PEP_matrix<-merge(input_files$PROT[which(input_files$PROT$Accession %in% uniprot_to_take$Accession),],
                                     input_files$PEP, by.x = "Accession", by.y = "Master Protein Accessions")
    input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,c(colnames(input_files$PD_PEP_matrix)[grepl(paste(
      "Accession",
      "Description",
      "GeneName",
      "Annotated Sequence",
      "Modifications",
      "Positions in Master Proteins", sep = "|"), 
      colnames(input_files$PD_PEP_matrix))],
      lapply(input_files$Input$`File ID`, function(x){
        colnames(input_files$PD_PEP_matrix)[grepl(str_c(x,":"), colnames(input_files$PD_PEP_matrix))]
      }) %>% unlist())]
    if("TRUE" %in% grepl("\\.", colnames(input_files$PD_PEP_matrix))){
      input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,-which(colnames(input_files$PD_PEP_matrix) %in%
                                                                     c(colnames(input_files$PD_PEP_matrix)[grepl("\\.",
                                                                                                                 colnames(input_files$PD_PEP_matrix))]))]
    }
    colnames(input_files$PD_PEP_matrix)<-c(colnames(input_files$PD_PEP_matrix)[grepl(paste(
      "Accession",
      "Description",
      "GeneName",
      "Annotated Sequence",
      "Modifications",
      "Positions in Master Proteins", sep = "|"), 
      colnames(input_files$PD_PEP_matrix))],
      unlist(lapply(colnames(input_files$PD_PEP_matrix), function(x){
        lapply(input_files$Input$`File ID`, function(y){if(str_detect(x,paste0(y,":"))){
          input_files$Input$`File Name`[which(input_files$Input$`File ID` %in% y)]
        }})
      })))
    input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1]
    #Maintain only the new complete matrix of intensity
    psm_sig_raw<-as.data.frame(input_files$PD_PEP_matrix)
    c_anno<-input_files$Input
    if(!("Sample" %in% colnames(c_anno))){
      colnames(c_anno)[2]<-"sample"
    }else{
      colnames(psm_sig_raw)<-c(c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins"),
                               c_anno$Sample)
    }
    colnames(c_anno)<-tolower(colnames(c_anno))
    
    rownames(c_anno)<-c_anno$sample
    if("color" %in% colnames(c_anno)){
      colour_vec<-na.omit(c_anno[colnames(psm_sig_raw),]$color)
      names(colour_vec)<-na.omit(c_anno[colnames(psm_sig_raw),]$sample)
    } else{
      c_anno<-left_join(c_anno,
                        data.frame("color"=colour_vec[match(sort(c_anno$condition),unique(sort(c_anno$condition)))],
                                   "sample"=c_anno[order(c_anno$condition), "sample"]))
    }
    
    input_files$PEP_info <- as.data.frame(unique(psm_sig_raw[, c("Accession","Description","GeneName","Annotated Sequence",
                                                                 "Modifications","Position in Master Proteins")]))
    colnames(input_files$PEP_info) <- c("Accession","Description","GeneName", "Annotated Sequence","Modifications", "Position in Master Proteins")
    rownames(input_files$PEP_info) <- paste(input_files$PEP_info$Accession, input_files$PEP_info$Modifications, input_files$PEP_info$`Annotated Sequence`, sep = "_")
    rownames(psm_sig_raw) <- make.names(paste(psm_sig_raw$Accession, psm_sig_raw$Modifications, psm_sig_raw$`Annotated Sequence`, sep="_"), unique = T)
    psm_sig_raw <- psm_sig_raw[,-which(colnames(psm_sig_raw) 
                                       %in% 
                                         c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins"))]
  }
  
  psm_peptide_table<-input_files$PEP_info
  
  remove(uniprot_to_take,input_files)
  return(list("psm_sig_raw" = psm_sig_raw,
              "psm_peptide_table" = psm_peptide_table,
              "c_anno" = c_anno,
              "colour_vec" = colour_vec,
              "formule_contrast" = formule_contrast))
}

filenames <- list("Input"=params$file_input_prot,"prot"=params$file_prot_prot,"pep"=params$file_pep_prot)
res <- read_input_files("PROT", filenames)
psm_sig_raw_prot<-res$psm_sig_raw
psm_peptide_table_prot <- res$psm_peptide_table
c_anno_prot<-res$c_anno
rownames(c_anno_prot)<-c_anno_prot$sample
colour_vec<-res$colour_vec
formule_contrast<-res$formule_contrast

filenames <- list("Input"=params$file_input_phos,"prot"=params$file_prot_phos,"pep"=params$file_pep_phos,"psm"=params$file_psm_phos)
res <- read_input_files("PHOS", filenames)
psm_sig_raw_phos<-res$psm_sig_raw
c_anno_phos<-res$c_anno
rownames(c_anno_phos)<-c_anno_phos$sample
psm_peptide_table_phos <- res$psm_peptide_table


cat("#### Phosho-proteome samples \n ")
kable(c_anno_phos[setdiff(colnames(c_anno_phos), c("color","Color"))], row.names = F)
cat("#### Proteome samples \n ")
kable(c_anno_prot[setdiff(colnames(c_anno_prot), c("color","Color"))], row.names = F)

remove(filenames, res)
shiny::setProgress(0.23, detail = "Files correctly read...")
```

```{r load_data_from_MQ, eval=readMQ_files,echo=F, message=F, warning=F, results='asis'}
message("Reading files from MS...")
read_input_files<-function(type, filenames){
  #Read all files in the input folder
  template_files=c("Input","pep")
  input_files<-list("FILES"="in_files")
  for (f in template_files){
    if(f == template_files[1]){
      input_files[f] <- tryCatch({
        read_excel_allsheets(filenames[f][[1]])
      }, error=function(cond){
        stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
      })
    }else{
      input_files[f] <- tryCatch({
        list(read_tsv(filenames[f][[1]]))
      }, error=function(cond){
        stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
      })
    }
  }
  names(input_files)<-c("dir","Input","PEP")
  message("Data acquired")
  
  #Clean files and merge
  colToKeep<-intersect(colnames(input_files$Input), c("Condition","Color","Sample","Filename"))
  input_files$Input <- input_files$Input[,colToKeep]
  if(!("Condition" %in% colnames(input_files$Input))){ stop("Error: \'Condition\' column missin in \'Input\' file.") }
  if(!("Filename" %in% colnames(input_files$Input))){ 
    input_files$Input$Filename<-input_files$Input$Sample 
    message("Filename not found. Use Sample column as Filename. Can occur problem in reading the Evidence file.")
  }
  if(batch_corr_exe & !("MS_batch" %in% colnames(input_files$Input))){ stop("Error: \'MS_batch\' column missin in \'Input\' file with batch correction activated") }
  
  if(type == "PROT"){
    input_files$Input$Condition <- str_c(input_files$Input$Condition, "_i")
  } else{
    input_files$Input$Condition <- str_c(input_files$Input$Condition, "_p")
  }
  
  if(any(str_starts(input_files$Input$Condition, "[0-9]"))){
    name<-names(formule_contrast)
    formule_contrast <- lapply(unique(input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))]), 
                               function(x){
                                 str_replace_all(formule_contrast,
                                                 x,
                                                 str_c("X.", x))
                               })[[1]]
    names(formule_contrast) <- name
    input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))] <- str_c("X.",
                                                                                             input_files$Input$Condition[(str_starts(input_files$Input$Condition,
                                                                                                                                     "[0-9]"))])
  }
  #Prepare PROT table with only column Accession and Dscription, extract fro Description the GeneName and remove contaminants
  # taxonomy_NCBI<-lapply(input_files$PEP$`Protein names`, function(x){gsub(".*OX=(.+) GN=.*", "\\1", x)}) %>% unlist()
  # taxonomy_NCBI<-strtoi(names(sort(table(taxonomy_NCBI), decreasing = T))[1])
  # if(is.na(taxonomy_NCBI)){
  #   taxonomy_NCBI<-9606
  # }
  # 
  # #Cast genename to all upper for human and as title for mouse
  # if(taxonomy_NCBI == 9606){
  #   input_files$PEP$`Gene names` <- str_to_upper(input_files$PEP$`Gene names`)
  # } else {
  #   input_files$PEP$`Gene names` <- str_to_title(input_files$PEP$`Gene names`)
  # }
  
  input_files$PEP <- input_files$PEP[-which(grepl("Keratin|keratin",input_files$PEP$`Protein names`) |
                                              grepl("CON_",input_files$PEP$`Leading razor protein`) |
                                              is.na(input_files$PEP$`Protein names`) |
                                              is.na(input_files$PEP$`Gene names`) |
                                              !(input_files$PEP$`Raw file` %in% input_files$Input$Filename) |
                                              (input_files$PEP$Type == "MSMS")),]
  if(type == "PHOS"){
    input_files$PEP <- input_files$PEP[grepl(x = input_files$PEP$Modifications, pattern = "Phospho|phospho"),]
    #Remove phosphorylation with low score
    input_files$PEP <- input_files$PEP[unlist(lapply(str_extract_all(input_files$PEP$`Phospho (STY) Probabilities`, "1|(0\\.\\d+)"),
                                                     function(x){any(as.double(unlist(x)) > (phospho_thr/100))})),]
    #Modify sequence to detect only the phosphorilated sites
    pattern <- str_extract_all(input_files$PEP$`Phospho (STY) Probabilities`, "1|(0\\.\\d+)")
    replacement <- lapply(str_extract_all(input_files$PEP$`Phospho (STY) Probabilities`, "1|(0\\.\\d+)"), 
                          function(x){as.integer(as.double(unlist(x)) > (phospho_thr/100))})
    input_files$PEP$Sequence <- lapply(1:length(input_files$PEP$`Phospho (STY) Probabilities`), 
                                       function(x){
                                         stri_replace_all_regex(input_files$PEP$`Phospho (STY) Probabilities`[x], 
                                                                pattern[[x]],
                                                                as.character(replacement[[x]]),
                                                                vectorize_all = F)}) %>% unlist()
  }
  input_files$PEP$`Gene names`[which(str_detect(input_files$PEP$`Gene names`,";"))] <- lapply(
    input_files$PEP$`Gene names`[which(str_detect(input_files$PEP$`Gene names`,";"))],
    function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()
  
  #Made the matrix
  input_files$PEP_matrix<- data.frame("Protein" = as.factor(paste(input_files$PEP$`Leading razor protein`, input_files$PEP$Modifications, input_files$PEP$Sequence, sep="_")), 
                                      "Sample" = as.factor(input_files$PEP$`Raw file`), 
                                      "Intensity" = input_files$PEP$Intensity)
  input_files$PEP_matrix<-as.data.frame(pivot_wider(input_files$PEP_matrix, names_from = Sample, values_from = Intensity, values_fn = sum))
  rownames(input_files$PEP_matrix) <- input_files$PEP_matrix$Protein
  input_files$PEP_matrix <- input_files$PEP_matrix[,-1]
  colnames(input_files$PEP_matrix) <- input_files$Input[match(colnames(input_files$PEP_matrix), input_files$Input$Filename),"Sample"]
  
  #Made the description of the mpeptides
  if(type == "PROT"){
    input_files$PEP_info <- as.data.frame(unique(input_files$PEP[, c("Leading razor protein", "Protein names", "Gene names", "Sequence", "Modifications")]))
    colnames(input_files$PEP_info) <- c("Accession","Description","GeneName", "Annotated Sequence","Modifications")
    rownames(input_files$PEP_info) <- paste(input_files$PEP_info$Accession, input_files$PEP_info$Modifications, input_files$PEP_info$`Annotated Sequence`, sep="_")
  } else{
    input_files$PEP_info <- as.data.frame(unique(input_files$PEP[, c("Leading razor protein", "Protein names", "Gene names", "Sequence", "Modifications", "Phospho (STY) Probabilities")]))
    colnames(input_files$PEP_info) <- c("Accession","Description","GeneName", "Annotated Sequence","Modifications", "Phospho_%")
    rownames(input_files$PEP_info) <- paste(input_files$PEP_info$Accession, input_files$PEP_info$Modifications, input_files$PEP_info$`Phospho_%`, sep="_")
    
    pattern <- data.frame("Phospho" = input_files$PEP_info$`Phospho_%`)
    pattern <- pattern %>% separate(Phospho, 
                                    as.character(1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1)),
                                    sep="\\(|\\)")
    pattern$group <- paste(input_files$PEP_info$Accession, input_files$PEP_info$Modifications, input_files$PEP_info$`Annotated Sequence`, sep="_")
    pattern$seq <- input_files$PEP_info$`Annotated Sequence`
    pattern <- pattern[order(pattern$group),]
    pattern[,as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 0))] <- sapply(
      pattern[,as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 0))], 
      as.double)
    pattern2 <- aggregate(pattern, list(pattern$group), mean)
    pattern2[,as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 0))] <- sapply(
      pattern2[,as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 0))], 
      function(x){round(x, digits = 3)})
    pattern2[order(pattern2$Group.1),
             as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 1))] <- unique(
               pattern[order(pattern$group),
                       c(as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 1)), "group", "seq")])
    pattern2[] <- lapply(pattern2, as.character)
    pattern2[is.na(pattern2)] <- "tmpC"
    base_string<- paste0(paste(rep("%s(%s)", 
                                   max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))), 
                               collapse = ""),
                         "%s")
    pattern2$newseq<-as.character(lapply(1:nrow(pattern2), function(x){
      str_remove_all(do.call(sprintf, c(fmt= base_string,
                                        (pattern2[x,as.character(1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))]))), "\\(tmpC\\)|tmpC| ")
    }))
    
    input_files$PEP_info <- as.data.frame(unique(input_files$PEP[, c("Leading razor protein", "Protein names", "Gene names", "Sequence", "Modifications")]))
    colnames(input_files$PEP_info) <- c("Accession","Description","GeneName", "Annotated Sequence","Modifications")
    rownames(input_files$PEP_info) <- paste(input_files$PEP_info$Accession, input_files$PEP_info$Modifications, input_files$PEP_info$`Annotated Sequence`, sep="_")
    input_files$PEP_info[pattern2$Group.1, "Phospho_%"] <- pattern2[,"newseq"]
    remove(pattern, pattern2)
  }
  
  #Maintain only the new complete matrix of intensity
  psm_sig_raw<-input_files$PEP_matrix
  psm_peptide_table<-input_files$PEP_info
  c_anno<-input_files$Input
  colnames(c_anno)<-tolower(colnames(c_anno))
  
  rownames(c_anno)<-c_anno$sample
  if("color" %in% colnames(c_anno)){
    colour_vec<-na.omit(c_anno[colnames(psm_sig_raw),]$color)
    names(colour_vec)<-na.omit(c_anno[colnames(psm_sig_raw),]$sample)
  } else{
    c_anno<-left_join(c_anno,
                      data.frame("color"=colour_vec[match(sort(c_anno$condition),unique(sort(c_anno$condition)))],
                                 "sample"=c_anno[order(c_anno$condition), "sample"]))
  }
  
  remove(input_files)
  return(list("psm_sig_raw" = psm_sig_raw,
              "psm_peptide_table" = psm_peptide_table,
              "c_anno" = c_anno,
              "colour_vec" = colour_vec,
              "formule_contrast" = formule_contrast))
}

filenames <- list("Input"=params$file_input_prot,"pep"=params$file_pep_prot)
res <- read_input_files("PROT", filenames)
psm_sig_raw_prot<-res$psm_sig_raw
psm_peptide_table_prot <- res$psm_peptide_table
c_anno_prot<-res$c_anno
rownames(c_anno_prot)<-c_anno_prot$sample
colour_vec<-res$colour_vec
formule_contrast<-res$formule_contrast


filenames <- list("Input"=params$file_input_phos,"pep"=params$file_pep_phos)
res <- read_input_files("PHOS", filenames)
psm_sig_raw_phos<-res$psm_sig_raw
c_anno_phos<-res$c_anno
rownames(c_anno_phos)<-c_anno_phos$sample
psm_peptide_table_phos <- res$psm_peptide_table


cat("#### Phosho-proteome samples \n ")
kable(c_anno_phos[setdiff(colnames(c_anno_phos), c("color","Color"))], row.names = F)
cat("#### Proteome samples \n ")
kable(c_anno_prot[setdiff(colnames(c_anno_prot), c("color","Color"))], row.names = F)
remove(filenames, res)
shiny::setProgress(0.23, detail = "Files correctly read...")
```

```{r peptide_annotation, message=F, warning=F, echo=F, eval=T}
if(readPD_files){
  psm_peptide_table_prot$`Position in Master Proteins`<-gsub(" ", "_", psm_peptide_table_prot$`Position in Master Proteins`)
  psm_peptide_table_phos$`Position in Master Proteins`<-gsub(" ", "_", psm_peptide_table_phos$`Position in Master Proteins`)
  psm_peptide_table_prot$Modifications<-gsub(" ", "_", psm_peptide_table_prot$Modifications)
  psm_peptide_table_phos$Modifications<-gsub(" ", "_", psm_peptide_table_phos$Modifications)
} else{
  psm_peptide_table_phos$Modifications<-gsub(" ", "_", psm_peptide_table_phos$Modifications)
  psm_peptide_table_prot$Modifications<-gsub(" ", "_", psm_peptide_table_prot$Modifications)
}

psm_anno_raw_prot <- data.frame("symbol"=psm_peptide_table_prot$GeneName,
                                  "sequence"=psm_peptide_table_prot$`Annotated Sequence`,
                                  "modifications"=psm_peptide_table_prot$Modifications)
psm_anno_raw_prot$id<-paste(psm_anno_raw_prot$symbol,psm_anno_raw_prot$sequence,psm_anno_raw_prot$modifications,sep="_")
  
psm_anno_raw_phos <- unique(data.frame("symbol"=psm_peptide_table_phos$GeneName,
                                  "sequence"=psm_peptide_table_phos$`Annotated Sequence`,
                                  "modifications"=psm_peptide_table_phos$Modifications))
psm_anno_raw_phos$id<-paste(psm_anno_raw_phos$symbol,psm_anno_raw_phos$sequence,psm_anno_raw_phos$modifications,sep="_")

#PROTEOMICS
rownames(psm_sig_raw_prot)<-rownames(psm_peptide_table_prot)<-rownames(psm_anno_raw_prot)<-psm_anno_raw_prot$id
psm_anno_raw_prot$old_id<-rownames(psm_anno_raw_prot)

# create peptide names linked to symbols
psm_anno_raw_prot$row <- seq(1,nrow(psm_anno_raw_prot))
psm_anno_raw_prot <- psm_anno_raw_prot %>% dplyr::group_by(symbol) %>% dplyr::mutate("min"=min(row),"card"=n()) %>% ungroup()
psm_anno_raw_prot$rank<- psm_anno_raw_prot$row - psm_anno_raw_prot$min +1
psm_anno_raw_prot$id<- paste(psm_anno_raw_prot$symbol,psm_anno_raw_prot$rank,psm_anno_raw_prot$card,sep="_")

psm_sig_raw_prot<-psm_sig_raw_prot[psm_anno_raw_prot$old_id,]
rownames(psm_anno_raw_prot)<-psm_anno_raw_prot$old_id
psm_sig_prot_raw_prot<-psm_sig_raw_prot

#PHOSPHO
rownames(psm_peptide_table_phos)<-paste(psm_peptide_table_phos$GeneName,psm_peptide_table_phos$`Annotated Sequence`,psm_peptide_table_phos$Modifications,sep="_")
rownames(psm_sig_raw_phos)<-rownames(psm_anno_raw_phos)<-psm_anno_raw_phos$id
psm_anno_raw_phos$old_id<-rownames(psm_anno_raw_phos)

# create peptide names linked to symbols
psm_anno_raw_phos$row <- seq(1,nrow(psm_anno_raw_phos))
psm_anno_raw_phos <- psm_anno_raw_phos %>% dplyr::group_by(symbol) %>% dplyr::mutate("min"=min(row),"card"=n()) %>% ungroup()
psm_anno_raw_phos$rank<- psm_anno_raw_phos$row - psm_anno_raw_phos$min +1
psm_anno_raw_phos$id<- paste(psm_anno_raw_phos$symbol,psm_anno_raw_phos$rank,psm_anno_raw_phos$card,sep="_")

psm_sig_raw_phos<-psm_sig_raw_phos[psm_anno_raw_phos$old_id,]
psm_sig_pet_raw_phos<-psm_sig_raw_phos
rownames(psm_anno_raw_phos)<-psm_anno_raw_phos$old_id

shiny::setProgress(0.27, detail = "Annotate proteins/peptides...")
```

```{r preprocess_sig_raw, echo=F, message=F, warning=F}
#Preprocess Protein intensities
psm_sig_prot_raw_prot[psm_sig_prot_raw_prot == 0] <- NA # transform 0s into NAs

sig_thr<-filt_absent_value # NA threshold

psm_long_df_prot <- psm_sig_prot_raw_prot %>% mutate(id=as.factor(rownames(psm_sig_prot_raw_prot)))
psm_long_df_prot <- psm_long_df_prot %>% pivot_longer(-id, names_to = "sample", values_to = "counts")
psm_long_df_prot <- suppressMessages(left_join(psm_long_df_prot,c_anno_prot))

psm_filter_df_prot <- psm_long_df_prot %>% dplyr::group_by(id,condition, .drop=FALSE) %>% dplyr::summarise("min_c"=sum(is.na(counts))) %>% ungroup()

psm_filter_df_prot <- psm_filter_df_prot %>% dplyr::group_by(id,.drop=FALSE) %>% dplyr::summarise("passes_c"= sum(min_c <= sig_thr)) %>% ungroup()

filter_id_prot <- as.character(psm_filter_df_prot %>% dplyr::filter(passes_c > 0) %>% pull(id))

psm_sig_prot_df <-psm_sig_prot_raw_prot[filter_id_prot,]
psm_anno_df <- psm_anno_raw_prot[filter_id_prot,]
psm_peptide_table_prot <- psm_peptide_table_prot[filter_id_prot,]
#Log2
psm_log_prot_df <- psm_sig_prot_df
psm_log_prot_df <- psm_sig_prot_df %>% log2()

#Clean old variables
remove(psm_anno_raw_prot,psm_sig_prot_raw_prot,psm_long_df_prot,psm_filter_df_prot,filter_id_prot,sig_thr)

#Preprocess peptide intensities
psm_sig_pet_raw_phos[psm_sig_pet_raw_phos == 0] <- NA # transform 0s into NAs
sig_thr<-filt_absent_value # NA threshold

psm_long_df_phos <- psm_sig_pet_raw_phos %>% mutate(id=as.factor(rownames(psm_sig_pet_raw_phos)))
psm_long_df_phos <- psm_long_df_phos %>% pivot_longer(-id, names_to = "sample", values_to = "counts")
psm_long_df_phos <- suppressMessages(left_join(psm_long_df_phos,c_anno_phos))

psm_filter_df_phos <- psm_long_df_phos %>% dplyr::group_by(id,condition, .drop=FALSE) %>% dplyr::summarise("min_c"=sum(is.na(counts))) %>% ungroup()
psm_filter_df_phos <- psm_filter_df_phos %>% dplyr::group_by(id,.drop=FALSE) %>% dplyr::summarise("passes_c"= sum(min_c <= sig_thr)) %>% ungroup()
filter_id_phos <- as.character(psm_filter_df_phos %>% dplyr::filter(passes_c > 0) %>% pull(id))

psm_sig_pet_df_phos <-psm_sig_pet_raw_phos[filter_id_phos,]
id_pep_table <- paste(psm_peptide_table_phos$GeneName, 
                      psm_peptide_table_phos$`Annotated Sequence`, 
                      psm_peptide_table_phos$Modifications, sep="_")[(paste(psm_peptide_table_phos$GeneName, 
                                                                            psm_peptide_table_phos$`Annotated Sequence`, 
                                                                            psm_peptide_table_phos$Modifications, sep="_") %in% filter_id_phos)]
psm_peptide_table<-psm_peptide_table_phos[id_pep_table,]

#Determine column tryptic
peptides_df <- psm_peptide_table[,c("Accession", "Annotated Sequence")]
peptides_df$preAA <- str_sub(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,1], regex("\\[\\w+\\]")),
                             2,
                             str_length(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."),
                                                                    n = 3)[,1], regex("\\[\\w+\\]")))-1)

peptides_df$endAA <- str_sub(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,2], -1, -1)
peptides_df$postAA <- str_sub(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,3], regex("\\[\\w+\\]")),
                              2,
                              str_length(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."),
                                                                     n = 3)[,3], regex("\\[\\w+\\]")))-1)

peptides_df$fully_TRI = (peptides_df$preAA %in% c("K","R") &
                           peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$NSEMI_TRI = (peptides_df$preAA %in% c("K","R") &
                           !peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$CSEMI_TRI = (!peptides_df$preAA %in% c("K","R") &
                           peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$non_TRI = (!peptides_df$fully_TRI & !peptides_df$NSEMI_TRI & !peptides_df$CSEMI_TRI)

peptides_df$tryptic_cond[peptides_df$fully_TRI] <- "fully tryptic"
peptides_df$tryptic_cond[peptides_df$NSEMI_TRI] <- "N-semi tryptic"
peptides_df$tryptic_cond[peptides_df$CSEMI_TRI] <- "C-semi tryptic"
peptides_df$tryptic_cond[peptides_df$non_TRI] <- "non tryptic"

psm_peptide_table$tryptic_cond <- peptides_df$tryptic_cond

#Log2
psm_log_pet_df <- psm_sig_pet_df_phos
psm_log_pet_df <- psm_log_pet_df %>% log2()

remove(psm_sig_pet_raw_phos,psm_sig_raw_phos,psm_long_df_phos,psm_filter_df_phos,filter_id_phos,sig_thr, peptides_df, psm_anno_raw_phos, psm_peptide_table_phos)

shiny::setProgress(0.29, detail = "Filtering intensity matrix...")
```


## 1. Analysis

### 1.1. Sample annotation
The sample table below annotates the samples of the study as in the **Sample_Annotation** file. Important columns for the analysis:

- **Sample**: sample name used in the results,
- **Condition**: condition of the sample used in study desgin and differential analyses,
- **Color**: the color of the sample in figures.

Raw data consist in the area under the peak (m/z, time, number of events) calculated for PSM (PSMs: peptide-to-spectrum matches).

-   PSMs not consistently present in all replicates of at least 1 condition will be removed.
-   Contaminants are removed.

Initial filtering removes the following peptides:

-   Low/missing abundance: PSMs not consistently present in all replicates of at least one condition are removed.
-   Contaminants.

After filtering, raw abundances are log2 transformed

#### Number of identified peptides/proteins
```{r stat_proteomic, echo=F, message=F, warning=F, results='asis'}
df_stat <- data.frame("number" = c(length(unique(psm_anno_df$symbol)), nrow(psm_log_pet_df)), row.names = c("Discovered proteins in proteomics:", "Discovered peptides in phospho-proteomiscs:"))
kable(df_stat)
```

#### 1.1. Distributions of log2 raw abundances {.tabset} 
Violin plot showing sample distributions of log2 raw abundances of peptides.

```{r raw_distributions, message=F, warning=F, echo=F, results='asis'}
cat("\n \n")

psm_long_df <- psm_log_pet_df[,c_anno_phos[order(c_anno_phos$condition),"sample"]] %>% mutate(id=as.factor(rownames(psm_log_pet_df[,c_anno_phos[order(c_anno_phos$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2 raw abundance")
psm_long_df <- suppressMessages(left_join(psm_long_df,c_anno_phos))

hs<-ggplot(data=psm_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`log2 raw abundance`,fill=sample,colour=sample))+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = T)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank()) +
  scale_fill_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Phospho-proteomics \n")
print(hs)
cat("\n \n")

psm_long_df <- psm_log_prot_df[,c_anno_prot[order(c_anno_prot$condition),"sample"]] %>% mutate(id=as.factor(rownames(psm_log_prot_df[,c_anno_prot[order(c_anno_prot$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2 raw abundance")
psm_long_df <- suppressMessages(left_join(psm_long_df,c_anno_prot))

hs<-ggplot(data=psm_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`log2 raw abundance`,fill=sample,colour=sample))+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = T)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank()) +
  scale_fill_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Proteomics \n")
print(hs)
cat("\n \n")

shiny::setProgress(0.32, detail = "Calculate distributions...")
```

#### 1.2. Percentage of quantified peptides per sample {.tabset} 
Barplot showing the percentage of peptides with available abundancies for each sample.

```{r numeric_numbers, echo=F, message=F, warning=F, results='asis'}
cat("\n \n")
numeric_df<- c_anno_phos[c_anno_phos[order(c_anno_phos$condition),"sample"],]
numeric_df$numeric_values<-colSums(is.na(psm_log_pet_df))
numeric_df$numeric_percentage<- 100-(numeric_df$numeric_values/nrow(psm_log_pet_df)*100)
setnames(numeric_df,"numeric_percentage","% of available abundances")
hs<-ggplot(data=numeric_df, aes(x=factor(sample, levels=unique(numeric_df$sample)),y=`% of available abundances`,fill=sample,colour=sample))+
  coord_flip()+
  geom_bar(stat="identity",width=.7,alpha=.8)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  scale_fill_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Phospho-proteomics \n")
print(hs)
cat("\n \n")

numeric_df<- c_anno_prot[c_anno_prot[order(c_anno_prot$condition),"sample"],]
numeric_df$numeric_values<-colSums(is.na(psm_log_prot_df))
numeric_df$numeric_percentage<- 100-(numeric_df$numeric_values/nrow(psm_log_prot_df)*100)
setnames(numeric_df,"numeric_percentage","% of available abundances")
hs<-ggplot(data=numeric_df, aes(x=factor(sample, levels=unique(numeric_df$sample)),y=`% of available abundances`,fill=sample,colour=sample))+
  coord_flip()+
  geom_bar(stat="identity",width=.7,alpha=.8)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  labs(x = "Percentage of known intensity (%)") +
  scale_fill_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Proteomics \n")
print(hs)
cat("\n \n")
remove(hs,numeric_df)
shiny::setProgress(0.34, detail = "Doing imputation...")
```

#### 1.3. Phosphosite residues
The following graph represent the percentage of the phosphosites located on Serine (S), Throenines (T) and Tyrosines (Y).

```{r numeric_percentage_phosphosite, echo=F, message=F, warning=F, results='asis', fig.height=3, fig.width=7.5}
cat("\n \n")
if(readPD_files){
  active_sites <- lapply(lapply(stri_extract_all_regex(psm_peptide_table$modif, "\\w\\d+\\(1|\\w\\d+\\.|\\ \\w\\]|\\w\\(1"), 
                                function(x){stri_replace_all(x,regex = "\\ ",replacement = "")}), 
                         function(y){unlist(stri_extract_all_regex(unlist(y), "S|T|Y"))}) %>% unlist() %>% table()
} else{
  active_sites <- lapply(stri_extract_all_regex(psm_peptide_table$`Annotated Sequence`, "\\w\\(1"), 
                         function(x){stri_sub_all(x, from = 1, to = 1)}) %>% unlist() %>% table()
}
numeric_df<- data.frame("Site" = c("S", "T", "Y"),
                        "perc"= c((active_sites["S"]/sum(active_sites)*100), 
                                  (active_sites["T"]/sum(active_sites)*100), 
                                  (active_sites["Y"]/sum(active_sites)*100)),
                        "label"= c(paste(as.character(round(active_sites["S"]/sum(active_sites)*100, digits = 2)), "%"), 
                                   paste(as.character(round(active_sites["T"]/sum(active_sites)*100, digits = 2)), "%"),
                                   paste(as.character(round(active_sites["Y"]/sum(active_sites)*100, digits = 2)), "%")))
setnames(numeric_df,"perc","Percentage of phosphosite (%)")

hs <- enrichment_lollipop(numeric_df, 
                    x_col = "Percentage of phosphosite (%)", 
                    y_col = "Site", 
                    size_col = "Percentage of phosphosite (%)", size_vec = c(6,6),
                    shape_col = "Site", shape_vec = c(16,16,16),
                    color_col = "Site", color_vec = c("#F79256", "#FBD1A2", "#7DCFB6"), 
                    fill_col = "Site", fill_vec = c("#F79256", "#FBD1A2", "#7DCFB6"), 
                    text_col = "label") + theme(legend.position = "none", axis.text.y = element_text(size = 14))
  
  

print(hs)
cat("\n \n")

remove(hs,numeric_df,active_sites)
```

#### 1.4. Imputation, normalization, peptide-to-protein summarization 

**Imputation** is performed on peptide and protein abundances with the Bioconductor package [PhosR](https://www.sciencedirect.com/science/article/pii/S221112472100084X). Round imputation is performed in absence of replicates. ProTN uses two function of PhosR for the imputation, the first impute the missing values for a peptide across replicates within a single condition, the second is a tail-based imputation approach as implemented in Perseus.

**Normalization:**

**Phospho-peptides** abundances are normalized with the equalMedianNormalization function from the Bioconductor package [DEqMS](<https://www.bioconductor.org/packages/release/bioc/html/DEqMS.html>) (equal medians in all samples). 

**Protein** normalized abundancies are calculated with the medianSweeping function from the Bioconductor package [DEqMS](<https://www.bioconductor.org/packages/release/bioc/html/DEqMS.html>).

```{r pep_in_proteins, echo=F, message=F, warning=F}

numeric_df <- as.data.table(table(psm_anno_df$symbol))
numeric_df[which(numeric_df$N > 20), "N"] <- 20
numeric_df <- numeric_df[order(numeric_df$N) , .(NPeptides = .N), by = c("N")][2:20,]
numeric_df$N <- factor(str_sort(str_replace(as.character(numeric_df$N), pattern = "20", replacement = "20+"), numeric = T), levels = c(2:19, "20+"))

hs<-ggplot(data=numeric_df, aes(x=N,y=NPeptides, color = NPeptides, fill = NPeptides))+
  geom_bar(stat="identity",width=.7,alpha=.8)+
  theme_bw()+
  theme(legend.position = "none")+
  labs(x = "# peptides per protein", y = "# protein") +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank(),panel.grid.major.x = element_blank())

hs

remove(hs,numeric_df)
```

```{r imputation, echo=F, message=F, warning=F, results='asis'}
message("Imputation of intensity matrix in progress...")
psm_log_prot_df<-tryCatch(
  {
    #Imputation with Phospho
    ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(psm_log_prot_df)))
    #Mantieni ordine
    grps <- as.factor(c_anno_prot[colnames(psm_log_prot_df), "condition"])
    ppe <- scImpute(ppe, 0.6, grps)
    ppe <- tImpute(ppe, assay = "imputed")
    psm_log_prot_df[is.na(psm_log_prot_df)]<-ppe@assays@data@listData$imputed[is.na(psm_log_prot_df)]
    psm_log_prot_df
  },
  error=function(cond){
    # Rounds of imputation
    mat_i <- psm_log_prot_df
    col_sele<-colnames(mat_i)

    vec_all<-unlist(mat_i[,col_sele]) # convert to vector
    vec_numeric<-vec_all[-which(is.na(vec_all))] # remove NAs
    orig_stats<-c(mean(vec_numeric),sd(vec_numeric)) # calculate mean and sd
    imp_stats<-c(orig_stats[1]-(orig_stats[2]*1.8),orig_stats[2]*0.3) # imputed mean = mean-1.8*sd, imputed sd = sd*0.3

    set.seed(42)
    imp_matrix<-matrix(rnorm(length(vec_all), mean = imp_stats[1], sd = imp_stats[2]), ncol=ncol(mat_i)) # create matrix of imputed values
    psm_log_prot_df[is.na(psm_log_prot_df)]<-imp_matrix[is.na(psm_log_prot_df)]
    psm_log_prot_df
  }
)

remove(ppe,grps)

psm_log_pet_df<-tryCatch(
  {
    #Imputation with Phospho
    ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(psm_log_pet_df)))
    grps <- as.factor(c_anno_phos[colnames(psm_log_prot_df), "condition"])
    ppe <- scImpute(ppe, 0.6, grps)
    ppe <- tImpute(ppe, assay = "imputed")
    psm_log_pet_df[is.na(psm_log_pet_df)]<-ppe@assays@data@listData$imputed[is.na(psm_log_pet_df)]
    psm_log_pet_df
  },
  error=function(cond){
    # Rounds of imputation
    mat_i <- psm_log_pet_df
    col_sele<-colnames(mat_i)

    vec_all<-unlist(mat_i[,col_sele]) # convert to vector
    vec_numeric<-vec_all[-which(is.na(vec_all))] # remove NAs
    orig_stats<-c(mean(vec_numeric),sd(vec_numeric)) # calculate mean and sd
    imp_stats<-c(orig_stats[1]-(orig_stats[2]*1.8),orig_stats[2]*0.3) # imputed mean = mean-1.8*sd, imputed sd = sd*0.3

    set.seed(42)
    imp_matrix<-matrix(rnorm(length(vec_all), mean = imp_stats[1], sd = imp_stats[2]), ncol=ncol(mat_i)) # create matrix of imputed values
    psm_log_pet_df[is.na(psm_log_pet_df)]<-imp_matrix[is.na(psm_log_pet_df)]
    psm_log_pet_df
  }
)

remove(ppe,grps)

shiny::setProgress(0.38, detail = "Done normalization...")
```

```{r prot_summarization, warning=F, message=F, echo=F}
message("Median normalization in progress...")

#Summarize into proteins and normalize by median
dat_psm <- cbind(psm_anno_df[,c("id","symbol")],psm_log_prot_df)
dat_gene = DEqMS::medianSweeping(dat_psm,group_col = 2)

# Median centering log2 table for peptides
dat_pep = DEqMS::equalMedianNormalization(psm_log_pet_df)

message("Normalization DONE.")

shiny::setProgress(0.42, detail = "Done normalization and imputation...")
```

```{r batch_correction, warning=F, message=F, echo=F, eval=batch_corr_exe, results='asis'}
cat("#### 1.4.1. Batch correction {.tabset}  \n")
cat("A batch effect correction is applied to the datased using the proBatch package. \n")
cat(" \n \n")

batch_annotation <- c_anno_phos
batch_annotation$order<-c(1:nrow(batch_annotation))

dat_pep_long <- matrix_to_long(dat_pep) %>% setnames("FullRunName","sample")
comBat_df_pep <- correct_with_ComBat_df(dat_pep_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
dat_pep = as.data.frame(long_to_matrix(comBat_df_pep, sample_id_col = "sample"))

batch_annotation <- c_anno_prot
batch_annotation$order<-c(1:nrow(batch_annotation))
dat_gene_long <- matrix_to_long(dat_gene) %>% setnames("FullRunName","sample")
comBat_df_gene <- correct_with_ComBat_df(dat_gene_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
dat_gene = as.data.frame(long_to_matrix(comBat_df_gene, sample_id_col = "sample"))
```

```{r sig_tables, message=F, warning=F, echo=F, results='hide'}
#Save proteins table
expr_mat<-as.data.table(dat_gene)
expr_mat$gene <- rownames(dat_gene)

expr_l_df <- melt(expr_mat)
colnames(expr_l_df) <- c("id","sample","expr")
expr_l_df <- expr_l_df[c_anno_prot, on = "sample"]

expr_cond_df <- expr_l_df[ , .(N = .N, avg = mean(expr), sd=sd(expr), CV=sd(expr)/mean(expr), se = sd(expr)/sqrt(.N)), by = c("condition","id")]

expr_avg_df <- dcast(expr_cond_df[,c("id","condition","avg")], id ~ condition)
colnames(expr_avg_df)[-1]<-paste0(colnames(expr_avg_df)[-1],"_avg")
expr_se_df <- dcast(expr_cond_df[,c("id","condition","se")], id ~ condition)
colnames(expr_se_df)[-1]<-paste0(colnames(expr_se_df)[-1],"_se")
expr_cv_df <- dcast(expr_cond_df[,c("id","condition","CV")], id ~ condition)
colnames(expr_cv_df)[-1]<-paste0(colnames(expr_cv_df)[-1],"_Coef_Variant_(%)")

expr_avgse_df <- Reduce(merge,list(expr_avg_df,expr_se_df,expr_cv_df))

toPrint<-expr_avgse_df
colnames(toPrint)[1]<-"symbol"

n_pep_prot <- unique(merge.data.table(as.data.table(psm_peptide_table_prot[,c("Accession","Description","GeneName")]), as.data.table(psm_anno_df)[ , .(Num.Peptide = .N), by = symbol], by.x = "GeneName", by.y = "symbol"))
colnames(n_pep_prot)[1]<-"symbol"
toPrint_datGene<-as.data.table(dat_gene)
toPrint_datGene$symbol<-rownames(dat_gene)

df_to_save<-list("protein_per_sample"=merge.data.table(n_pep_prot,toPrint_datGene),
                 "protein_per_condition"=merge.data.table(n_pep_prot,toPrint))

#Save peptides table
expr_mat<-as.data.table(dat_pep)
expr_mat$gene <- rownames(dat_pep)

expr_l_df <- melt(expr_mat)
colnames(expr_l_df) <- c("id","sample","expr")
expr_l_df <- expr_l_df[c_anno_phos, on = "sample"]

expr_cond_df <- expr_l_df[ , .(N = .N, avg = mean(expr), sd=sd(expr), CV=sd(expr)/mean(expr), se = sd(expr)/sqrt(.N)), by = c("condition","id")]

expr_avg_pet_df <- dcast(expr_cond_df[,c("id","condition","avg")], id ~ condition)
colnames(expr_avg_pet_df)[-1]<-paste0(colnames(expr_avg_pet_df)[-1],"_avg")
expr_se_pet_df <- dcast(expr_cond_df[,c("id","condition","se")], id ~ condition)
colnames(expr_se_pet_df)[-1]<-paste0(colnames(expr_se_pet_df)[-1],"_se")
expr_cv_pep_df <- dcast(expr_cond_df[,c("id","condition","CV")], id ~ condition)
colnames(expr_cv_pep_df)[-1]<-paste0(colnames(expr_cv_pep_df)[-1],"_Coef_Variant_(%)")

expr_avgse_pep_df <- Reduce(merge,list(expr_avg_pet_df,expr_se_pet_df,expr_cv_pep_df))

toPrint<-expr_avgse_pep_df

#Prepare the README
readme_sheet <- data.frame("INFO"=c(NA,
                                    "Excel file containing abundance values generated by proTN. Abundances are log2 transformed, normalized, imputed (and batch corrected). The file is organized in the following sheets",
                                    NA,
                                    "Sheet *protein_per_sample*: protein abundances per sample. (PROTEOME)",
                                    "Sheet *peptide_per_sample*: peptide abundances per sample. (PHOSPHO-PROTEOME)",
                                    "Sheet *protein_per_condition*: protein abundances per condition (average & standard deviation), as defined in the Sample Annotation. (PROTEOME)",
                                    "Sheet *peptide_per_condition*: peptide abundances per condition (average & standard deviation), as defined in the Sample Annotation. (PHOSPHO-PROTEOME)"
))

#Export table with SE e MEAN
df_to_save<-list("README"=readme_sheet,
                 "protein_per_sample"=df_to_save$`protein_per_sample`,
                 "peptide_per_sample"=merge(psm_peptide_table, dat_pep, by=0)[,-c(1)],
                 "protein_per_condition"=df_to_save$`protein_per_condition`,
                 "peptide_per_condition"=merge.data.table(as.data.table(rownames_to_column(psm_peptide_table)), toPrint, by.x = "rowname", by.y = "id")[,-c(1)])

writexl::write_xlsx(df_to_save,paste0(dirOutput,subfold_Tab,"normalised_abundances.xlsx"))
remove(expr_mat,expr_l_df,expr_cond_df,toPrint)

shiny::setProgress(0.45, detail =  "Save normalized data...")
```

```{r norm_distributions, message=F, warning=F, echo=F, results='asis'}
cat("\n \n")
cat("#### 1.5. Distributions of normalized abundancies {.tabset}  \n")
cat("Violin plot showing sample distributions of log2 normalized and imputed abundancies. \n \n ")
cat("\n \n")

pg_long_df <- dat_pep[,c_anno_phos[order(c_anno_phos$condition),"sample"]] %>% mutate(id=as.factor(rownames(dat_pep[,c_anno_phos[order(c_anno_phos$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2 normalized abundance")
pg_long_df <- suppressMessages(left_join(pg_long_df,c_anno_phos))


hs<-ggplot(data=pg_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`log2 normalized abundance`,fill=sample,colour=sample))+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = F)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  scale_fill_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Phospho-proteomics \n")
print(hs)
cat("\n \n")

pg_long_df <- dat_gene[,c_anno_prot[order(c_anno_prot$condition),"sample"]] %>% mutate(id=as.factor(rownames(dat_gene[,c_anno_prot[order(c_anno_prot$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2 normalized abundance")
pg_long_df <- suppressMessages(left_join(pg_long_df,c_anno_prot))


hs<-ggplot(data=pg_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=`log2 normalized abundance`,fill=sample,colour=sample))+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = F)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  scale_fill_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Proteomics \n")
print(hs)
cat("\n \n")

remove(hs, pg_long_df)
shiny::setProgress(0.47, detail =  "Calculate post-norm distribution...")
```

```{r check_number_sample, warning=FALSE, echo=F, message=FALSE}
design = model.matrix(~0+str_remove(c_anno_phos$condition, "_p\\b")) 
colnames(design) = levels(as.factor(str_remove(c_anno_phos$condition, "_p\\b")))
rownames(design)<-c_anno_phos$sample
filt_contro_list <- list()
for (i in 1:length(formule_contrast)) {
  if(all(stri_remove_empty(str_remove_all(str_extract_all(formule_contrast[i], "\\w+")[[1]], "^\\d+$")) %in% colnames(design))){
    filt_contro_list<-c(filt_contro_list,i)
  }
}
contro_list<-formule_contrast[unlist(filt_contro_list)]
if(length(contro_list) == 0){ stop("Error: No valid contrast design given. Check the match between the spell of Condition and contrast design.")}
contrast =  limma::makeContrasts(contrasts=contro_list,levels=design)
colnames(contrast)<-names(contro_list)

unique_cond <- colSums(design) == 1
unique_cond <- sort(names(unique_cond[unique_cond]))
res<-lapply(colnames(contrast), function(i){all(sort(names((contrast[,i] != 0)[contrast[,i] != 0])) %in% unique_cond)}) %>% unlist()
formule_contrast<- contro_list[!res]

eval_single_Cond <- if(all(res)){FALSE}else{TRUE}
if(!eval_single_Cond | length(formule_contrast) > 0){
  cat("*WARNING*: Some comparisons cannot be done since have only two samples. The comparison are removed.")
}
```

```{r mds_counts, warning=F, message=F, echo=F, results='asis', eval=eval_single_Cond}
cat(" \n \n")
cat("#### 1.6. Multi-dimensional scaling {.tabset}  \n")
cat("Multidimensional scaling (MDS) takes a set of dissimilarities and returns a set of points such that the distances between the points are approximately equal to the dissimilarities. Classical multidimensional scaling is also known as principal coordinates analysis. \n \n ")
cat("MDS analysis is performed on normalized **Phospho Peptide** and **Proteomic Protein** abundances. \n")
cat(" \n \n")

#Peptides
sample_data<-(t(dat_pep))
sample_distances <- dist(sample_data, method = "euclidean")

mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
mds_cmdscale$sample <- rownames(mds_cmdscale)
mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno_phos))

#Take correct order of color
cc<-mds_cmdscale$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
  names(cc)<-unique(mds_cmdscale$condition)
} else{
  names(cc)<-mds_cmdscale$condition
}

cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
  geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  scale_colour_manual(values=cc[unique(names(cc))]) +
  theme_bw(base_size = bs, base_family = bf) +
  theme(legend.position = "right", panel.grid.minor=element_blank())

cat("##### Phospho-proteome \n")
print(cmd)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"mds_phosphoproteome.pdf"), cmd, device=cairo_pdf, 
                        width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in")))

#PROTEOMICS
sample_data<-(t(dat_gene))
sample_distances <- dist(sample_data, method = "euclidean")

mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
mds_cmdscale$sample <- rownames(mds_cmdscale)
mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno_prot))

#Take correct order of color
cc<-mds_cmdscale$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
  names(cc)<-unique(mds_cmdscale$condition)
} else{
  names(cc)<-mds_cmdscale$condition
}


cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
  geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  scale_colour_manual(values=cc[unique(names(cc))]) +
  theme_bw(base_size = bs, base_family = bf) +
  theme(legend.position = "right", panel.grid.minor=element_blank())

cat("##### Proteome \n")
print(cmd)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"mds_proteome.pdf"), cmd, device=cairo_pdf, 
                        width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,cmd)

shiny::setProgress(0.49, detail = "Calculate MDS...")
```

```{r pca_norm, warning=F, message=F, echo=F, results='asis', eval=eval_single_Cond}
cat(" \n \n")
cat("#### 1.7. Principal Component Analysis {.tabset}  \n")
cat("Principal component analysis (PCA) is performed on normalized  **Phospho Peptide** and **Proteomic Protein** abundances. \n \n ")
cat(" \n \n")

#Peptides
sample_data<-(t(dat_pep))
apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
pc <- apca_prot$x[,1:2]

pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
pc<- merge(pc, c_anno_phos, by = 0)
pc$condition <- as.factor(pc$condition)

ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
ve <- ve[c(1, 2)]
labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

#Take correct order of color
cc<-pc$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(pc$condition))]
  names(cc)<-unique(pc$condition)
} else{
  names(cc)<-pc$condition
}

#ggplot method
p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
      geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
      geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
      scale_colour_manual(values=cc[unique(names(cc))]) +
      theme_bw(base_size = bs, base_family = bf) +
      theme(legend.position = "right", panel.grid.minor=element_blank()) +
      xlab(labs[1]) +
      ylab(labs[2])

cat("##### Phospho-proteome \n")
print(p1)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"pca_phosphoproteome.pdf"), p1, device=cairo_pdf, 
                        width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,p1)

#Proteome
sample_data<-(t(dat_gene))
apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
pc <- apca_prot$x[,1:2]

pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
pc<- merge(pc, c_anno_prot, by = 0)
pc$condition <- as.factor(pc$condition)

ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
ve <- ve[c(1, 2)]
labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

#Take correct order of color
cc<-pc$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(pc$condition))]
  names(cc)<-unique(pc$condition)
} else{
  names(cc)<-pc$condition
}

#ggplot method
p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
      geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
      geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
      scale_colour_manual(values=cc[unique(names(cc))]) +
      theme_bw(base_size = bs, base_family = bf) +
      theme(legend.position = "right", panel.grid.minor=element_blank()) +
      xlab(labs[1]) +
      ylab(labs[2])

cat("##### Proteome \n")
print(p1)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"pca_proteome.pdf"), p1, device=cairo_pdf,
                        width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,cmd)
shiny::setProgress(0.51, detail = "Calculate PCA...")
```

```{r boxplot_proteins, warning=F, message=F, echo=F, eval=boxplot_prot_exe, results='asis'}
prot_find<-unique(c(intersect(prot_boxplot,psm_peptide_table$GeneName),
                    intersect(str_to_title(prot_boxplot),psm_peptide_table$GeneName),
                    intersect(str_to_upper(prot_boxplot),psm_peptide_table$GeneName),
                    intersect(str_to_lower(prot_boxplot),psm_peptide_table$GeneName)))

if(length(prot_find)>0){
  cat("#### 1.8. Abundances of selected proteins {.tabset}  \n")
  cat("Normalized log2 abundancies are displayed for proteins selected in the input. Abundances are grouped per condition. \n \n ")
  cat("Selected proteins with available abundancies: \n")
  cat(paste(prot_find, sep = ", "))
  cat(" \n")
  cat(" \n \n")

  prot_intensity_long <- as.data.table(dat_pep[rownames(psm_peptide_table[which(psm_peptide_table$GeneName %in% prot_find),]),])
  prot_intensity_long$genename <- psm_peptide_table[which(psm_peptide_table$GeneName %in% prot_find),"GeneName"]
  prot_intensity_long <- prot_intensity_long[,lapply(.SD,mean,na.rm=TRUE),by=genename,.SDcols=colnames(dat_pep)] %>% as.data.frame()
  prot_intensity_long<-prot_intensity_long[,c(-1)]
  rownames(prot_intensity_long)<-prot_find
  prot_intensity_long <- proBatch::matrix_to_long(prot_intensity_long) %>%
                              data.table::setnames(new = c("Protein","Condition","Intensity"))
  prot_intensity_long <- unique((left_join(prot_intensity_long,
                                             c_anno_phos[prot_intensity_long$Condition, c("sample","condition")],
                                             by=c("Condition"="sample")))[,-c(2)])  %>%
                              data.table::setnames(new = c("Protein","Intensity","Condition"))
    

  expr_cond_df<-prot_intensity_long %>% dplyr::group_by(Condition,Protein) %>%
            dplyr::summarise(N=n(),avg=mean(Intensity),sd=sd(Intensity)) %>% ungroup() %>% mutate("se"=sd/sqrt(N))
  prot_avg_se_long <- expr_cond_df[, c("Condition","Protein","avg","se")]
  
  #Take correct order of color
  cc<-c_anno_phos$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(c_anno_phos$condition))]
    names(cc)<-unique(c_anno_phos$condition)
  } else{
    names(cc)<-c_anno_phos$condition
  }
  cc<-unique(cc)
  g<-ggplot(prot_avg_se_long,aes(Condition,avg,fill=Condition,colour=Condition))+
    geom_crossbar(aes(ymin=avg,ymax=avg),position = "dodge",width=.8,alpha=.9,fatten=1.5)+
    geom_errorbar(aes(ymin=(avg-se), ymax=(avg+se)), width=.4,position=position_dodge(),show.legend=F,alpha=.8)+
    geom_quasirandom(data=prot_intensity_long, aes(Condition,Intensity), alpha=.7,width=.1,shape=16,size=0.11*bs)+
    scale_fill_manual(name="Condition",values=cc[sort(unique(prot_intensity_long$Condition))]) +
    scale_colour_manual(name="Condition",values=cc[sort(unique(prot_intensity_long$Condition))])+
    theme_bw(base_size = bs, base_family = bf) +
    theme(axis.title.x=element_blank(),
          axis.text.x = element_text(angle = 30, hjust = 1, colour=cc[sort(unique(prot_intensity_long$Condition))]),
          panel.grid.major.x=element_blank(),
          panel.grid.minor.y=element_blank(),
          legend.text = element_text(size = 0.7*bs),
          legend.key.size = unit((0.015*bs),"in"),
          legend.position="none",
          legend.title=element_blank(),
          legend.background = element_rect(fill = NA),
          strip.text=element_text(colour="white",face="bold"),
          panel.border=element_rect(colour=c("grey40"),size=0.03*bs),
          strip.background=element_rect(fill="grey40",colour="grey40",size=0.03*bs),
          plot.title = element_text(hjust = 0.5))+
    facet_wrap(~Protein, scales = "free",ncol = if(length(prot_find)>4){round(length(prot_find)/1.9)}else{4})+
    labs(y="Abundance")
  print(g)

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_expr,"selected_protein_plot.pdf"), g, device=cairo_pdf, 
                          width = ((if(length(prot_find)<4){((length(prot_find)-1/(length(prot_find)))^1.2)*0.9}else{(4*1.2)*0.9}))+(0.75*length(unique(prot_avg_se_long$Condition))), 
                          height = 3*(if(length(prot_find)>=4){(length(prot_find) %/% 4)+1}else{1}), units = c("in")))

}else{
  cat("##### Selected proteins in options file do not find in the normalised matrix. Check the spell of the proteins. \n")
  cat(" \n \n")
}

shiny::setProgress(0.56, detail = "Control boxplot proteins...")
```

## 2. Identification of Differentially Phosphorylated Peptides

Differentially phosphorylated peptides are identified using the Limma Bioconductor package. In each comparison, phospho-peptide changes are scaled for differences in the corresponding protein levels. PhosProTN also perform phosphorylation enrichment analysis for each condition 

```{r print_error_diff_analysis, warning=FALSE, echo=F, message=FALSE, results='asis', eval=!(eval_single_Cond)}
cat(" \n \n")
#Print summary of filter and contrast design
cat("**WARNING:** differential analysis not executed since are identified only 1 sample for the two condition \n ")
cat(" \n")
run_enrich <- run_enrich_universe <- run_STRING <- FALSE
```

```{r print_settings_diff_analysis, warning=FALSE, echo=F, message=FALSE, results='asis', eval=eval_single_Cond}
cat(" \n \n")
#Print summary of filter and contrast design
cat("**Thresholds used:** \n ")
cat(" \n")
cat(paste0("- Fold Change threshold: log2_FC > ",fc_thr," (+), log2_FC < -",fc_thr," (-) "))
cat(" \n")
cat(paste0("- Statistical significance threshold: p.val < ",pval_thr," "))
cat(" \n")
if(signal_thr != -Inf){cat(paste0("- Signal log2 intesity threshold: signal > ",signal_thr," "))}
cat(" \n")

```

```{r diff_analysis,  warning=F, message=F, echo=F, eval=eval_single_Cond}
shiny::setProgress(0.58, detail = "Differential Analysis in progress...")
message("Differentiation analysis in progress...")

c_anno_phos$sample <- str_c(c_anno_phos$sample, "_p")
c_anno_prot$sample <- str_c(c_anno_prot$sample, "_i")
c_anno <- rbind(c_anno_phos,c_anno_prot)

colnames(dat_pep) <- str_c(colnames(dat_pep), "_p")
colnames(dat_gene) <- str_c(colnames(dat_gene), "_i")
dat_gene$genename <- rownames(dat_gene)
dat_pep$genename <- psm_peptide_table[match(rownames(dat_pep),paste(psm_peptide_table$GeneName, 
                                                                    psm_peptide_table$`Annotated Sequence`, 
                                                                    psm_peptide_table$Modifications, sep="_")),"GeneName"]
dat_pep$names <- rownames(dat_pep)
dat_complete <- inner_join(dat_pep, dat_gene)
rownames(dat_complete) <- dat_complete$names
dat_complete <- dat_complete %>% dplyr::select(-c("genename", "names"))

dat_pep <- dat_pep %>% dplyr::select(-c("genename", "names"))

colnames(expr_avgse_pep_df)[1] <- "names"
expr_avgse_pep_df$id <- psm_peptide_table[expr_avgse_pep_df$names,"GeneName"]
expr_avgse_complete_df <- inner_join(expr_avgse_pep_df, expr_avgse_df)
rownames(expr_avgse_complete_df) <- expr_avgse_complete_df$names
expr_avgse_complete_df <- expr_avgse_complete_df %>% dplyr::select(-c("id"))
colnames(expr_avgse_complete_df)[1] <- "id"

#Execution of differentiation analysis using DEqMS for proteins
psm_count_table<-as.data.frame(table(rownames(dat_pep)))
#Make the design
df <- data.frame("p" = unique(sort(str_remove(c_anno_phos$condition, "_p\\b"))), "i" = unique(sort(str_remove(c_anno_prot$condition, "_i\\b"))))
df <- unique(df[match(df$p, df$i),])
df$rule <- str_c(str_c(df$p, "_p"), "-", str_c(df$i, "_i"))
contro_list <- df$rule

contro_list<-c(contro_list,
               str_c(str_c("(", stringi::stri_replace_all_regex(formule_contrast, str_c("\\b",df$p,"\\b"), str_c(df$p, "_p"), vectorize = FALSE), ")"),
                     "-",
                     str_c("(", stringi::stri_replace_all_regex(formule_contrast, str_c("\\b",df$p,"\\b"), str_c(df$p, "_i"), vectorize = FALSE), ")"))
               )
names(contro_list) <- make.names(c(str_c(df$p,"_PhosphoEnr"), names(formule_contrast)), unique = T)

if(length(contro_list) > 0){
  deps_pep_df <- limmafnc(type="PEP",c_anno = c_anno,dat_gene = dat_complete,psm_count_table = psm_count_table,contro_list = contro_list,expr_avgse_df = as.data.frame(expr_avgse_complete_df),signal_thr,fc_thr, pval_thr, pval_fdr)
}
deps_pep_l_df<-deps_pep_df$degs_l_df
deps_pep_w_df<-deps_pep_df$degs_w_df
toPrint_pep<-deps_pep_w_df

#Prepare the README
readme_sheet <- data.frame("INFO"=c(NA,
                                "Excel file containing the results of differential analysis, according to the contrasts defined in the Design file.",
                                NA,
                                "Annotation columns:",
                                "1. *Accession*: protein UniprotID,",
                                "2. *Description*: protein description,",
                                "3. *GeneName*: Gene Symbol,",
                                "4. *Peptide_Sequence*: peptide sequence,",
                                "5. *Peptide_Modifications*: peptide modifications,",
                                "6. *Peptide_Position*: start and end position of the peptide within the protein sequence, defined UniprotID,",
                                NA,
                                "And for each comparison:",
                                "8. *class*: defined according to the fold change, p-value and abundance thresholds specified in the input: \"+\" up-regulated protein/peptide, \"-\" down-regulated protein/peptide, \"=\" invariant protein/peptide",
                                "9. *log2_FC*: protein/peptide log2 transformed fold change",
                                    "10. *FC*: protein/peptide fold change",
                                    "11. *p_val*: protein/peptide contrast p-value",
                                    "12. *p_adj*: protein/peptide adjusted p-value (FDR after BH correction)"
                              ))

#Export table with SE e MEAN
peptide_DE <- left_join(rownames_to_column(psm_peptide_table), toPrint_pep, by=c("rowname" = "id"))[,-c(1)]
colnames(peptide_DE)[1:7] <- c("Accession","Description","GeneName","Peptide_Sequence","Peptide_Modifications","Peptide_Position","Peptide_Tryptic")
df_to_save<-list("README"=readme_sheet,
                 "PhosphoProteome_DE"=peptide_DE)
writexl::write_xlsx(df_to_save,paste0(dirOutput,subfold_Tab,"differential_expression.xlsx"))

formule_contrast <- contro_list
#Prepare color
col_sigle_contrast <- data.frame("color_constrast"=c_anno[match(df$p, str_remove(c_anno$condition, "_p\\b|_i\\b")),"color"], "color_constrast_dark"=c(""), row.names = paste0(df$p, "_PhosphoEnr"))
for(col in rownames(col_sigle_contrast)){
  col_sigle_contrast[col,"color_constrast_dark"]<-darker.col(col_sigle_contrast[col,"color_constrast"])
}
color_constrast<-rbind(color_constrast,col_sigle_contrast)

remove(deps_df,toPrint,deps_pep_df,toPrint_pep,df_to_save, peptide_DE)
message("Differentation analysis DONE.")
```

### 2.1. Differential expression contrasts
The following table contains the names and the formulas of the contrasts considered for differential phosphorylation analysis.

The conditions from the phospho-proteomics are represented by an **_p** at the end of the condition, the **_i** represent the conditions from the proteomics. Also, the comparison provided in input by the user are adapted for the differential phosphorylation analysis.

```{r print_settings_design, warning=FALSE, echo=F, message=FALSE, results='asis', eval=eval_single_Cond}
cat("**Contrast design formulas:** ")
cat(" \n")
kable(data.frame("Name"=names(formule_contrast), "Formula"=formule_contrast), row.names = F)
cat(" \n")
```

```{r number_deps, warning=FALSE, echo=FALSE, results='asis'}
# Plot DEPs barplot (as a double barplot)
cat(" \n \n")
cat("#### 2.2. Number of differentially phosphorylated peptides for each comparison  \n")
#Execute only if found at least one gene differentiated

#Peptides
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat(" \n \n")
  lolli_df <- data.table("comp"=deps_pep_l_df$comp[which(deps_pep_l_df$class == "+" | deps_pep_l_df$class == "-")], 
                       "class"=factor(deps_pep_l_df$class[which(deps_pep_l_df$class == "+" | deps_pep_l_df$class == "-")]))
  lolli_df <- lolli_df[ , .(N = .N), by=c("comp","class")]
  lolli_df$id <- str_c(lolli_df$comp, lolli_df$class, sep="_")
  
  col_vec<-as.vector(t(color_constrast))
  names(col_vec)[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]]<-paste0(lolli_df$comp[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]], "_+")
  names(col_vec)[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 0]]<-paste0(lolli_df$comp[(1:length(lolli_df$comp))[(1:length(lolli_df$comp))%%2 == 1]], "_-")
  
  pDEPs<-deps_b2b_lollipop(input_df=lolli_df, 
                           break_vec=seq(0,plyr::round_any(max(lolli_df$N)*1.2, if(max(lolli_df$N)>90){100}else{10}, f = ceiling),
                                         round((plyr::round_any(max(lolli_df$N)*1.2, if(max(lolli_df$N)>90){100}else{10}, f = ceiling))/5, 0)), 
                           fill_vec = col_vec, 
                           color_vec = col_vec, 
                           char_max = 30, shape_vec = c(16,21), position_dodge = 0)
  
  print(pDEPs)
  cat(" \n \n")

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_expr,"DE_peptide_barplot.pdf"), pDEPs, device=cairo_pdf, units = c("in")))
  remove(pDEPs,cmd,mds_cmdscale)
}else{
  message("No gene differentiated discovered.")
  cat("No gene differentiated discovered.")
}

shiny::setProgress(0.60, detail = "Count DEPs...")
```

```{r volcano_pep, fig.height=6, fig.width=6, warning=FALSE, echo=FALSE, results='asis'}
cat(" \n \n")
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){

  plotlist = list()
  
  for(comp in unique(deps_pep_l_df$comp)){
    col <- if(pval_fdr){"p_adj"}else{"p_val"}
    input_df <- na.omit((deps_pep_l_df[which(deps_pep_l_df$comp == comp),])[order(deps_pep_l_df$id),])
    input_df$id <- psm_peptide_table[input_df$id, "GeneName"]
    input_df$log2_FC <- round(input_df$log2_FC, digits = 2)
    input_df[,col] <- round(-log10(input_df[,col]), digits = 2)

    cmd<-ggplot(data=input_df, aes(x=log2_FC, y=if(pval_fdr){p_adj}else{p_val}, col=class, text = paste('</br>Gene: ', id,
                      '</br>Class: ', class,
                      '</br>Log2_FC: ', log2_FC,
                      '</br>',if(pval_fdr){"P_adj"}else{"P_val"},': ',if(pval_fdr){p_adj}else{p_val}))) +
      geom_point(pch=20,cex=2) +
      geom_hline(yintercept=-log10(pval_thr), col="black") +
      geom_vline(xintercept=c(-fc_thr, fc_thr), col="black") +
      ggtitle(paste0("Volcano Plot of ",comp)) +
      ylab(if(pval_fdr){"-log10(fdr)"}else{"-log10(p_val)"}) +
      scale_color_manual(values=c("+"=color_constrast[comp,"color_constrast"], "-"=color_constrast[comp,"color_constrast_dark"], "="="grey70")) +
      scale_x_continuous(limits = c(min(-max(abs(input_df$log2_FC)),-3), max(max(abs(input_df$log2_FC)),3))) +
      scale_y_continuous(limits = c(0, max(max(abs((if(pval_fdr){input_df$p_adj}else{input_df$p_val}))),4))) +
      theme_bw(base_size = bs, base_family = bf)

    col <- if(pval_fdr){"p_adj"}else{"p_val"}
    labels <- c((input_df %>% filter(class == '+'))[order(-(input_df %>% filter(class == '+'))[,"log2_FC"], (input_df %>% filter(class == '+'))[,col]),][1:5,"id"],
                (input_df %>% filter(class == '-'))[order((input_df %>% filter(class == '-'))[,"log2_FC"], (input_df %>% filter(class == '-'))[,col]),][1:5,"id"])
    
    a <- list()
    for (i in seq_len(length(labels))) {
      m <- labels[i]
      a[[i]] <- list(
        x = input_df[which(input_df$id %in% m),"log2_FC"],
        y = (input_df[which(input_df$id %in% m), col]),
        text = m,
        xref = "x",
        yref = "y",
        showarrow = TRUE,
        arrowhead = 0.5,
        ax = 20,
        ay = -40
      )
    }
    plotlist[[comp]] = ggplotly(cmd, tooltip = c("text"))
  }
shiny::setProgress(0.65, detail = "Perform volcano plot...")
}

cat("#### 2.3.2. Volcano plot of Peptides {.tabset}  \n")
cat(" \n \n")
in_tabs(plotlist, labels = names(plotlist), level = 4L)
cat(" \n \n")

```

```{r MDS_deps_pep, warning=F, message=F, echo=F, eval=T, results='asis'}
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat("#### 2.4. MDS based on differentially phosphorylated peptides {.tabset}  \n " )
  cat("Multidimensional scaling (MDS) are performed on normalized abundances of differentially phosphorylated peptides. \n")
  cat(" \n \n")  #Select only genes that are differentiated and print PCA of samples
  #Select only genes that are differentiated and print PCA of samples
  deps_vec_all<- deps_pep_l_df %>% dplyr::filter(class!="=") %>%
                    pull(id) %>% unique() %>% sort()

  sample_data<-t(dat_pep[(deps_vec_all),])

  sample_distances <- dist(sample_data, method = "euclidean")

  mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
  colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
  mds_cmdscale$sample <- rownames(mds_cmdscale)

  mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno_phos))
  #Take correct order of color
  cc<-mds_cmdscale$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
    names(cc)<-unique(mds_cmdscale$condition)
  } else{
    names(cc)<-mds_cmdscale$condition
  }
  cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
    geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
    geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
    scale_colour_manual(values=cc[unique(names(cc))]) +
    theme_bw(base_size = bs, base_family = bf) +
    theme(legend.position = "right", panel.grid.minor=element_blank())

  print(cmd)

  ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"DE_mds_peptide.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in"))

shiny::setProgress(0.69, detail = "Perform MDS...")
}

```

```{r pca_deps, warning=F, message=F, echo=F, results='asis'}
cat(" \n \n")
cat("#### 2.5. PCA based on differentially phosphorylated peptides {.tabset}  \n")
cat("Principal component analysis (PCA) are performed on normalized abundances of differentially phosphorylated Peptides. \n")
cat(" \n \n")

cat(" \n \n")
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  #Peptides
  deps_vec_all<- deps_pep_l_df %>% dplyr::filter(class!="=") %>%
    pull(id) %>% unique() %>% sort()
  
  # sample_data<-t(dat_gene[toupper(deps_vec_all),])
  sample_data<-t(dat_pep[(deps_vec_all),])
  apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
  pc <- apca_prot$x[,1:2]
  
  pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
  pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
  pc<- merge(c_anno_phos, pc, by.x = "sample", by.y = "row.names")
  pc$condition <- as.factor(pc$condition)
  
  ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
  ve <- ve[c(1, 2)]
  labs <- paste0(colnames(pc)[c(ncol(pc)-1,ncol(pc))], " (", round(ve * 100, 2), "%)")
  
  #Take correct order of color
  cc<-pc$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(pc$condition))]
    names(cc)<-unique(pc$condition)
  } else{
    names(cc)<-pc$condition
  }
  #ggplot method
  p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
    geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
    geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
    scale_colour_manual(values=cc[unique(names(cc))]) +
    theme_bw(base_size = bs, base_family = bf) +
    theme(legend.position = "right", panel.grid.minor=element_blank()) +
    xlab(labs[1]) +
    ylab(labs[2])
  
  print(p1)
  cat(" \n \n")
  
  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,subfold_MDSPCA,"DE_pca_peptide.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))
  
  remove(sample_data,sample_distances,mds_cmdscale,p1)
}

```


```{r enrichment_universe,message=F, warning=F,echo=F, eval=run_enrich_universe, results='asis'}
shiny::setProgress(0.75, detail = "Enrichment in progress whole Universe in background... \n Can require several minutes...")

message("Enrichment in progress whole Universe in background... \n Can require several minutes...")
#Perform enriched analysis with EnrichR
dbs<-NULL
if(enrichR_DB){
  dbs<-enrich_filter_DBs
}

p = callr::r_bg(
  func = function(g, pval_fdr_enrich, pval_enrich_thr,overlap_size_enrich_thr,dbs) {
    source("functions_2021.R")
    enrichRfnc_universe(g, pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr,dbs)
  },
  args = list(unique(psm_peptide_table[deps_pep_l_df[which(deps_pep_l_df$comp %in% names(formule_CORAL)), "id"], "GeneName"]), pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr, dbs),
  stdout = "|",
  stderr = "|",
  error = getOption("callr.error", "error")
)

```

```{r enrichment_sms,message=F, warning=F,echo=F, eval=run_enrich, results='asis'}
shiny::setProgress(0.75, detail = "Enrichment in progress... \n Can require several minutes...")
cat(" \n \n")
cat("## 3. Functional enrichment analysis \n")
cat("Annotation enrichment analysis is performed using the web-based application [EnrichR](https://maayanlab.cloud/Enrichr/), against an updated collection of 98 databases covering Transcription, Pathways, Ontologies, Diseases, Drugs, Cell Types, Experimental Datasets. \n \n ")
cat("For each comparison enrichment is calculate over up-regulated proteins (UP), down-regulated proteins (DOWN), and their union (ALL). \n")
cat(" \n")
cat(paste0("- Statistical significance threshold: p.val < ",pval_enrich_thr," "))
cat(" \n")
cat(paste0("- Overlap size threshold for enrichment analysis: OverlapSize > ",overlap_size_enrich_thr," "))
cat(" \n")
if(run_enrich_universe){cat("- Execution of the enrichmentalso on all detected proteins.")}
def_val_height=  knitr::opts_chunk$get("fig.height")
message("Enrichment step with EnrichR in proress...")
```

```{r enrichment,message=F, warning=F,echo=F, eval=run_enrich, results='hide'}
doNextChunk <- tryCatch({
  dbs<-NULL
  if(enrichR_DB){
    dbs<-enrich_filter_DBs
  }
  deps_pep_l_df$id<- psm_peptide_table[deps_pep_l_df$id, "GeneName"]
  #Perform enriched analysis with EnrichR
  enr_df<-enrichRfnc(deps_pep_l_df[which(deps_pep_l_df$comp %in% names(formule_CORAL)),], pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr, dbs)
  #Save in RData for possible further analysis
  enrich_df<-enr_df[which(enr_df$Significant == "TRUE" & enr_df$overlap_size>=overlap_size_enrich_thr),c(1:13)]
  save(enrich_df, file=paste0(dirOutput,subfold_Dat,"enrichment_DE.RData"))

  #Prepare the README
  readme_sheet <- data.frame("INFO"=c(   NA,
                                "Excel file containing a selection of enrichment results starting from differentially expressed proteins. 
                                Terms are selected according to significance thresholds specified in the input (Default: adj.P.Value < 0.05, Overlap Size >= 5)",
                                NA,
                                "Enrichment columns:",
                                "1. *input_name*: comparison name,",
                                "2. *anno_name*: enriched name term,",
                                "3. *anno_class*: dataset,",
                                "4. *overlap_sive*: DEPs in term,",
                                "5. *p_value*: p-value,",
                                "6. *fdr*: adjusted p-value (FDR after BH correction),",
                                "7. *odds_ratio*: ",
                                "8. *combined_score*: combined score provide by EnrichR,",
                                "9. *input_size*: DEPs of the comparison,",
                                "10. *anno_size*: number protein of the term,",
                                "11. *overlap_input_ratio*: overlap_size/input_size",
                                "12. *overlap_anno_ratio*: overlap_size/anno_size",
                                "13. *overlap_ids*: gene symbols identified in the term"
                              ))
  writexl::write_xlsx(enrich_df,
                      path = paste0(dirOutput,subfold_Tab,"enrichment_DE.xlsx"))
  remove(enrich_df)

  dir.create(file.path(dirOutput,subfold_Fig,subfold_enrich), showWarnings = FALSE)
  dirOutput_enr=paste0(dirOutput,subfold_Fig,subfold_enrich)
  #LOAD category EnrichR
  dbs_default <- read_tsv("dbs_enrichR.txt", col_names = FALSE) %>% as.data.frame()
  dbs_category <- dbs_default %>% split(f = as.factor(.$X2))
  TRUE
},
error=function(cond){
  print("\n ERROR: An error occur when connect to EnrichR. \n ")
  FALSE
})
message("Enrichment DONE.")
shiny::setProgress(0.77, detail = "Done Enrichment...")
knitr::opts_chunk$set(comment = NA)
```


```{r enrichment_plots_all, echo=F, message=F, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  #Select DEPs in the DBs of interest
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  #Select the ALL column (UP union DOWN)
  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
}
```

```{r enrichment_plots_all_2, echo=F, message=FALSE, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% intersect(unique(enr_sele_df$anno_class), enrich_filter_DBs))})

  #Print the plot
  col_vec<-as.vector(t(color_constrast[unique(str_remove(enr_sele_df$input_name, "_all\\b")),"color_constrast"]))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                           size_col="log2_OR",
                           color_col="input_name",
                           color_vec = col_vec,
                           shape_vec=c(16,21),
                          shape_col = "Significant",
                          fill_col = "Significant",
                           char_max=60) +guides(color=F, shape = guide_legend(override.aes = list(size=4)))
    }
  }    

  tryCatch({
    cat("#### 3.1. Top enrichments in selected annotation databases (ALL). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
    cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
    cat("**Differentially expressed proteins (ALL)** \n ")
    cat(" \n \n")
    
    for(db in names(plotlist)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), "anno_name"]))*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist)){
      name_list[db]<-paste0(dirOutput_enr,"enr_DE_keysources_",db,".pdf")
      ggsave(name_list[db], plotlist[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_DE_keysources.pdf"))
    unlink(name_list)
    remove(plotlist, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.77, detail = "Plotting enrichment results...")
```

```{r enrichment_plots, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  #Select DEPs in the DBs of interest
  #Filter the DEPs taking only the ones from the desired DBs
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  !str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  #Select the results divided in up and down
  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
}
```

```{r enrichment_plots_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% intersect(unique(enr_sele_df$anno_class), enrich_filter_DBs))})
  col_vec<-as.vector(t(color_constrast[unique(str_remove(enr_sele_df$input_name, "_up\\b|_down\\b")),]))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist2 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      
      plotlist2[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                              size_col="log2_OR",
                                              color_col="input_name",
                                              color_vec=col_vec,
                                              shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                                              shape_col = "Group",
                                              fill_col = "Significant",
                                              char_max=60) + 
        guides(color=F, shape = guide_legend(override.aes = list(shape = c(16,21),size=4), title = "Significant"), fill=F)
    }
  }
  
  
  tryCatch({
    cat("#### 3.2. Top enrichments in selected annotation databases (UP,DOWN). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
    cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
    cat("**Up-regulated and down-regulated proteins (UP,DOWN)** \n ")
    cat(" \n \n")
    for(db in names(plotlist2)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist2[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), "anno_name"]))*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist2)){
      name_list[db]<-paste0(dirOutput_enr,"enr_updown_keysources_",db,".pdf")
      ggsave(name_list[db], plotlist2[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_updown_keysources.pdf"))
    unlink(name_list)
    remove(plotlist2, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.79, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_all_terms, echo=F, message=F, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  lookup_words<-enrich_filter_term

  enr_sele_names<-NULL
  #For each pattern search in DEPs name
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_terms_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% unique(enr_sele_df$anno_class))})
  col_vec<-as.vector((color_constrast[unique(str_remove(enr_sele_df$input_name, "_all\\b")),"color_constrast"]))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist3 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist3[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                              size_col="log2_OR",
                                              color_col="input_name",
                                              color_vec = col_vec,
                                              shape_vec=c(16,21),
                                              shape_col = "Significant",
                                              fill_col = "Significant",
                                              char_max=60) + guides(color=F, shape = guide_legend(override.aes = list(size=4)))
    }
  }
  tryCatch({
    cat("#### 3.3. Top enrichments based on selected keywords (ALL). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
    cat("The dot plots shows the top significant terms containing selected keywords. \n")
    cat("Differentially expressed proteins (ALL) \n")
    cat("**List of terms to search:**")
    cat(" \n")
    cat(paste(enrich_filter_term, collapse=", "))
    
    cat(" \n \n")
    for(db in names(plotlist3)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist3[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), c("anno_name","anno_class")])[,"anno_name"])*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist3)){
      name_list[db]<-paste0(dirOutput_enr,"enr_DE_keywords_",db,".pdf")
      ggsave(name_list[db], plotlist3[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_DE_keywords.pdf"))
    unlink(name_list)
    remove(plotlist3, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.82, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_terms, echo=F, message=F, warning=F, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){

  lookup_words<-enrich_filter_term
  enr_sele_names<-NULL

  #For each patter we want, search in each DEPs name to find it
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        !str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_terms_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk&(!run_enrich_universe), results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% unique(enr_sele_df$anno_class))})
  col_vec<-as.vector(t(color_constrast[unique(str_remove(enr_sele_df$input_name, "_up\\b|_down\\b")),]))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist4 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist4[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                              size_col="log2_OR",
                                              color_col="input_name",
                                              color_vec=col_vec,
                                              shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                                              shape_col = "Group",
                                              fill_col = "Significant",
                                              char_max=60)  + guides(color=F, shape = guide_legend(override.aes = list(shape = c(16,21),size=4), title = "Significant"), fill=F)
    }
  }
  tryCatch({
    cat("#### 3.4. Top enrichments based on selected keywords (UP,DOWN). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
    cat("The dot plots shows the top significant terms containing selected keywords \n")
    cat("Up-regulated and down-regulated proteins (UP,DOWN) \n")
    cat("**List of terms to search:**")
    cat(" \n")
    cat(paste(enrich_filter_term, collapse=", "))
    cat(" \n \n")
    for(db in names(plotlist4)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist4[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), c("anno_name","anno_class")])[,"anno_name"])*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist4)){
      name_list[db]<-paste0(dirOutput_enr,"enr_updown_keywords_",db,".pdf")
      ggsave(name_list[db], plotlist4[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_updown_keywords.pdf"))
    unlink(name_list)
    remove(plotlist4, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.85, detail = "Plotting enrichment results...")
```


```{r enrichment_universe_get, message=F, warning=F,echo=F, eval=run_enrich_universe, results='asis'}
shiny::setProgress(0.77, detail = "Enrichment in progress whole Universe in background... \n Can require several minutes...")

#Wait 10 minutes. If do not end in 10 minutes, kill the process
hide_res<-p$read_output()
p$wait(30000)
for (i in 1:15) {
  p$read_output()
  p$wait(1000*60)  
}

if(p$is_alive() | is.null(p$get_result())){
  p$kill()
  print("\n ERROR: An error occur when connect to EnrichR for the enrichemnt of the whole universe of the experiment. \n ")
  run_enrich_universe <- FALSE
} else{
  enr_df_universe<-p$get_result()
  p$kill()
  #Save in RData for possible further analysis
  enrich_all_df <- (enr_df_universe %>% dplyr::filter(Significant == "TRUE", overlap_size>=overlap_size_enrich_thr))[,c(1:13)]
  save(enrich_all_df, file=paste0(dirOutput,subfold_Dat,"enrichment_allproteins.RData"))

  writexl::write_xlsx(enrich_all_df,
                      path = paste0(dirOutput,subfold_Tab,"enrichment_allproteins.xlsx"))
  remove(enrich_all_df)

  message("Enrichment whole universe DONE.")
}
shiny::setProgress(0.79, detail = "Done Enrichment of universe...")

```

```{r enrichment_plots_all_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}
if(length(enrich_filter_DBs) > 0){
  #Select DEPs in the DBs of interest
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  #Select the ALL column (UP union DOWN)
  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_DBs) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% intersect(unique(enr_sele_df$anno_class), enrich_filter_DBs))})
  #Print the plot
  col_vec<-as.vector(c(na.omit(color_constrast[unique(str_remove(enr_sele_df$input_name, "_all\\b")),"color_constrast"]), "grey50"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                             size_col="log2_OR",
                                             color_col="input_name",
                                             color_vec = col_vec,
                                             shape_vec=c(16,21),
                                             shape_col = "Significant",
                                             fill_col = "Significant",
                                             char_max=60) +guides(color=F, shape = guide_legend(override.aes = list(size=4)))
    }
  }    
  
  tryCatch({
    cat("#### 3.1. Top enrichments in selected annotation databases (ALL). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
    cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
    cat("**Differentially expressed proteins (ALL)** \n ")
    cat(" \n \n")
    
    for(db in names(plotlist)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), "anno_name"]))*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist)){
      name_list[db]<-paste0(dirOutput_enr,"enr_DE_keysources_",db,".pdf")
      ggsave(name_list[db], plotlist[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_DE_keysources.pdf"))
    unlink(name_list)
    remove(plotlist, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}


shiny::setProgress(0.79, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}
if(length(enrich_filter_DBs) > 0){
  #Filter the DEPs taking only the ones from the desired DBs
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  Significant == "TRUE",
                  !str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  #Select the results divided in up and down
  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all") | str_ends(input_name,"Universe_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}
if(length(enrich_filter_DBs) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% intersect(unique(enr_sele_df$anno_class), enrich_filter_DBs))})
  col_vec<-as.vector(c(t(color_constrast[unique(str_remove(enr_sele_df$input_name, "_up\\b|_down\\b")),]), "grey50"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist2 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      
      plotlist2[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                                              size_col="log2_OR",
                                              color_col="input_name",
                                              color_vec=col_vec,
                                              shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                                              shape_col = "Group",
                                              fill_col = "Significant",
                                              char_max=60) + 
        guides(color=F, shape = guide_legend(override.aes = list(shape = if("Universe_all" %in% enr_sele_df$input_name){c(17,24,16)}else{c(17,24)},size=4), title = "Significant"), fill=F)
    }
  }
  
  tryCatch({
    cat("#### 3.2. Top enrichments in selected annotation databases (UP,DOWN). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n ")
    cat("The dot plots shows the top significant terms considering selected annotation databases. \n ")
    cat("**Up-regulated and down-regulated proteins (UP,DOWN)** \n ")
    cat(" \n \n")
    for(db in names(plotlist2)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist2[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), "anno_name"]))*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist2)){
      name_list[db]<-paste0(dirOutput_enr,"enr_updown_keysources_",db,".pdf")
      ggsave(name_list[db], plotlist2[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_updown_keysources.pdf"))
    unlink(name_list)
    remove(plotlist2, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}


shiny::setProgress(0.79, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_all_terms_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}
if(length(enrich_filter_term) > 0){

  lookup_words<-enrich_filter_term
  enr_sele_names<-NULL
  #For each pattern search in DEPs name
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_terms_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_term) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% intersect(unique(enr_sele_df$anno_class), enrich_filter_DBs))})
  col_vec<-as.vector(c(na.omit(color_constrast[unique(str_remove(enr_sele_df$input_name, "_all\\b")),"color_constrast"]), "grey50"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist3 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist3[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                         size_col="log2_OR",
                         color_col="input_name",
                         color_vec = col_vec,
                         shape_vec=c(16,21),
                         shape_col = "Significant",
                         fill_col = "Significant",
                         char_max=60) + guides(color=F, shape = guide_legend(override.aes = list(size=4)))
    }
  }
  tryCatch({
    cat("#### 3.3. Top enrichments based on selected keywords with Universe background (ALL). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
    cat("The dot plots shows the top significant terms containing selected keywords. \n")
    cat("Differentially expressed proteins (ALL) \n")
    cat("**List of terms to search:**")
    cat(" \n")
    cat(paste(enrich_filter_term, collapse=", "))

    cat(" \n \n")
    for(db in names(plotlist3)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist3[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), c("anno_name","anno_class")])[,"anno_name"])*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist3)){
      name_list[db]<-paste0(dirOutput_enr,"enr_DE_keywords_",db,".pdf")
      ggsave(name_list[db], plotlist3[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_DE_keywords.pdf"))
    unlink(name_list)
    remove(plotlist3, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.82, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_terms_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}
if(length(enrich_filter_term) > 0){

  lookup_words<-enrich_filter_term
  enr_sele_names<-NULL

  #For each patter we want, search in each DEPs name to find it
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(Significant == "TRUE",
                                        overlap_size>=overlap_size_enrich_thr,
                                        !str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all") | str_ends(input_name,"Universe_all"))
  enr_sele_df$Group <- str_to_upper(str_remove_all(stri_extract_last_regex(str = enr_sele_df$input_name, pattern = "_up$|_down$|_all$"),"_"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_terms_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_term) > 0){
  category_db <- lapply(dbs_category, function(x){filter(x, x[,1] %in% unique(enr_sele_df$anno_class))})
  col_vec<-as.vector(c(t(color_constrast[unique(str_remove(enr_sele_df$input_name, "_up\\b|_down\\b")),]), "grey50"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  plotlist4 = list()
  
  for (db in names(category_db)) {
    if(nrow(category_db[[db]]) > 0){
      enr_sele_df_db <- enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),]
      plotlist4[[db]] <- enrichment_dotmatrix(enr_sele_df_db,
                         size_col="log2_OR",
                         color_col="input_name",
                         color_vec=col_vec,
                           shape_vec=c("DOWN"=25,"UP"=24,"ALL"=21),
                          shape_col = "Group",
                           fill_col = "Significant",
                                              char_max=60)  + guides(color=F, 
                                                                     shape = guide_legend(override.aes = list(shape = if("Universe_all" %in% enr_sele_df$input_name){c(17,24,16)}else{c(17,24)},size=4), 
                                                                     title = "Significant"), fill=F)
    }
  }
  tryCatch({
    cat("#### 3.4. Top enrichments based on selected keywords with Universe background (UP,DOWN). {.tabset}  \n")
    cat("Significant enrichments (FDR<0.05) are displayed as filled dots, non-significant as empty dots. Point size is proportional to log2 Odds Ratio. \n")
    cat("The dot plots shows the top significant terms containing selected keywords \n")
    cat("Up-regulated and down-regulated proteins (UP,DOWN) \n")
    cat("**List of terms to search:**")
    cat(" \n")
    cat(paste(enrich_filter_term, collapse=", "))
    cat(" \n \n")
    for(db in names(plotlist4)){
      cat(paste0("##### ",db," \n"))
      print(resize_plot(resizePlot = plotlist4[[db]], resizeHeight = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]), c("anno_name","anno_class")])[,"anno_name"])*0.3),3)))
      cat(" \n \n")
    }
    cat(" \n \n")
    name_list<-vector()
    for(db in names(plotlist4)){
      name_list[db]<-paste0(dirOutput_enr,"enr_updown_keywords_",db,".pdf")
      ggsave(name_list[db], plotlist4[[db]], 
             device=cairo_pdf, width = 7, 
             height = max(min(20,length(unique(enr_sele_df[which(enr_sele_df$anno_class %in% category_db[[db]][,1]),
                                                           "anno_name"]))*0.3),3),
             units = c("in"))
    }
    pdf_combine(input = name_list, output = paste0(dirOutput_enr,"enr_updown_keywords.pdf"))
    unlink(name_list)
    remove(plotlist4, name_list, enr_sele_df_db, category_db)
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.85, detail = "Plotting enrichment results...")
```





```{r selection_genes, echo=F, message=F, warning=F, eval=run_STRING, results='asis'}
shiny::setProgress(0.90, detail = "Network analysis in progress... \n Can require several minutes...")
cat(" \n \n")
cat("## 4. Protein-protein interaction network analysis of differentially expressed proteins \n")
cat(paste0("Protein-protein interactions (PPIs) are crucial for understanding cell physiopathology. PPI analysis of differentially expressed proteins is based on the [STRING](https://string-db.org/) database. Only interactions with score > 600 are considered for building the network. Communities within the network are identified with the Clauset-Newman-Moore (CNM) algorithm. \n \n"))
cat("For a better visualization of the network, only the top 500 differential proteins are considered for each contrast.")
#Reset of height of plots
if(run_enrich){knitr::opts_chunk$set(fig.height = def_val_height)}

deps_l_df <- deps_pep_l_df[which(deps_pep_l_df$comp %in% names(formule_CORAL)),]
#Select up- down- regualted genes, if 0 genes are find, the all network analysis is skipped
g_sel_comp<-list()
doComp<-list()
for (comp in unique(deps_l_df$comp)){
  tmp_deps<-deps_l_df[(deps_l_df$class != "=" & deps_l_df$comp == comp), ]
  genes<-(tmp_deps[order(tmp_deps$p_val),])[1:min(500, nrow(tmp_deps)),"id"]
  if(length(genes)>0){g_sel_comp[[comp]]<-unique(vapply(str_split(genes, "_", n = 2), `[`, 1, FUN.VALUE=character(1)))}else{g_sel_comp[[comp]]<-list()}
  if(length(g_sel_comp[[comp]])!=0){doComp[comp]=TRUE}
}
if(length(doComp)==0 | all(doComp==F)){
  doNextChunk_STRING<-FALSE
  print("WARNING: Not possible to continue with the STRING network evaluation. No protein up- or down-regulated.\n")
}else{
  doNextChunk_STRING<-TRUE
  dir.create(file.path(dirOutput,subfold_Fig,subfold_net), showWarnings = FALSE)
  dirOutput_net=paste0(dirOutput,subfold_Fig,subfold_net)
}

shiny::setProgress(0.93, detail = "Network analysis done... \n Can require several minutes...")
```

```{r network_string_communities, echo=F, message=F, warning=F, eval = doNextChunk_STRING, results='hide'}
message("Build PPI network with STRING in progress... \n Can require several minutes...")

rm(cluster_ext, cmd, comm, dat_psm,df_to_save,dt_links,edge_list,el,enr_sele_df,enr_sele_names, matches, mds_cmdscale, psm_anno_df, 
       sample_data, annos, colToKeep, comp, currentTime, dirOutput_1,dirOutput_2, doNextChunk,
       f, filenames, filt_genes, g_sel, genes, l, links, lookup_words, name_list, net_genes, now, res, sample_distances, word,
       batch_annotation,comBat_df_gene, comBat_df_pep, dat_gene_long,dat_pep_long,
       gene_name, input_df, pos, prot_intensity_long, deps_vec_all, i, labels, labels_down, labels_up, list.of.packages,
       list.of.packages.bio, new.packages, prot_find, template_files)
gc()
#Read STRINGdb edges for human
#Human id --> 9606
#Mouse id --> 10090
string_db <- STRINGdb$new(version="11.5", species=taxonomy_NCBI, score_threshold=500, input_directory="STRINGdb/")
gene_name<-unlist(g_sel_comp) %>% unique() %>% as.data.frame()
colnames(gene_name)<-c("gene_id")
string_mapped <- string_db$map(gene_name, "gene_id", removeUnmappedRows = TRUE)
links_string <- string_db$get_interactions(string_mapped$STRING_id)
links_string$from <- string_mapped$gene_id[match(links_string$from,string_mapped$STRING_id)]
links_string$to <- string_mapped$gene_id[match(links_string$to,string_mapped$STRING_id)]
string_gene_df<-data_frame("gene1"=links_string$from,"gene2"=links_string$to,"weigth"=links_string$combined_score)

if(nrow(string_gene_df) > 0){
  data_comms_df<-list()
  data_comms_list<-list()
  data_dt_links<-list()
  colour_vector<-list()
  #Cycle for each contrast
  for (comp in names(doComp)){
    # params ----
    thr_score <- 150 # define max strength of interaction

    #Select genes that are up or down regulated
    g_sel <- g_sel_comp[[comp]]
    if(all(unique(!grepl("[[:lower:]]",string_gene_df$gene1)))){
      g_sel<-toupper(g_sel)
    }else{
      g_sel<-str_to_title(g_sel)
    }
    #Find communities in STRING db
    comm <- suppressMessages(find_communities(g_sel, thr_score,string_gene_df))
    i_comms_df <- comm[["i_comms_df"]]
    data_comms_df[[comp]]<-i_comms_df
    i_comms_list <- comm[["i_comms_list"]]
    data_comms_list[[comp]]<-i_comms_list
    dt_links <- comm[["dt_links"]]
    data_dt_links[[comp]]<-dt_links

    colour_vector[[comp]] <- c(c(brewer.pal(n = 8, name = "Dark2")), color_base)
    colour_vector[[comp]] <- colour_vector[[comp]][1:length(i_comms_list)]
  }

  i_comms_df<-data_comms_df
  i_comms_list<-data_comms_list
  dt_links<-data_dt_links

  message("Network DONE.")
}else{
  print("WARNING: No strong interaction detected beetween the proteins. Usually too few proteins.")
  doNextChunk_STRING <- FALSE
  message("Network incomplete.")
}
shiny::setProgress(0.93, detail = "Generating network figures... \n Can require several minutes...")
```

```{r network_string, echo=F, message=F, warning=F, eval = doNextChunk_STRING, fig.width=12, results='asis'}
message("Plotting STRING network in progress...")
cat("#### 4.1. Size of protein communities within PPI networks  {.tabset}  \n")
cat(" \n \n")

for (comp in names(doComp)){
  scr_thr <-  200# visual
  links <- 2
  # Filter genes and links ----
  net_genes <- g_sel_comp[[comp]]
  if(all(unique(!grepl("[[:lower:]]",string_gene_df$gene1)))){
      net_genes<-toupper(net_genes)
    }else{
      net_genes<-str_to_title(net_genes)
    }
  net_edges <- subset(dt_links[[comp]], from%in%net_genes & to%in%net_genes) #select genes with weight>scr_thr
  net_edges<-net_edges[which(net_edges$weight > mean(net_edges$weight)*0.7),]

  gene_links<-table(c(net_edges$from,net_edges$to))
  filt_genes<-names(gene_links)[which(gene_links >= 2)] #remove isolated genes (leaves)
  net_edges<-subset(net_edges,from %in% filt_genes & to %in% filt_genes)

  net_edges$group_to<-"PP"
  net_edges<-unique(net_edges)
  # Vertices df ----
  gene_vertices<-data.frame(label=filt_genes)
  if(nrow(gene_vertices) != 0){
    rownames(gene_vertices)<-gene_vertices$label

    gene_vertices$Community<-(i_comms_df[[comp]])[as.character(gene_vertices$label),"comm_n"] #class=communities

    nc<-ggplot(gene_vertices, aes(x=Community, fill=Community)) +
        geom_bar(alpha=0.9, colour="white", width=0.4)+
        scale_x_discrete()+
        scale_fill_manual(values=colour_vector[[comp]], drop=FALSE)+
        theme_bw(base_size = bs) +
        labs(x = "Community", y = "# genes") +
        theme(legend.position = "none", panel.grid.major.x = element_blank(),
              panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank())+
        ggtitle("Number of genes in each community", subtitle = paste0("Communities of condition: ",comp))

    cat("##### ",comp," \n")
    print(nc)
    cat(" \n \n")
    ggsave(paste0(dirOutput_net,gsub(comp, pattern = "\\/", replacement="vs"),"_communities_sizes.pdf"), nc, device=cairo_pdf, width = 4, height = 4, units = c("in"))

    write_tsv(data.frame("GeneSymbol"=gene_vertices$label, "Community"=gene_vertices$Community), 
              file = paste0(dirOutput_net,gsub(comp, pattern = "\\/", replacement="vs"),"_communities_sizes.txt"))
     
    # #BUILD NETWORK      
    tb = tibble(v = c(net_edges$from, net_edges$to))
    d = as.vector(table(tb$v))
    nodes = mutate(gene_vertices, Degree = d)
    
    g <- graph_from_data_frame(net_edges, directed=TRUE, vertices=nodes)
    
    layouts <- if(length(nodes$label) > 400){c("kk")}else{c("fr","kk")}
    p = callr::r_bg(
      func = function(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts) {
        source("functions_2021.R")
        plot_networks(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts)
      },
      args = list(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts),
      stdout = "|",
      stderr = "|",
      error = getOption("callr.error", "error")
    )
    p$wait()
    
    cat(" \n \n")
    rm(net_genes, net_edges, gene_links, filt_genes, net_edges, gene_vertices, nc, net_net, 
           node_list_from, node_list_to, node_list, edge_list, g, name_list, l_list)
    gc()
  }
}

net_pdf<-list.files(dirOutput_net, pattern = "network.pdf", full.names = T)
if(length(net_pdf) > 0){
	cat("\n \n")
	message("Networking with STRING DONE")
	cat("\n \n")
	cat("#### 4.2. Network plots \n ")
	cat("\n \n Results inside folder: *network*")
	cat("\n ")
	cat("\n \n The networks are not reported in this report. For each comparison, a 2-page pdf file is created inside the network folder. \n \n \n ")
	cat("Below is reported an example of the first comparison written in the *Design* file with layout Kamada-Kawai (KK)")
	cat(" \n \n")
  	image_read_pdf(net_pdf[1], pages = pdf_info(net_pdf[1])$pages)
}else{
  cat("\n \n")
  cat("WARNING: Cannot be possible generate networks \n ")
}
message("Cleaning...")

shiny::setProgress(0.90, detail = "Network figures generated...")
```


```{r kinase_tree_CORAL, echo=F, message=F, warning=F, eval=run_kinaseTree, results='asis'}
shiny::setProgress(0.90, detail = "Kinase identification and Kinase draw in progress... \n Can require several minutes...")
cat(" \n \n")
cat("## 5. Kinase Trees  {.tabset}  \n")
cat("In this step, PhosProTN identifies alterations in the activity of kinases, based on the differentially phosphorylated sites observed in each contrast. The identification of the altered kinases is perfomed by [PhosR](https://github.com/PYangLab/PhosR) package (Kim et al. 2021), which provide a score of kinase activities based on the comparison formula provided. The activities of the kinases are saved in txt files inside the KinaseTree folder \n \n In addition, graphical kinase trees are generated using an adapted version of the webtool [CORAL](http://phanstiel-lab.med.unc.edu/CORAL/) (Metz K.S. et al. 2018). \n \n ")
cat((paste0("DISCLAIMER CORAL: The kinome tree plots generated by CORAL make use the data generated by",
                tags$a("Manning et al., Science, 2002",href="http://science.sciencemag.org/content/298/5600/1912.long", target="_blank"),
                " and are based on a figure generated by ",
                tags$a("Cell Signaling Technology",href="https://www.cellsignal.com/contents/science/protein-kinases-introduction/kinases", target="_blank"),
                ".")))
cat("\n \n Results inside folder: *KinaseTree*")
cat(" \n \n ")

dir.create(file.path(dirOutput,subfold_Fig,"kinaseTree/"), showWarnings = FALSE)
dirOutput_kinase=paste0(dirOutput,subfold_Fig,"kinaseTree/")

if(!run_enrich){deps_pep_l_df$id<- psm_peptide_table[deps_pep_l_df$id, "GeneName"]}
kinase_act_phosr_wrapper <- function(comparison) {
  oldwd<-getwd()
  source("functions_2021.R")
  library(PhosR)
  library(pheatmap)
  library(svgPanZoom)
  library(SummarizedExperiment)
  lapply(list.files("PhosR", full.names = T), function(c) {source(c)})
  source("CORAL/global.R")
  source("server.R")
  svg<-kinase_act_phosr(dirOutput_kinase = dirOutput_kinase, formule_CORAL = formule_CORAL, comp = comparison, 
                        dat_pep = dat_pep, deps_pep_l_df = deps_pep_l_df, psm_peptide_table = psm_peptide_table, 
                        c_anno_phos = c_anno_phos, df = df)
  setwd(oldwd)
  svg
}

ncores <- min(detectCores()-2, length(names(formule_CORAL)))
res <- NULL
res <- mclapply(names(formule_CORAL), kinase_act_phosr_wrapper, mc.cores = ncores)
cat(" \n \n")
for(i in 1:length(res)){
  cat(" \n")
  cat(paste0("### ", stri_split_regex(str = res[[i]], pattern = "\\/|\\_kinase")[[1]][7], " \n \n "))
  cat(paste0("![](", res[[i]], ")"), "\n")
  cat(" \n \n")
}

shiny::setProgress(0.95, detail = "Kinase analysis done...")
```

```{r save_df, echo=F, message=F, warning=F, results='hide'}
tryCatch(unlink("enrich_plot.html"))
if(!(eval_single_Cond)){
save(c_anno_phos,
     c_anno,
     color_constrast,
     dat_pep,
     dat_complete,
     psm_peptide_table,
     expr_avgse_pep_df,
     expr_avgse_complete_df,
     formule_CORAL,
     colour_vec,
     bf,
     bs,
     fc_thr, pval_thr, pval_enrich_thr, overlap_size_enrich_thr,
     file = paste0(dirOutput,subfold_Dat,"phosProTN_env_R.RData"))
}else{
save(c_anno_phos,
     c_anno,
     color_constrast,
     dat_pep,
     dat_complete,
     psm_peptide_table,
     deps_pep_l_df,
     df,
     expr_avgse_pep_df,
     expr_avgse_complete_df,
     formule_CORAL,
     colour_vec,
     bf,
     bs,
     fc_thr, pval_thr, pval_enrich_thr, overlap_size_enrich_thr,
     file = paste0(dirOutput,subfold_Dat,"phosProTN_env_R.RData"))
}
remove(list = ls()[-1])
gc()

shiny::setProgress(1, detail = "Saving RData...")
```
