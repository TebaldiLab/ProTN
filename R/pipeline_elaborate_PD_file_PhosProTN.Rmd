---
author: "Gabriele Tom√®, Toma Tebaldi"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  rmdformats::readthedown:
    css: custom_theme_report.css
    df_print: paged
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: true
params:
  doc_title: "Report of integrative pipeline for phospho-proteomics analysis"
  description: NA
  readPD_files: NA
  readMQ_files: NA
  file_input_prot: NA
  file_prot_prot: NA
  file_pep_prot: NA
  file_input_phos: NA
  file_prot_phos: NA
  file_pep_phos: NA
  file_psm_phos: NA
  pval_fdr: NA
  phospho_thr: "75"
  signal_thr: "inf"
  fc_thr: "0.75"
  pval_thr: "0.05"
  batch_corr_exe: NA
  contr_design: NA
  prot_boxplot: NA
  run_enrich: NA
  run_enrich_universe: NA
  run_STRING: NA
  pval_fdr_enrich: NA
  run_kinaseTree: NA
  pval_enrich_thr: "0.05"
  overlap_size_enrich_thr: 5
  enrich_filter_term: NA
  enrich_filter_DBs: NA
  dirOutput: NA
---

```{r settings, message=F, warning=F, echo=F,results='hide'}
shiny::setProgress(0, detail = "Initialize...")  # set progress to 50%
# require("knitr")
# library("rstudioapi")
# library(stringr)
# #find and set the home directory depending on the position of the current Rmd
# PATH_R_FILE<-paste(str_split(getSourceEditorContext()$path, "/")[[1]][1:(length(str_split(getSourceEditorContext()$path, "/")[[1]])-2)],collapse = "/")
# opts_knit$set(root.dir = PATH_R_FILE,
#               dev="cairo.pdf")
# setwd(PATH_R_FILE)
#
# #Create the output directory
# dirOutput_2="../outputResults/"
# dir.create(file.path("./",dirOutput_2), showWarnings = FALSE)
# currentTime = gsub(".*?([0-9]+).*?", "\\1", Sys.time())
# dirOutput_1=paste(currentTime,"/",sep = "")
# dir.create(file.path(dirOutput_2, dirOutput_1), showWarnings = FALSE)
# dirOutput=paste(dirOutput_2,dirOutput_1,sep = "")

dirOutput = params$dirOutput
#Auto-install needed library
list.of.packages <- c("ggrepel","tidyr","ggraph","graphlayouts","RColorBrewer",
                      "scales","igraph","data.table","qpdf","devtools",
                      "corrplot", "data.table", "ggplot2", "ggfortify","lazyeval",
                      "lubridate", "pheatmap", "reshape2","readr", "rlang", "rmdformats",
                      "tibble", "dplyr", "tidyr", "wesanderson","WGCNA","ggbeeswarm","ggthemes")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) suppressMessages(suppressWarnings({install.packages(new.packages, dependencies = T)}))
list.of.packages.bio <- c("biomaRt","DEqMS","STRINGdb",
                          "GO.db", "impute", "preprocessCore", "pvca","sva")
new.packages <- list.of.packages.bio[!(list.of.packages.bio %in% installed.packages()[,"Package"])]
if(length(new.packages)) {
  if (!require("BiocManager", quietly = TRUE))
      install.packages("BiocManager")
  suppressMessages(suppressWarnings({BiocManager::install(new.packages)}))
}
list.of.packages <- c("proBatch", "PhosR")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) {
  suppressMessages(suppressWarnings({devtools::install_github("symbioticMe/proBatch", dependencies = T)}))
  suppressMessages(suppressWarnings({devtools::install_github("PYangLab/PhosR", dependencies = T)}))
}

#Load functions
suppressMessages(suppressWarnings({
  source("functions_2021.R") # new functions 2021
  #Library needed
  library('biomaRt')
  library('PhosR')
  library('DEqMS')
  library(ggrepel) # graphics
  library(tidyr)
  library(dplyr)
  library(tibble)
  library(ggraph)
  library(graphlayouts)
  library(RColorBrewer) # Color palettes
  library(scales) # heatmap colors scales
  library(geomnet) # network plots
  library(igraph) # Network analysis
  library(data.table)
  library(qpdf)
  library(STRINGdb)
  library("proBatch")
  library(ggbeeswarm)
  library(parallel)
  library(readr)
  library(stringi)
  library(stringr)
}))

options(dplyr.summarise.inform = FALSE)

#Set font and size
loadfonts(quiet=T)
bs<-11      # point sizes in ggplot
bf<-"Arial" # font family in ggplot

# Color definition
color_base<-c("dodgerblue2", "#E31A1C", # red
              "green4", "#6A3D9A", # purple
              "#FF7F00", # orange
              "black", "gold1", "skyblue2", "#FB9A99", # lt pink
              "palegreen2","#CAB2D6", #lt purple
              "#FDBF6F", #lt orange
              "#9af7c9","#c0a0e6","#f5939a","#5fefee","#e8d388","#8abdff","#e3bf7a","#48c0f6","#ccb86f","#fafeaf",
              "#04bfe4","#ea92a8","#25cfe9","#ffbb97","#62e8ff","#ffd29b","#8fcbff","#aec87f","#b2c6ff","#aedf9b",
              "#ffb3c8","#81b97c","#ffcef0","#54bcae","#ffcab3","#7dd7ff","#ffe4ad","#81b0da","#ebffc5","#a7a8d5",
              "#bdffd0","#d6d2ff","#9fb282","#a5d8ff","#c9a395","#9bfff7","#ffcbce","#70b6ca","#faffdd","#88b3bc",
              "#d6ffdf","#a3e5ff","#b1ac8f","#ccffff","#b4bb9f","#7eb7a5","#c5dbc3","#a8b9ff","#74dfbc","#f2ace7")
colour_vec<-color_base

all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- difftime(Sys.time(), now)
      # return a character string to show the time
      all_times[[options$label]] <<- res
    }
  }
}))
knitr::opts_chunk$set(time_it = TRUE)

subfold_Fig <- "figures/"
subfold_Dat <- "data/"
subfold_Tab <- "tables/"

shiny::setProgress(0.01, detail = "Initialize...")  # set progress to 50%
```

```{r load_settings, warning=FALSE, echo=F, message=FALSE, results='hide'}
message("Reading options")
# tpm<-getwd()
#Load the excel file with  the basic settings
# input_settings <- tryCatch({suppressMessages({readxl::read_excel("options.xlsx", col_names = F)})},
#                            error=function(cond){stop("Error: \'options.xlsx\' not present in the current folder. Follow the instruction in the README.")})
# input_settings <- input_settings[rowSums(is.na(input_settings)) != ncol(input_settings), ]
# #Read title and description
# bindingIsLocked("params", env = .GlobalEnv)
# unlockBinding("params", env = .GlobalEnv)
# if(!is.na(input_settings$...2[1])){params$doc_title<-input_settings$...2[1]}
description<-params$description
# input_settings<-input_settings[3:nrow(input_settings),]
#Read Platform of previuos quantification
# sw_analysis <-input_settings$...2[1]
# readPD_files <- readMQ_files <- FALSE
# if(sw_analysis == "PD"){ readPD_files <- TRUE
# }else if(sw_analysis == "MQ"){ readMQ_files <- TRUE
# }else { stop("Error: Incorrect plaftorm of quantification inserted. Write \'PD\' for Protein Discovery or \'MQ\' for MaxQuant.")}
readPD_files <- params$readPD_files
readMQ_files <- params$readMQ_files
#Read input directory
# dir_file_input<-input_settings$...2[2]
# filenames_prot<-list(params$file_input_prot, params$file_pep_prot, params$file_prot_prot)
# filenames_phos<-list(params$file_input_phos, params$file_pep_phos, params$file_prot_phos)
#Read input parameters for Limma
phospho_thr=suppressWarnings(parse_double(params$phospho_thr))
if(is.na(phospho_thr)){
  message("Warning: parse error for Phosphorilation accuracy percentage threshold. Set default paramenter to 75%\n")
  phospho_thr <- 75
}
signal_thr=suppressWarnings(parse_double(params$signal_thr))
if(is.na(signal_thr)){signal_thr<- -Inf}
fc_thr=suppressWarnings(parse_double(params$fc_thr))
if(is.na(fc_thr)){
  message("Warning: parse error for Fold Change threshold. Set default paramenter to 0.75\n")
  fc_thr <- 0.75
}
pval_thr=suppressWarnings(parse_double(params$pval_thr))
if(is.na(pval_thr)){
  message("Warning: parse error for P.Value threshold. Set default paramenter to 5%\n")
  pval_thr <- 0.05
}
batch_corr_exe<-as.logical(params$batch_corr_exe)

# save(signal_thr, fc_thr, pval_thr, batch_corr_exe, readMQ_files, readPD_files, file="tmp.RData")
message(params$contr_design)
#Read the design
input_settings<-read_excel_allsheets(params$contr_design)[[1]]
contr_design<-data.frame(t(input_settings[1:nrow(input_settings),]))
contr_design<-data.frame(contr_design[,colSums(is.na(contr_design)) != nrow(contr_design) ])
if(ncol(contr_design) > 0){
  if(any(is.na(contr_design[3,]))){
    contr_design[3,]<-color_base[1:ncol(contr_design)]
  }
  contr_design<-data.frame(t(fill(contr_design, names(contr_design), .direction = "down")))
  contr_design[,2]<-unlist(lapply(contr_design[,2], function(x){ if("-" %in% x){str_replace_all(x,"-","_")}else{x}}))
  formule_contrast<-(contr_design[,1])
  names(formule_contrast)<-contr_design[,2]
  color_constrast<-contr_design[,3]
  names(color_constrast)<-contr_design[,2]

  darker.col = function(color, how.much = 50){
    colorRampPalette(c(color, "black"))(100)[how.much]
  }
  color_constrast_dark<-c()
  for(col in names(color_constrast)){
    color_constrast_dark[col]<-darker.col(color_constrast[col])
  }
  color_constrast<-cbind(color_constrast,color_constrast_dark)
}else{
  stop("Error: At least one contrast design is required for the analysis.")
}

formule_CORAL <- formule_contrast

#Read Proteins List for control boxplot
prot_boxplot<-na.omit(strsplit(params$prot_boxplot, split = "\\;|\\,|\\ |\\; |\\, ")[[1]])
boxplot_prot_exe <- FALSE
if(length(prot_boxplot)>0){ boxplot_prot_exe<-TRUE }
#Read enrich parameter
doNextChunk_STRING <- doNextChunk <- run_enrich <- run_STRING <- run_enrich_universe <- run_kinaseTree <- pval_fdr <- FALSE
pval_fdr_enrich <- TRUE
pval_fdr <- as.logical(params$pval_fdr)
pval_fdr_enrich <- as.logical(params$pval_fdr_enrich)
run_enrich <- as.logical(params$run_enrich)
run_enrich_universe <- as.logical(params$run_enrich_universe)
run_STRING <- as.logical(params$run_STRING)
run_kinaseTree <- as.logical(params$run_kinaseTree)
# save(params, file = "tmp.RData")
pval_enrich_thr <- if(is.null(params$pval_enrich_thr)){0.05
                   }else if(is.double(params$pval_enrich_thr)){params$pval_enrich_thr
                   }else{parse_double(params$pval_enrich_thr)}
if(is.na(pval_enrich_thr)){
  message("Warning: parse error for p-value enrichment threshold. Set default paramenter to 0.05\n")
  pval_enrich_thr <- 0.05
}
overlap_size_enrich_thr=if(is.null(params$overlap_size_enrich_thr)){5
                         }else if(is.integer(params$overlap_size_enrich_thr)){params$overlap_size_enrich_thr
                         }else{parse_double(params$overlap_size_enrich_thr)}
if(is.na(overlap_size_enrich_thr)){
  message("Warning: parse error for Overlap size enrichment threshold. Set default paramenter to 5\n")
  overlap_size_enrich_thr <- 5
}

enrich_filter_term<-if(is.null(params$enrich_filter_term)){list()
}else if(params$enrich_filter_term == ""){list()
}else{na.omit(strsplit(params$enrich_filter_term, split = "\\;|\\,|\\; |\\, ")[[1]])}
enrich_filter_DBs<-if(is.null(params$enrich_filter_DBs)){list()
}else if(is.character(params$enrich_filter_DBs)){ na.omit(params$enrich_filter_DBs)
}else{list()}

remove(input_settings,contr_design,color_constrast_dark)
shiny::setProgress(0.05, detail = "Reading setting...")  # set progress to 50%
```


---
title: `r if(params$doc_title==""){"Report of integrative pipeline for phospho-proteomics analysis"}else{params$doc_title}`
---

`r description`

This report summarize the results obtained during the execution of the integrative pipeline for phospho-proteomics analysis. More results can be found in the folder.

## Details on the output files

- ```report.html```: complete report of the analysis with all pics and results of the enrichment.
- ```Data``` folder: contains the RData for further analysis:
  - ```database_env_R.RData```: RData containing the essential variables for further analysis.
```{r print_descr_enrich3, warning=FALSE, echo=F, message=FALSE, eval=run_enrich, results='asis'}
  cat("  - ```DEPs_enrichment_data.RData```: result of the enrichment made with EnrichR \n")
```
```{r print_descr_enrich_uni3, warning=FALSE, echo=F, message=FALSE, eval=run_enrich_universe, results='asis'}
  cat("  - ```DEPs_enrichment_data_universe.RData```: result of the enrichment on the whole universe of the experiment made with EnrichR \n")
```
- ```Tables``` folder: contains the excel file resulted by the analysis:
  - ```normalised_intensity_table.xlsx```: excel file with the matrix used in the analysis. In sheet *Proteome Normalized intensity* is written the normalized and imputed version of the original intensities of each protein in each sample of the proteomics analysis. In sheet *Phospho-proteome Normalized intensity* is written the normalized and imputed version of the original intensities of each peptide in each sample of the phospho-proteomics analysis. In sheet *Proteome Normalized group by condition* is written the average and the standard deviation of each condition described in the Sample_annotation file for each protein of the proteomics analysis. Where column *avg* is the average of the replicates, column *se* is the standard error, column *Coef_variant* is the coefficient of variant in %. In sheet *Phospho-proteome Normalized group by condition* is written the average and the standard deviation of each condition described in the Sanple_annotation file for each peptide of the phospho-proteomics analysis. Where column *avg* is the average of the replicates, column *se* is the standard error, column *Coef_variant* is the coefficient of variant in %.
  - ```DEPs_table.xlsx```: summary of the result of Limma. In sheet *DEPs_phosphoProteome* describe the differentially expressed proteins. Column description: *Accession* is the UniprotID of protein, column *Description* is the description of protein, *GeneName* is Gene Symbol, *Annotated Sequence* is the sequence of peptides, *Modifications* is the modification that affect the peptides, *Position in Master Proteins* is the UniprotID with the position on the sequence, *tryptic_cond* is the status of the tryptic for each peptide. For each contrast rule are present 5 columns:
    - **class**: is "+" if the protein is up-regulated following the input parameters, "-" if the protein is down-regulated, "=" otherwise
    - **log2_FC**: is the log2 Fold Change of the contrast
    - **p_val**: is the p. value
    - **p_adj**: is the adjusted p. value
    - **log2_expr**: is the signal log2 expression
```{r print_descr_enrich2, warning=FALSE, echo=F, message=FALSE, eval=run_enrich, results='asis'}
  cat("  - ```DEPs_enrichment_table.xlsx```: excel with only the enriched terms with an high significance (Default: adj.P.Value < 0.05, Overlap Size >= 5) \n")
```
```{r print_descr_enrich_uni2, warning=FALSE, echo=F, message=FALSE, eval=run_enrich_universe, results='asis'}
  cat("  - ```DEPs_enrichment_table_universe.xlsx```: excel with only the enriched terms with an high significance (Default: adj.P.Value < 0.05, Overlap Size >= 5) \n")
```
- ```Figures``` folder: contains the pdf figures resulted by the analysis:
  - ```general_mds_phosphoproteome.pdf```: MDS of the samples of the phosphoproteomic analysis.
  - ```general_mds_proteome.pdf```: MDS of the samples of the proteomic analysis.
  - ```general_pca_pohosphoproteome.pdf```: PCA of the samples of the phosphoproteomic analysis.
  - ```general_pca_proteome.pdf```: PCA of the samples of the proteomic analysis.

```{r print_descr_batch, warning=FALSE, echo=F, message=FALSE, eval=batch_corr_exe, results='asis'}
cat("  - ```corrected_mds_phosphoproteomic.pdf```: MDS of the samples by phosphoproteomics after the bacth effect correction \n")
cat("  - ```corrected_mds_proteome.pdf```: MDS of the samples by proteome after the bacth effect correction \n")
```

```{r print_descr_control, warning=FALSE, echo=F, message=FALSE, eval=prot_boxplot, results='asis'}
cat("  - ```boxplot_control_intensity.pdf```: boxplot for the control of the intensities of selected proteins \n")
```

  - ```DEPs_peptides_count_barplot.pdf```: number of DEPs find for each contrast design based on peptides. Dark grey are the down-regulated, light grey are the up-regulated genes.
  - ```DEPs_mds_phosphoproteome.pdf```: MDS of the DEPs discovered.
  - ```DEPs_phosphoproteome_PCA.pdf```: PCA of the DEPs discovered.

```{r print_descr_enrich, warning=FALSE, echo=F, message=FALSE, eval=run_enrich, results='asis'}
cat("  - ```enrich``` directory: plots of the enrichment data under the parameters set \n")  
cat("    - **enrichment_database_filter.pdf**: dot matrix of the enrichment result divided in up- and down-regulated genes. Filtered by the datasets choose in the advanced options. \n")
cat("    - **enrichment_terms_filter.pdf**: dot matrix of the enrichment result divided in up- and down-regulated genes. Filtered by the terms written in the advanced options. \n")
cat("    - **enrichment_database_filter_all.pdf**: dot matrix of the enrichment result combining the up- and down- regulated genes in a single list. Filtered by the datasets choose in the advanced options. \n")
cat("    - **enrichment_terms_filter_all.pdf**: dot matrix of the enrichment result combining the up- and down- regulated genes in a single list. Filtered by the terms written in the
    advanced options. \n")

shiny::setProgress(0.10, detail = "Settings...")
```

```{r print_descr_enrich_uni, warning=FALSE, echo=F, message=FALSE, eval=run_enrich_universe, results='asis'}
cat("  - ```enrich``` directory: the plots of the enrichment data are in the same folder of the normal enrichment \n")  
cat("    - **enrichment_database_filter_universe.pdf**: dot matrix of the enrichment result divided in up- and down-regulated genes of the comparisons compared with the universe. Filtered by the datasets choose in the advanced options. \n")
cat("    - **enrichment_terms_filter_universe.pdf**: dot matrix of the enrichment result divided in up- and down-regulated genes of the comparisons compared with the universe. Filtered by the terms written in the advanced options. \n")
cat("    - **enrichment_database_filter_all_universe.pdf**: dot matrix of the enrichment result combining the up- and down- regulated genes in a single list, comparisons versus background the proteins discovered by the experiment. Filtered by the datasets choose in the advanced options. \n")
cat("    - **enrichment_terms_filter_all_universe.pdf**: dot matrix of the enrichment result combining the up- and down- regulated genes in a single list, comparisons versus background the proteins discovered by the experiment. Filtered by the terms written in the
    advanced options. \n")

shiny::setProgress(0.10, detail = "Settings...")
```

```{r print_descr_STRING, warning=FALSE, echo=F, message=FALSE, eval=run_STRING, results='asis'}
cat("  - ```network``` directory: plots of the up- and down- regulated genes based on STRINGdb. For each contrast design are create 2 files: \n")
cat("    - **community_number_gene_filtered.pdf**: histogram representing the number of genes in each community discovered after a filter on the genes and on the links. \n")
cat("    - **network.pdf**: visual representation of the network discovered in two layouts: *fr* and *kk*. \n")
```

```{r print_descr_KINASE_TREE, warning=FALSE, echo=F, message=FALSE, eval=run_kinaseTree, results='asis'}
cat("  - ```KinaseTree``` directory: Kinase tree generated with CORAL in svg and associated txt file with the activity of each kinase. \n")
```


## Summary parameters and filter thresholds

```{r print_settings, warning=FALSE, echo=F, message=FALSE, results='asis'}
cat(" \n \n")
#Print summary of filter and contrast design
cat("**Threshold used during the analysis:** ")
cat(" \n \n")
cat(paste0("- Phosphorilation accuracy percentage threshold: phos_% > ",phospho_thr,"% "))
cat(" \n")
cat(paste0("- Log2 Fold Change (FC) threshold: FC > ",fc_thr,", FC < -",fc_thr," "))
cat(" \n")
cat(paste0("- P-Value threshold: p.val < ",pval_thr," "))
cat(" \n")
if(batch_corr_exe){cat("- Execution of batch effect correction.")}
cat(" \n")
if(signal_thr != -Inf){cat(paste0("- Signal log2 intesity threshold: signal > ",signal_thr," "))}
cat(" \n")
if(run_enrich){cat(paste0("- P-Value threshold for enrichment analysis: p.val < ",pval_enrich_thr," "))}
cat(" \n")
if(run_enrich){cat(paste0("- Overlap size threshold for enrichment analysis: OverlapSize > ",overlap_size_enrich_thr," "))}
cat(" \n")
if(run_enrich_universe){cat("- Execution of whole universe enrichment.")}
cat(" \n")
if(run_STRING){cat("- Execution of PPI network analysis with STRINGdb.")}
cat(" \n")
if(run_kinaseTree){cat("- Execution of Kinase Tree activation analysis with PhosR and CORAL.")}

shiny::setProgress(0.18, detail = "Reading files...")
```


## 1. Sample Annotation
The table summarize the input samples read in the **Sample_Annotation** file. Each case has:

- a sample name in column **sample**,
- the associated condition of study in column **condition**,
- the color of that sample in column **color**.


```{r load_data_from_PD, eval=readPD_files,echo=F, message=F, warning=F, results='asis'}
message("Reading files from MS...")
read_input_files<-function(type, filenames){
  #Read all files in the input folder
  if(type=="PROT"){template_files=c("Input","pep","prot")}else{template_files=c("Input","pep","prot","psm")}
  input_files<-list("FILES")
  for (f in template_files){
    input_files[f] <- tryCatch({
      read_excel_allsheets(filenames[f][[1]])
      # read_excel_allsheets(paste0(dir_file_input,filenames[which(grepl(f,filenames) & !grepl('~', filenames))]))
    }, error=function(cond){
      stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
    })
  }
  if(type=="PROT"){names(input_files)<-c("dir","Input","PEP","PROT")}else{names(input_files)<-c("dir","Input","PEP","PROT","PSM")}
  message("Data acquired")
  
  
  #Clean files and merge
  colToKeep<-intersect(colnames(input_files$Input), c("File ID","File Name","Condition","Color","Sample","MS_batch"))
  input_files$Input <- input_files$Input[,colToKeep]
  if(!("Condition" %in% colnames(input_files$Input))){ stop("Error: \'Condition\' column missin in \'Input\' file.") }
  if(batch_corr_exe & !("MS_batch" %in% colnames(input_files$Input))){ stop("Error: \'MS_batch\' column missin in \'Input\' file with batch correction activated") }
  
  if(type == "PROT"){
    input_files$Input$Condition <- str_c(input_files$Input$Condition, "_i")
  } else{
    input_files$Input$Condition <- str_c(input_files$Input$Condition, "_p")
  }
  
  input_files$Input$`File Name`<- lapply(input_files$Input$`File Name`,
                                                     function(x){tail(unlist(strsplit(x,"\\",fixed=T)),n=1)})
  
  input_files$Input$`File Name`<-mf(unlist(input_files$Input$`File Name`),"_")
  if(any(str_starts(input_files$Input$Condition, "[0-9]"))){
    name<-names(formule_contrast)
    formule_contrast <- lapply(unique(input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))]), 
                               function(x){
                                 str_replace_all(formule_contrast,
                                                 x,
                                                 str_c("X.", x))
                               })[[1]]
    names(formule_contrast) <- name
    input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))] <- str_c("X.",
                                                                                        input_files$Input$Condition[
                                                                                          (str_starts(input_files$Input$Condition, "[0-9]"))])
  }
  #Prepare PROT table with only column Accession and Dscription, extract fro Description the GeneName and remove contaminants
  if(is_empty(which(grepl("Keratin|keratin",input_files$PROT$Description) |
                    grepl("CON_",input_files$PROT$Accession)))){
    input_files$PROT <- na.omit(input_files$PROT[,c("Accession","Description")])
  }else{
    input_files$PROT <- na.omit(input_files$PROT[-which(grepl("Keratin|keratin",input_files$PROT$Description) |
                                                grepl("CON_",input_files$PROT$Accession))
                                         ,c("Accession","Description")])
  }
  input_files$PROT$GeneName<-lapply(input_files$PROT$Description, function(x){gsub(".*GN=(.+) PE=.*", "\\1", x)}) %>% unlist()
  taxonomy_NCBI<-lapply(input_files$PROT$Description, function(x){gsub(".*OX=(.+) GN=.*", "\\1", x)}) %>% unlist()
  taxonomy_NCBI<-strtoi(names(sort(table(taxonomy_NCBI), decreasing = T))[1])
  #Mantain only the first UNIPROT code
  input_files$PEP$`Master Protein Accessions`<-lapply(input_files$PEP$`Master Protein Accessions`,
                                                                  function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()
  #Filter PHOS taking only phospho modifications
  if(type == "PHOS"){
    input_files$PEP <- input_files$PEP[grepl("Phospho",input_files$PEP$Modifications),]
    
    #Verify if the Abundance start in 5 column in PEP table, if not remove extra column
    if(!grepl("Abundance",colnames(input_files$PEP)[5])){
      input_files$PEP<-input_files$PEP[,c(colnames(input_files$PEP)[grepl(paste("Annotated Sequence",
                                                                                "Modifications",
                                                                                "Master Protein Accessions",
                                                                                "Positions in Master Proteins", sep = "|"), 
                                                                          colnames(input_files$PEP))],
                                          colnames(input_files$PEP)[which(grepl("Abundance",colnames(input_files$PEP)))])]
    }
    
    #Modify seqeunce to detect only active phosphosite
    pattern_sub <- lapply(str_extract_all(input_files$PEP$`Modifications in Master Proteins`, "\\(\\d+\\.\\d+|\\(\\d+"), 
                          function(x){(unlist(str_remove_all(unlist(x), "\\(")))})
    replacement <- lapply(str_extract_all(input_files$PEP$`Modifications in Master Proteins`, "\\(\\d+\\.\\d+|\\(\\d+"), 
                          function(x){as.integer(as.double(unlist(str_remove_all(unlist(x), "\\("))) > phospho_thr)})
    input_files$PEP$modif <- lapply(1:length(input_files$PEP$`Modifications in Master Proteins`), 
                                    function(x){
                                      stri_replace_all_regex(input_files$PEP$`Modifications in Master Proteins`[x], 
                                                             pattern_sub[[x]],
                                                             as.character(replacement[[x]]),
                                                             vectorize_all = F)}) %>% unlist()
    input_files$PEP$modif <- paste(input_files$PEP$`Master Protein Accessions`, input_files$PEP$modif, input_files$PEP$`Annotated Sequence`, sep="_")
    PEP_collapse <- input_files$PEP[,c(which(grepl("Abundance",colnames(input_files$PEP))), ncol(input_files$PEP))]
    PEP_collapse <- PEP_collapse %>% group_by(modif) %>% summarize_all(funs(sum(., na.rm = T))) 
    PEP_collapse <- right_join(input_files$PEP[,c("Annotated Sequence",
                                                  "Modifications in Master Proteins",
                                                  "Master Protein Accessions",
                                                  "Positions in Master Proteins",
                                                  "modif")], PEP_collapse, by ="modif")
    PEP_collapse <- PEP_collapse[!duplicated(PEP_collapse$modif),]
    #merge by uniprot the prot description and the pep table
    uniprot_to_take<-merge(input_files$PROT, PEP_collapse, by.x = "Accession", by.y = "Master Protein Accessions")
    input_files$PD_PEP_matrix<-merge(input_files$PROT[which(input_files$PROT$Accession %in% uniprot_to_take$Accession),],
                                     PEP_collapse, by.x = "Accession", by.y = "Master Protein Accessions")
    input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,c(colnames(input_files$PD_PEP_matrix)[grepl(paste(
      "Accession",
      "Description",
      "GeneName",
      "Annotated Sequence",
      "Modifications",
      "Positions in Master Proteins",
      "modif", sep = "|"), 
      colnames(input_files$PD_PEP_matrix))],
      lapply(input_files$Input$`File ID`, function(x){
        colnames(input_files$PD_PEP_matrix)[grepl(str_c(x,":"), colnames(input_files$PD_PEP_matrix))]
      }) %>% unlist())]
    if("TRUE" %in% grepl("\\.", colnames(input_files$PD_PEP_matrix))){
      input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,-which(colnames(input_files$PD_PEP_matrix) %in%
                                                                     c(colnames(input_files$PD_PEP_matrix)[grepl("\\.",
                                                                                                                 colnames(input_files$PD_PEP_matrix))]))]
    }
    colnames(input_files$PD_PEP_matrix)<-c(colnames(input_files$PD_PEP_matrix)[grepl(paste(
      "Accession",
      "Description",
      "GeneName",
      "Annotated Sequence",
      "Modifications",
      "Positions in Master Proteins",
      "modif", sep = "|"), 
      colnames(input_files$PD_PEP_matrix))],
      unlist(lapply(colnames(input_files$PD_PEP_matrix), function(x){
        lapply(input_files$Input$`File ID`, function(y){if(str_detect(x,paste0(y,":"))){
          input_files$Input$`File Name`[which(input_files$Input$`File ID` %in% y)]
        }})
      })))
    # input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1] %>% toupper()
    input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1]
    #Maintain only the new complete matrix of intensity
    psm_sig_raw<-as.data.frame(input_files$PD_PEP_matrix)
    c_anno<-input_files$Input
    if(!("Sample" %in% colnames(c_anno))){
      colnames(c_anno)[2]<-"sample"
    }else{
      colnames(psm_sig_raw)<-c(c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins","modif"),
                               c_anno$Sample)
    }
    colnames(c_anno)<-tolower(colnames(c_anno))
    
    rownames(c_anno)<-c_anno$sample
    if("color" %in% colnames(c_anno)){
      colour_vec<-na.omit(c_anno[colnames(psm_sig_raw),]$color)
      names(colour_vec)<-na.omit(c_anno[colnames(psm_sig_raw),]$sample)
    } else{
      c_anno<-left_join(c_anno,
                        data.frame("color"=colour_vec[match(sort(c_anno$condition),unique(sort(c_anno$condition)))],
                                   "sample"=c_anno[order(c_anno$condition), "sample"]))
    }
    
    # READ PSM
    # PSM ANALYSIS
    #Read PSM and manage the Phospho Percentage
    input_files[["PSM"]] <- input_files[["PSM"]][-which(input_files[["PSM"]]$`Annotated Sequence` %in% input_files[["PD_PEP_matrix"]]$`Annotated Sequence` |
                                                         !grepl(pattern = "Phospho", input_files[["PSM"]]$`ptmRS: Best Site Probabilities`) |
                                                         (is.na(input_files[["PSM"]]$`Precursor Abundance`))),]
    input_files[["PSM"]] <- input_files[["PSM"]][unlist(lapply(str_extract_all(input_files[["PSM"]]$`ptmRS: Best Site Probabilities`,
                                                                               "\\: \\d+\\.\\d+\\b|\\: \\d+\\b"),
                                                               function(x){any(as.double(unlist(str_remove_all(unlist(x), "\\: "))) > phospho_thr)})),]

    #Mantain only the first UNIPROT code
    input_files$PSM$`Master Protein Accessions`<-lapply(input_files$PSM$`Master Protein Accessions`,
                                                                    function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()

    #Modify sequence to detect only the phosphorilated sites
    pattern_sub <- lapply(str_extract_all(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\: \\d+\\.\\d+\\b|\\: \\d+\\b"),
                          function(x){(unlist(str_remove_all(unlist(x), "\\: ")))})
    replacement <- lapply(str_extract_all(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\: \\d+\\.\\d+\\b|\\: \\d+\\b"),
                          function(x){as.integer(as.double(unlist(str_remove_all(unlist(x), "\\: "))) > phospho_thr)})
    input_files$PSM$modif <- lapply(1:length(input_files$PSM$`ptmRS: Best Site Probabilities`),
                                       function(x){
                                         stri_replace_all_regex(input_files$PSM$`ptmRS: Best Site Probabilities`[x],
                                                                pattern_sub[[x]],
                                                                as.character(replacement[[x]]),
                                                                vectorize_all = F)}) %>% unlist()
    input_files$PSM$`Annotated Sequence` <- str_to_upper(input_files$PSM$`Annotated Sequence`)

    id_pep_doubt <- psm_sig_raw[stri_detect_regex(psm_sig_raw$Modifications,"\\/"),c(1:7)]
    
    pattern<-input_files$PSM[,c("Annotated Sequence","Master Protein Accessions", "modif")] %>% filter(`Annotated Sequence` %in% id_pep_doubt$`Annotated Sequence` &
                                                                                                         `Master Protein Accessions` %in% id_pep_doubt$Accession)

    pattern$modif_split <- lapply(stri_split_regex(pattern$modif, ";"), 
                                  function(x){stri_c(unlist(lapply(stri_extract_all_regex(str_remove_all(x, "\\ "), "^.|.$"), 
                                                                   function(y){y[y[2] != "0"]})), collapse = "")}) %>% unlist()
    
    pattern2 <- left_join(pattern, id_pep_doubt, by = c("Annotated Sequence" = "Annotated Sequence", "Master Protein Accessions" = "Accession"))
    pattern2$phospo_PEP <- lapply(stri_extract_all_regex(pattern2$modif.y, "\\w\\d+\\(1"), 
                                  function(x){stri_c(unlist(stri_extract_all_regex(x, "^.|.$")), collapse = "")}) %>% unlist()
    #Chance doubt phosphosite with the most probable
    for(ids in unique(pattern2$modif.y)){
      test<-pattern2[(pattern2$modif.y == ids) & !(pattern2$modif_split == pattern2$phospo_PEP),]
      if(nrow(test) > 0){
        test$doubtSite<-lapply(1:nrow(test), function(x){str_remove(test$modif_split[x], test$phospo_PEP[x])})
        table_site <- table(unlist(test$doubtSite))
        site_to_take <- stri_extract_all_regex(names(table_site[which(table_site == max(table_site))])[1], "^.")[[1]]
        psm_sig_raw$Modifications[which(psm_sig_raw$modif == test$modif.y[1])]<- stri_replace_all_regex(test$modif.y[1], "\\w\\/\\w\\/\\w|\\w\\/\\w",paste0(site_to_take,"(1)"))
        psm_sig_raw$modif[which(psm_sig_raw$modif == test$modif.y[1])]<- stri_replace_all_regex(test$modif.y[1], "\\w\\/\\w\\/\\w|\\w\\/\\w",paste0(site_to_take,"(1)"))
      } else{
        table_site <- table(unlist(unique(pattern2$phospo_PEP[which(pattern2$modif.y == ids)])))
        site_to_take <- stri_extract_all_regex(names(table_site[which(table_site == max(table_site))])[1], "^.")[[1]]
        psm_sig_raw$Modifications[which(psm_sig_raw$modif == ids)]<- stri_replace_all_regex(ids, "\\w\\/\\w\\/\\w|\\w\\/\\w",paste0(site_to_take,"(1)"))      
        psm_sig_raw$modif[which(psm_sig_raw$modif == ids)]<- stri_replace_all_regex(ids, "\\w\\/\\w\\/\\w|\\w\\/\\w",paste0(site_to_take,"(1)"))
      }
    }
    #############
    # #Collapse the PSM with different percentage
    # pattern <- data.frame("Phospho" = str_remove_all(input_files$PSM$`ptmRS: Best Site Probabilities`, pattern = ";"))
    # pattern <- pattern %>% separate(Phospho,
    #                                 as.character(1:(2*max(str_count(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\:")))),
    #                                 sep=" ")
    # 
    # #Collapse the PSM with different percentage
    # pattern$group <- paste(input_files$PSM$`Master Protein Accessions`,
    #                        str_to_upper(input_files$PSM$`Annotated Sequence`),
    #                        input_files$PSM$modif,
    #                        sep="_")
    # pattern$seq <- str_to_upper(input_files$PSM$`Annotated Sequence`)
    # pattern <- pattern[order(pattern$group),]
    # pattern[,as.character(which((1:(2*max(str_count(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\:"))))%%2 == 0))] <- sapply(
    #   pattern[,as.character(which((1:(2*max(str_count(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\:"))))%%2 == 0))],
    #   as.double)
    # pattern2 <- aggregate(pattern, list(pattern$group), mean)
    # pattern2[,as.character(which((1:(2*max(str_count(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\:"))))%%2 == 0))] <- sapply(
    #   pattern2[,as.character(which((1:(2*max(str_count(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\:"))))%%2 == 0))],
    #   function(x){round(x, digits = 2)})
    # pattern2[order(pattern2$Group.1),
    #          as.character(which((1:(2*max(str_count(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\:"))))%%2 == 1))] <- unique(
    #            pattern[order(pattern$group),
    #                    c(as.character(which((1:(2*max(str_count(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\:"))))%%2 == 1)), "group", "seq")])
    # pattern2[] <- lapply(pattern2, as.character)
    # pattern2[is.na(pattern2)] <- "tmpC"
    # base_string<- paste0(paste(rep("%s %s; ",
    #                            max(str_count(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\:"))-1),
    #                        collapse = ""),
    #                  "%s %s")
    # pattern2$newseq<-as.character(lapply(1:nrow(pattern2), function(x){
    #   str_remove_all(do.call(sprintf, c(fmt= base_string,
    #           (pattern2[x,as.character(1:(2*max(str_count(input_files$PSM$`ptmRS: Best Site Probabilities`, "\\:"))))]))), " tmpC;| tmpC| ")
    # }))
    #############
    input_files$PEP_info <- as.data.frame(unique(psm_sig_raw[, c("Accession","Description","GeneName","Annotated Sequence",
                                                                 "Modifications","Position in Master Proteins", "modif")]))
    colnames(input_files$PEP_info) <- c("Accession","Description","GeneName", "Annotated Sequence","Modifications", "Position in Master Proteins", "modif")
    rownames(input_files$PEP_info) <- input_files$PEP_info$ID_peptide
    rownames(psm_sig_raw) <- make.names(psm_sig_raw$modif, unique = T)
    psm_sig_raw <- psm_sig_raw[,-which(colnames(psm_sig_raw) 
                                       %in% 
                                         c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins", "modif"))]
    #TODO: THINK HOW INTEGRATE PSM WITH PEPTIDES
    # input_files$PEP_info[pattern2$Group.1, "Phospho_%"] <- pattern2[,"newseq"]
    # remove(pattern, pattern2)
  } else{
    #Verify if the Abundance start in 5 column in PEP table, if not remove extra column
    if(!grepl("Abundance",colnames(input_files$PEP)[5])){
      input_files$PEP<-input_files$PEP[,c(colnames(input_files$PEP)[grepl(paste("Annotated Sequence",
                                                                                "Modifications",
                                                                                "Master Protein Accessions",
                                                                                "Positions in Master Proteins", sep = "|"), 
                                                                          colnames(input_files$PEP))],
                                          colnames(input_files$PEP)[which(grepl("Abundance",colnames(input_files$PEP)))])]
    }
    input_files$PEP <- input_files$PEP %>% group_by(`Annotated Sequence` ,`Modifications in Master Proteins`,`Master Protein Accessions`,`Positions in Master Proteins`) %>% summarize_all(funs(sum(., na.rm = T))) 
    
    #merge by uniprot the prot description and the pep table
    uniprot_to_take<-merge(input_files$PROT, input_files$PEP, by.x = "Accession", by.y = "Master Protein Accessions")
    input_files$PD_PEP_matrix<-merge(input_files$PROT[which(input_files$PROT$Accession %in% uniprot_to_take$Accession),],
                                     input_files$PEP, by.x = "Accession", by.y = "Master Protein Accessions")
    input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,c(colnames(input_files$PD_PEP_matrix)[grepl(paste(
      "Accession",
      "Description",
      "GeneName",
      "Annotated Sequence",
      "Modifications",
      "Positions in Master Proteins", sep = "|"), 
      colnames(input_files$PD_PEP_matrix))],
      lapply(input_files$Input$`File ID`, function(x){
        colnames(input_files$PD_PEP_matrix)[grepl(str_c(x,":"), colnames(input_files$PD_PEP_matrix))]
      }) %>% unlist())]
    if("TRUE" %in% grepl("\\.", colnames(input_files$PD_PEP_matrix))){
      input_files$PD_PEP_matrix<-input_files$PD_PEP_matrix[,-which(colnames(input_files$PD_PEP_matrix) %in%
                                                                     c(colnames(input_files$PD_PEP_matrix)[grepl("\\.",
                                                                                                                 colnames(input_files$PD_PEP_matrix))]))]
    }
    colnames(input_files$PD_PEP_matrix)<-c(colnames(input_files$PD_PEP_matrix)[grepl(paste(
      "Accession",
      "Description",
      "GeneName",
      "Annotated Sequence",
      "Modifications",
      "Positions in Master Proteins", sep = "|"), 
      colnames(input_files$PD_PEP_matrix))],
      unlist(lapply(colnames(input_files$PD_PEP_matrix), function(x){
        lapply(input_files$Input$`File ID`, function(y){if(str_detect(x,paste0(y,":"))){
          input_files$Input$`File Name`[which(input_files$Input$`File ID` %in% y)]
        }})
      })))
    # input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1] %>% toupper()
    input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1]
    #Maintain only the new complete matrix of intensity
    psm_sig_raw<-as.data.frame(input_files$PD_PEP_matrix)
    c_anno<-input_files$Input
    if(!("Sample" %in% colnames(c_anno))){
      colnames(c_anno)[2]<-"sample"
    }else{
      colnames(psm_sig_raw)<-c(c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins"),
                               c_anno$Sample)
    }
    colnames(c_anno)<-tolower(colnames(c_anno))
    
    rownames(c_anno)<-c_anno$sample
    if("color" %in% colnames(c_anno)){
      colour_vec<-na.omit(c_anno[colnames(psm_sig_raw),]$color)
      names(colour_vec)<-na.omit(c_anno[colnames(psm_sig_raw),]$sample)
    } else{
      c_anno<-left_join(c_anno,
                        data.frame("color"=colour_vec[match(sort(c_anno$condition),unique(sort(c_anno$condition)))],
                                   "sample"=c_anno[order(c_anno$condition), "sample"]))
    }
    
    input_files$PEP_info <- as.data.frame(unique(psm_sig_raw[, c("Accession","Description","GeneName","Annotated Sequence",
                                                                 "Modifications","Position in Master Proteins")]))
    colnames(input_files$PEP_info) <- c("Accession","Description","GeneName", "Annotated Sequence","Modifications", "Position in Master Proteins")
    rownames(input_files$PEP_info) <- paste(input_files$PEP_info$Accession, input_files$PEP_info$Modifications, input_files$PEP_info$`Annotated Sequence`, sep = "_")
    rownames(psm_sig_raw) <- make.names(paste(psm_sig_raw$Accession, psm_sig_raw$Modifications, psm_sig_raw$`Annotated Sequence`, sep="_"), unique = T)
    psm_sig_raw <- psm_sig_raw[,-which(colnames(psm_sig_raw) 
                                       %in% 
                                         c("Accession","Description","GeneName","Annotated Sequence","Modifications","Position in Master Proteins"))]
  }
  
  # rownames(psm_sig_raw) <- make.names(paste(psm_sig_raw$Accession, psm_sig_raw$Modifications, psm_sig_raw$`Annotated Sequence`, sep="_"), unique = T)
  psm_peptide_table<-input_files$PEP_info
  
  remove(uniprot_to_take,input_files)
  #Print Annotation table
  # kable(c_anno)
  return(list("taxonomy_NCBI" = taxonomy_NCBI,
              "psm_sig_raw" = psm_sig_raw,
              "psm_peptide_table" = psm_peptide_table,
              "c_anno" = c_anno,
              "colour_vec" = colour_vec,
              "formule_contrast" = formule_contrast))
}

filenames <- list("Input"=params$file_input_prot,"prot"=params$file_prot_prot,"pep"=params$file_pep_prot)
res <- read_input_files("PROT", filenames)
taxonomy_NCBI<-res$taxonomy_NCBI
psm_sig_raw_prot<-res$psm_sig_raw
psm_peptide_table_prot <- res$psm_peptide_table
c_anno_prot<-res$c_anno
rownames(c_anno_prot)<-c_anno_prot$sample
colour_vec<-res$colour_vec
formule_contrast<-res$formule_contrast

filenames <- list("Input"=params$file_input_phos,"prot"=params$file_prot_phos,"pep"=params$file_pep_phos,"psm"=params$file_psm_phos)
res <- read_input_files("PHOS", filenames)
psm_sig_raw_phos<-res$psm_sig_raw
c_anno_phos<-res$c_anno
rownames(c_anno_phos)<-c_anno_phos$sample
psm_peptide_table_phos <- res$psm_peptide_table


cat("#### Phosho-proteome samples \n ")
kable(c_anno_phos, row.names = F)
cat("#### Proteome samples \n ")
kable(c_anno_prot, row.names = F)

remove(filenames, res)
shiny::setProgress(0.23, detail = "Files correctly read...")
```

```{r load_data_from_MQ, eval=readMQ_files,echo=F, message=F, warning=F, results='asis'}
message("Reading files from MS...")
read_input_files<-function(type, filenames){
  #Read all files in the input folder
  template_files=c("Input","pep")
  input_files<-list("FILES"="in_files")
  # save(template_files, filenames, input_files, file = "tmp.RData")
  for (f in template_files){
    if(f == template_files[1]){
      input_files[f] <- tryCatch({
        read_excel_allsheets(filenames[f][[1]])
        # read_excel_allsheets(paste0(dir_file_input,filenames[which(grepl(f,filenames) & !grepl('~', filenames))]))
      }, error=function(cond){
        stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
      })
    }else{
      input_files[f] <- tryCatch({
        list(read_tsv(filenames[f][[1]]))
  
        # list(read_tsv(paste0(dir_file_input,filenames[which(grepl(f,filenames) & !grepl('~', filenames))])))
      }, error=function(cond){
        stop(paste0("Error: missing file. The file \'",f,"\' is missing or not have the pattern in the filename or there are duplicates files."))
      })
    }
  }
  names(input_files)<-c("dir","Input","PEP")
  message("Data acquired")
  
  
  #Clean files and merge
  colToKeep<-intersect(colnames(input_files$Input), c("Condition","Color","Sample","Filename"))
  input_files$Input <- input_files$Input[,colToKeep]
  if(!("Condition" %in% colnames(input_files$Input))){ stop("Error: \'Condition\' column missin in \'Input\' file.") }
  if(!("Filename" %in% colnames(input_files$Input))){ 
    input_files$Input$Filename<-input_files$Input$Sample 
    message("Filename not found. Use Sample column as Filename. Can occur problem in reading the Evidence file.")
  }
  if(batch_corr_exe & !("MS_batch" %in% colnames(input_files$Input))){ stop("Error: \'MS_batch\' column missin in \'Input\' file with batch correction activated") }
  
  if(type == "PROT"){
    input_files$Input$Condition <- str_c(input_files$Input$Condition, "_i")
  } else{
    input_files$Input$Condition <- str_c(input_files$Input$Condition, "_p")
  }
  
  if(any(str_starts(input_files$Input$Condition, "[0-9]"))){
    name<-names(formule_contrast)
    formule_contrast <- lapply(unique(input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))]), 
                               function(x){
                                 str_replace_all(formule_contrast,
                                                 x,
                                                 str_c("X.", x))
                               })[[1]]
    names(formule_contrast) <- name
    input_files$Input$Condition[(str_starts(input_files$Input$Condition, "[0-9]"))] <- str_c("X.",
                                                                                           input_files$Input$Condition[(str_starts(input_files$Input$Condition,
                                                                                                                                   "[0-9]"))])
  }
  #Prepare PROT table with only column Accession and Dscription, extract fro Description the GeneName and remove contaminants
  taxonomy_NCBI<-lapply(input_files$PEP$`Protein names`, function(x){gsub(".*OX=(.+) GN=.*", "\\1", x)}) %>% unlist()
  taxonomy_NCBI<-strtoi(names(sort(table(taxonomy_NCBI), decreasing = T))[1])
  if(is.na(taxonomy_NCBI)){
    taxonomy_NCBI<-9606
  }
  
  #Cast genename to all upper for human and as title for mouse
  if(taxonomy_NCBI == 9606){
    input_files$PEP$`Gene names` <- str_to_upper(input_files$PEP$`Gene names`)
  } else {
    input_files$PEP$`Gene names` <- str_to_title(input_files$PEP$`Gene names`)
  }
  
  input_files$PEP <- input_files$PEP[-which(grepl("Keratin|keratin",input_files$PEP$`Protein names`) |
                                              grepl("CON_",input_files$PEP$`Leading razor protein`) |
                                              is.na(input_files$PEP$`Protein names`) |
                                              is.na(input_files$PEP$`Gene names`) |
                                              !(input_files$PEP$`Raw file` %in% input_files$Input$Filename) |
                                              (input_files$PEP$Type == "MSMS")),]
  if(type == "PHOS"){
    input_files$PEP <- input_files$PEP[grepl(x = input_files$PEP$Modifications, pattern = "Phospho|phospho"),]
    #Remove phosphorylation with low score
    input_files$PEP <- input_files$PEP[unlist(lapply(str_extract_all(input_files$PEP$`Phospho (STY) Probabilities`, "1|(0\\.\\d+)"),
                                                     function(x){any(as.double(unlist(x)) > (phospho_thr/100))})),]
    #Modify sequence to detect only the phosphorilated sites
    pattern <- str_extract_all(input_files$PEP$`Phospho (STY) Probabilities`, "1|(0\\.\\d+)")
    replacement <- lapply(str_extract_all(input_files$PEP$`Phospho (STY) Probabilities`, "1|(0\\.\\d+)"), 
                          function(x){as.integer(as.double(unlist(x)) > (phospho_thr/100))})
    input_files$PEP$Sequence <- lapply(1:length(input_files$PEP$`Phospho (STY) Probabilities`), 
                                       function(x){
                                         stri_replace_all_regex(input_files$PEP$`Phospho (STY) Probabilities`[x], 
                                                                pattern[[x]],
                                                                as.character(replacement[[x]]),
                                                                vectorize_all = F)}) %>% unlist()
  }
  input_files$PEP$`Gene names`[which(str_detect(input_files$PEP$`Gene names`,";"))] <- lapply(
                                                                          input_files$PEP$`Gene names`[which(str_detect(input_files$PEP$`Gene names`,";"))],
                                                                                    function(x){unlist(str_split(x, ";"))[1]}) %>% unlist()
  
  #Made the matrix
  input_files$PEP_matrix<- data.frame("Protein" = as.factor(paste(input_files$PEP$`Leading razor protein`, input_files$PEP$Modifications, input_files$PEP$Sequence, sep="_")), 
                                      "Sample" = as.factor(input_files$PEP$`Raw file`), 
                                      "Intensity" = input_files$PEP$Intensity)
  input_files$PEP_matrix<-as.data.frame(pivot_wider(input_files$PEP_matrix, names_from = Sample, values_from = Intensity, values_fn = sum))
  rownames(input_files$PEP_matrix) <- input_files$PEP_matrix$Protein
  input_files$PEP_matrix <- input_files$PEP_matrix[,-1]
  colnames(input_files$PEP_matrix) <- input_files$Input[match(colnames(input_files$PEP_matrix), input_files$Input$Filename),"Sample"]
  
  #Made the description of the mpeptides
  if(type == "PROT"){
    input_files$PEP_info <- as.data.frame(unique(input_files$PEP[, c("Leading razor protein", "Protein names", "Gene names", "Sequence", "Modifications")]))
    colnames(input_files$PEP_info) <- c("Accession","Description","GeneName", "Annotated Sequence","Modifications")
    rownames(input_files$PEP_info) <- paste(input_files$PEP_info$Accession, input_files$PEP_info$Modifications, input_files$PEP_info$`Annotated Sequence`, sep="_")
  } else{
    input_files$PEP_info <- as.data.frame(unique(input_files$PEP[, c("Leading razor protein", "Protein names", "Gene names", "Sequence", "Modifications", "Phospho (STY) Probabilities")]))
    colnames(input_files$PEP_info) <- c("Accession","Description","GeneName", "Annotated Sequence","Modifications", "Phospho_%")
    rownames(input_files$PEP_info) <- paste(input_files$PEP_info$Accession, input_files$PEP_info$Modifications, input_files$PEP_info$`Phospho_%`, sep="_")
    
    pattern <- data.frame("Phospho" = input_files$PEP_info$`Phospho_%`)
    pattern <- pattern %>% separate(Phospho, 
                                    as.character(1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1)),
                                    sep="\\(|\\)")
    pattern$group <- paste(input_files$PEP_info$Accession, input_files$PEP_info$Modifications, input_files$PEP_info$`Annotated Sequence`, sep="_")
    pattern$seq <- input_files$PEP_info$`Annotated Sequence`
    pattern <- pattern[order(pattern$group),]
    pattern[,as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 0))] <- sapply(
      pattern[,as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 0))], 
      as.double)
    pattern2 <- aggregate(pattern, list(pattern$group), mean)
    pattern2[,as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 0))] <- sapply(
      pattern2[,as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 0))], 
      function(x){round(x, digits = 3)})
    pattern2[order(pattern2$Group.1),
             as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 1))] <- unique(
               pattern[order(pattern$group),
                       c(as.character(which((1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))%%2 == 1)), "group", "seq")])
    pattern2[] <- lapply(pattern2, as.character)
    pattern2[is.na(pattern2)] <- "tmpC"
    base_string<- paste0(paste(rep("%s(%s)", 
                               max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))), 
                           collapse = ""),
                     "%s")
    pattern2$newseq<-as.character(lapply(1:nrow(pattern2), function(x){
      str_remove_all(do.call(sprintf, c(fmt= base_string,
              (pattern2[x,as.character(1:(2*max(str_count(input_files$PEP_info$`Annotated Sequence`, "1|0"))+1))]))), "\\(tmpC\\)|tmpC| ")
    }))

    input_files$PEP_info <- as.data.frame(unique(input_files$PEP[, c("Leading razor protein", "Protein names", "Gene names", "Sequence", "Modifications")]))
    colnames(input_files$PEP_info) <- c("Accession","Description","GeneName", "Annotated Sequence","Modifications")
    rownames(input_files$PEP_info) <- paste(input_files$PEP_info$Accession, input_files$PEP_info$Modifications, input_files$PEP_info$`Annotated Sequence`, sep="_")
    input_files$PEP_info[pattern2$Group.1, "Phospho_%"] <- pattern2[,"newseq"]
    remove(pattern, pattern2)
  }

  #merge by uniprot the prot description and the pep table
  # input_files$PD_PEP_matrix<-merge(input_files$PEP_info, input_files$PEP_matrix, by = 'row.names')
  # rownames(input_files$PD_PEP_matrix) <- input_files$PD_PEP_matrix$Row.names
  # input_files$PD_PEP_matrix <- input_files$PD_PEP_matrix[,-1]

  # 
  # input_files$PD_PEP_matrix$`End position` <- str_c(input_files$PD_PEP_matrix$GeneName,input_files$PD_PEP_matrix$`Start position`, input_files$PD_PEP_matrix$`End position`, sep = "_")
  # input_files$PD_PEP_matrix$`Start position` <- c(NA)
  # 
  # colnames(input_files$PD_PEP_matrix)<-c(c("Accession","Description","GeneName",
  #                                          "Annotated Sequence","Modifications","Position in Master Proteins"),
  #                                         unlist(lapply(colnames(input_files$PD_PEP_matrix), function(x){ if(str_detect(x,"Intensity")){
  #                                                str_split(x," ")[[1]][2]
  #                                            }})
  #                                        ))
  # input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1] %>% toupper()
  # input_files$PD_PEP_matrix$GeneName<-str_split_fixed(str_split_fixed(input_files$PD_PEP_matrix$GeneName,"-",n=2)[,1],"[.]",n=2)[,1]
  #Maintain only the new complete matrix of intensity
  psm_sig_raw<-input_files$PEP_matrix
  psm_peptide_table<-input_files$PEP_info
  c_anno<-input_files$Input
  colnames(c_anno)<-tolower(colnames(c_anno))
  
  rownames(c_anno)<-c_anno$sample
  if("color" %in% colnames(c_anno)){
    colour_vec<-na.omit(c_anno[colnames(psm_sig_raw),]$color)
    names(colour_vec)<-na.omit(c_anno[colnames(psm_sig_raw),]$sample)
  } else{
      c_anno<-left_join(c_anno,
                        data.frame("color"=colour_vec[match(sort(c_anno$condition),unique(sort(c_anno$condition)))],
                                   "sample"=c_anno[order(c_anno$condition), "sample"]))
  }
  
  remove(input_files)
  #Print Annotation table
  # kable(c_anno)
  return(list("taxonomy_NCBI" = taxonomy_NCBI,
              "psm_sig_raw" = psm_sig_raw,
              "psm_peptide_table" = psm_peptide_table,
              "c_anno" = c_anno,
              "colour_vec" = colour_vec,
              "formule_contrast" = formule_contrast))
}

filenames <- list("Input"=params$file_input_prot,"pep"=params$file_pep_prot)
res <- read_input_files("PROT", filenames)
taxonomy_NCBI<-res$taxonomy_NCBI
psm_sig_raw_prot<-res$psm_sig_raw
psm_peptide_table_prot <- res$psm_peptide_table
c_anno_prot<-res$c_anno
rownames(c_anno_prot)<-c_anno_prot$sample
colour_vec<-res$colour_vec
formule_contrast<-res$formule_contrast


filenames <- list("Input"=params$file_input_phos,"pep"=params$file_pep_phos)
res <- read_input_files("PHOS", filenames)
psm_sig_raw_phos<-res$psm_sig_raw
c_anno_phos<-res$c_anno
rownames(c_anno_phos)<-c_anno_phos$sample
psm_peptide_table_phos <- res$psm_peptide_table


cat("#### Phosho-proteome samples \n ")
kable(c_anno_phos, row.names = F)
cat("#### Proteome samples \n ")
kable(c_anno_prot, row.names = F)
remove(filenames, res)
shiny::setProgress(0.23, detail = "Files correctly read...")
```

```{r peptide_annotation, message=F, warning=F, echo=F, eval=T}
if(readPD_files){
  psm_peptide_table_prot$`Position in Master Proteins`<-gsub(" ", "_", psm_peptide_table_prot$`Position in Master Proteins`)
  psm_peptide_table_phos$`Position in Master Proteins`<-gsub(" ", "_", psm_peptide_table_phos$`Position in Master Proteins`)
  psm_peptide_table_prot$Modifications<-gsub(" ", "_", psm_peptide_table_prot$Modifications)
  psm_peptide_table_phos$Modifications<-gsub(" ", "_", psm_peptide_table_phos$Modifications)
} else{
  psm_peptide_table_phos$Modifications<-gsub(" ", "_", psm_peptide_table_phos$Modifications)
  psm_peptide_table_prot$Modifications<-gsub(" ", "_", psm_peptide_table_prot$Modifications)
}


# if(readPD_files){
#   #For peptides analysis
#   # psm_anno_raw <- data.frame("accession"=psm_sig_raw$Accession,
#   #                            "symbol"=psm_sig_raw$GeneName,
#   #                            "sequence"=psm_sig_raw$`Annotated Sequence`,
#   #                            "modifications"=psm_sig_raw$Modifications)
#   #For protein groups analysis
psm_anno_raw_prot <- data.frame("symbol"=psm_peptide_table_prot$GeneName,
                                  "sequence"=psm_peptide_table_prot$`Annotated Sequence`,
                                  "modifications"=psm_peptide_table_prot$Modifications)
psm_anno_raw_prot$id<-paste(psm_anno_raw_prot$symbol,psm_anno_raw_prot$sequence,psm_anno_raw_prot$modifications,sep="_")
  
psm_anno_raw_phos <- unique(data.frame("symbol"=psm_peptide_table_phos$GeneName,
                                  "sequence"=psm_peptide_table_phos$`Annotated Sequence`,
                                  "modifications"=psm_peptide_table_phos$Modifications))
psm_anno_raw_phos$id<-paste(psm_anno_raw_phos$symbol,psm_anno_raw_phos$sequence,psm_anno_raw_phos$modifications,sep="_")
# }else{
#   psm_anno_raw <- data.frame("symbol"=psm_sig_raw$GeneName,
#                              "sequence"=psm_sig_raw$`Annotated Sequence`,
#                              "modifications"=psm_sig_raw$Modifications)
#   psm_anno_raw$id<-paste(psm_anno_raw$symbol,psm_anno_raw$sequence,psm_anno_raw$modifications,sep="_")
# }
#PROTEOMICS
rownames(psm_sig_raw_prot)<-rownames(psm_peptide_table_prot)<-rownames(psm_anno_raw_prot)<-psm_anno_raw_prot$id
psm_anno_raw_prot$old_id<-rownames(psm_anno_raw_prot)

# create peptide names linked to symbols
psm_anno_raw_prot$row <- seq(1,nrow(psm_anno_raw_prot))
psm_anno_raw_prot <- psm_anno_raw_prot %>% dplyr::group_by(symbol) %>% dplyr::mutate("min"=min(row),"card"=n()) %>% ungroup()
psm_anno_raw_prot$rank<- psm_anno_raw_prot$row - psm_anno_raw_prot$min +1
psm_anno_raw_prot$id<- paste(psm_anno_raw_prot$symbol,psm_anno_raw_prot$rank,psm_anno_raw_prot$card,sep="_")

psm_sig_raw_prot<-psm_sig_raw_prot[psm_anno_raw_prot$old_id,]
rownames(psm_anno_raw_prot)<-psm_anno_raw_prot$old_id
# rownames(psm_sig_raw_prot)<-psm_anno_raw_prot$id
# 
# psm_anno_raw_prot<-as.data.frame(psm_anno_raw_prot)
# rownames(psm_anno_raw_prot)<- psm_anno_raw_prot$id

#Divide the table info from the matrix of peptide intensity
# psm_peptide_table_prot<-psm_sig_raw_prot[,c(1:6)]
# rownames(psm_peptide_table_prot)<-make.names(paste(psm_peptide_table_prot$`Position in Master Proteins`,
#                                               psm_peptide_table_prot$Modifications,
#                                               psm_peptide_table_prot$`Annotated Sequence`,sep = "_"), 
#                                         unique = T)
psm_sig_prot_raw_prot<-psm_sig_raw_prot

#PHOSPHO
rownames(psm_peptide_table_phos)<-paste(psm_peptide_table_phos$GeneName,psm_peptide_table_phos$`Annotated Sequence`,psm_peptide_table_phos$Modifications,sep="_")
rownames(psm_sig_raw_phos)<-rownames(psm_anno_raw_phos)<-psm_anno_raw_phos$id
psm_anno_raw_phos$old_id<-rownames(psm_anno_raw_phos)

# create peptide names linked to symbols
psm_anno_raw_phos$row <- seq(1,nrow(psm_anno_raw_phos))
psm_anno_raw_phos <- psm_anno_raw_phos %>% dplyr::group_by(symbol) %>% dplyr::mutate("min"=min(row),"card"=n()) %>% ungroup()
psm_anno_raw_phos$rank<- psm_anno_raw_phos$row - psm_anno_raw_phos$min +1
psm_anno_raw_phos$id<- paste(psm_anno_raw_phos$symbol,psm_anno_raw_phos$rank,psm_anno_raw_phos$card,sep="_")

psm_sig_raw_phos<-psm_sig_raw_phos[psm_anno_raw_phos$old_id,]
# rownames(psm_sig_raw_phos)<-psm_anno_raw_phos$id
# 
# psm_anno_raw_phos<-as.data.frame(psm_anno_raw_phos)
# rownames(psm_anno_raw_phos)<- psm_anno_raw_phos$id

#Divide the table info from the matrix of peptide intensity
# psm_peptide_table_phos<-psm_sig_raw_phos[,c(1:6)]
# rownames(psm_peptide_table_phos)<-make.names(paste(psm_peptide_table_phos$`Position in Master Proteins`,
#                                               psm_peptide_table_phos$Modifications,
#                                               psm_peptide_table_phos$`Annotated Sequence`,sep = "_"), 
#                                         unique = T)
psm_sig_pet_raw_phos<-psm_sig_raw_phos
rownames(psm_anno_raw_phos)<-psm_anno_raw_phos$old_id
# rownames(psm_sig_pet_raw_phos)<-rownames(psm_peptide_table_phos)

#For Peptide analysis
# rownames(psm_sig_raw)<-make.names(psm_anno_raw$accession,unique=T)
# rownames(psm_table_info)<-make.names(psm_table_info$Accession,unique=T)
# rownames(psm_anno_raw)<-make.names(psm_anno_raw$accession,unique=T)

shiny::setProgress(0.27, detail = "Annotate proteins/peptides...")

```

```{r preprocess_sig_raw, echo=F, message=F, warning=F}
#Preprocess Protein intensities
psm_sig_prot_raw_prot[psm_sig_prot_raw_prot == 0] <- NA # transform 0s into NAs

sig_thr<-0 # NA threshold

psm_long_df_prot <- psm_sig_prot_raw_prot %>% mutate(id=as.factor(rownames(psm_sig_prot_raw_prot)))
psm_long_df_prot <- psm_long_df_prot %>% pivot_longer(-id, names_to = "sample", values_to = "counts")
psm_long_df_prot <- suppressMessages(left_join(psm_long_df_prot,c_anno_prot))

psm_filter_df_prot <- psm_long_df_prot %>% dplyr::group_by(id,condition, .drop=FALSE) %>% dplyr::summarise("min_c"=sum(is.na(counts))) %>% ungroup()

psm_filter_df_prot <- psm_filter_df_prot %>% dplyr::group_by(id,.drop=FALSE) %>% dplyr::summarise("passes_c"= sum(min_c <= sig_thr)) %>% ungroup()

filter_id_prot <- as.character(psm_filter_df_prot %>% dplyr::filter(passes_c > 0) %>% pull(id))

psm_sig_prot_df <-psm_sig_prot_raw_prot[filter_id_prot,]
psm_anno_df <- psm_anno_raw_prot[filter_id_prot,]
psm_peptide_table_prot <- psm_peptide_table_prot[filter_id_prot,]
# psm_table_info <- psm_table_info[filter_id,]

#Log2
psm_log_prot_df <- psm_sig_prot_df
psm_log_prot_df <- psm_sig_prot_df %>% log2()

#Clean old variables
remove(psm_anno_raw_prot,psm_sig_prot_raw_prot,psm_long_df_prot,psm_filter_df_prot,filter_id_prot,sig_thr)

#Preprocess peptide intensities
psm_sig_pet_raw_phos[psm_sig_pet_raw_phos == 0] <- NA # transform 0s into NAs
sig_thr<-0 # NA threshold

psm_long_df_phos <- psm_sig_pet_raw_phos %>% mutate(id=as.factor(rownames(psm_sig_pet_raw_phos)))
psm_long_df_phos <- psm_long_df_phos %>% pivot_longer(-id, names_to = "sample", values_to = "counts")
psm_long_df_phos <- suppressMessages(left_join(psm_long_df_phos,c_anno_phos))

psm_filter_df_phos <- psm_long_df_phos %>% dplyr::group_by(id,condition, .drop=FALSE) %>% dplyr::summarise("min_c"=sum(is.na(counts))) %>% ungroup()
psm_filter_df_phos <- psm_filter_df_phos %>% dplyr::group_by(id,.drop=FALSE) %>% dplyr::summarise("passes_c"= sum(min_c <= sig_thr)) %>% ungroup()
filter_id_phos <- as.character(psm_filter_df_phos %>% dplyr::filter(passes_c > 0) %>% pull(id))

psm_sig_pet_df_phos <-psm_sig_pet_raw_phos[filter_id_phos,]
id_pep_table <- paste(psm_peptide_table_phos$GeneName, 
                      psm_peptide_table_phos$`Annotated Sequence`, 
                      psm_peptide_table_phos$Modifications, sep="_")[(paste(psm_peptide_table_phos$GeneName, 
                                                                            psm_peptide_table_phos$`Annotated Sequence`, 
                                                                            psm_peptide_table_phos$Modifications, sep="_") %in% filter_id_phos)]
psm_peptide_table<-psm_peptide_table_phos[id_pep_table,]

#Determine column tryptic
peptides_df <- psm_peptide_table[,c("Accession", "Annotated Sequence")]
peptides_df$preAA <- str_sub(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,1], regex("\\[\\w+\\]")),
                             2,
                             str_length(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."),
                                                                    n = 3)[,1], regex("\\[\\w+\\]")))-1)

peptides_df$endAA <- str_sub(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,2], -1, -1)
peptides_df$postAA <- str_sub(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."), n = 3)[,3], regex("\\[\\w+\\]")),
                              2,
                              str_length(str_extract(str_split_fixed(peptides_df$`Annotated Sequence`,regex("\\."),
                                                                     n = 3)[,3], regex("\\[\\w+\\]")))-1)

peptides_df$fully_TRI = (peptides_df$preAA %in% c("K","R") &
                           peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$NSEMI_TRI = (peptides_df$preAA %in% c("K","R") &
                           !peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$CSEMI_TRI = (!peptides_df$preAA %in% c("K","R") &
                           peptides_df$endAA %in% c("K","R") &
                           (peptides_df$postAA != "P" | is.na(peptides_df$postAA)))
peptides_df$non_TRI = (!peptides_df$fully_TRI & !peptides_df$NSEMI_TRI & !peptides_df$CSEMI_TRI)

peptides_df$tryptic_cond[peptides_df$fully_TRI] <- "fully tryptic"
peptides_df$tryptic_cond[peptides_df$NSEMI_TRI] <- "N-semi tryptic"
peptides_df$tryptic_cond[peptides_df$CSEMI_TRI] <- "C-semi tryptic"
peptides_df$tryptic_cond[peptides_df$non_TRI] <- "non tryptic"

psm_peptide_table$tryptic_cond <- peptides_df$tryptic_cond

#Log2
psm_log_pet_df <- psm_sig_pet_df_phos
psm_log_pet_df <- psm_log_pet_df %>% log2()

remove(psm_sig_pet_raw_phos,psm_sig_raw_phos,psm_long_df_phos,psm_filter_df_phos,filter_id_phos,sig_thr, peptides_df, psm_anno_raw_phos, psm_peptide_table_phos)

shiny::setProgress(0.29, detail = "Filtering intensity matrix...")
```

#### Statistics of the proteomics
```{r stat_proteomic, echo=F, message=F, warning=F, results='asis'}
df_stat <- data.frame("number" = c(length(unique(psm_anno_df$symbol)), nrow(psm_log_pet_df)), row.names = c("Discovered proteins in proteomics:", "Discovered peptides in phospho-proteomiscs:"))
kable(df_stat)
```

## 2. Analysis

Raw data consist in the area under the peak (m/z, time, number of events) calculated for PSM (PSMs: peptide-to-spectrum matches).

-   PSMs not consistently present in all replicates of at least 1 condition will be removed.
-   Contaminants are removed.

The intensities are transformed in log2 scale.

#### 2.1. Log2 signal distributions before imputation {.tabset} 
The box plot represents the distribution of the intensity values for each samples in the raw data. This figure is generated before the normalization and imputation of the data.


```{r raw_distributions, message=F, warning=F, echo=F, results='asis'}
cat("\n \n")

psm_long_df <- psm_log_pet_df[,c_anno_phos[order(c_anno_phos$condition),"sample"]] %>% mutate(id=as.factor(rownames(psm_log_pet_df[,c_anno_phos[order(c_anno_phos$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2_intensity")
psm_long_df <- suppressMessages(left_join(psm_long_df,c_anno_phos))

hs<-ggplot(data=psm_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=log2_intensity,fill=sample,colour=sample))+
  #geom_hline(yintercept = 0, lty=2)+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F,colour=NA)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = T)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank()) +
  labs(x = "Log2 Intensity") +
  scale_fill_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Phospho-proteomics distribution \n")
print(hs)
cat("\n \n")

psm_long_df <- psm_log_prot_df[,c_anno_prot[order(c_anno_prot$condition),"sample"]] %>% mutate(id=as.factor(rownames(psm_log_prot_df[,c_anno_prot[order(c_anno_prot$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "log2_intensity")
psm_long_df <- suppressMessages(left_join(psm_long_df,c_anno_prot))

hs<-ggplot(data=psm_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=log2_intensity,fill=sample,colour=sample))+
  #geom_hline(yintercept = 0, lty=2)+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F,colour=NA)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = T)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank()) +
  labs(x = "Log2 Intensity") +
  scale_fill_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Proteomics distribution \n")
print(hs)
cat("\n \n")

shiny::setProgress(0.32, detail = "Calculate distributions...")
```

#### 2.2. Percentage of numeric value in intensity matrix for each sample {.tabset} 
The next graph visualizes the percentage of intensities in the matrix. The percentage of intensity values are counted for each sample separately.

```{r numeric_numbers, echo=F, message=F, warning=F, results='asis'}
cat("\n \n")
numeric_df<- c_anno_phos[c_anno_phos[order(c_anno_phos$condition),"sample"],]
numeric_df$numeric_values<-colSums(is.na(psm_log_pet_df))
numeric_df$numeric_percentage<- 100-(numeric_df$numeric_values/nrow(psm_log_pet_df)*100)
setnames(numeric_df,"numeric_percentage","Percentage of known intensity (%)")
hs<-ggplot(data=numeric_df, aes(x=factor(sample, levels=unique(numeric_df$sample)),y=`Percentage of known intensity (%)`,fill=sample,colour=sample))+
  #geom_hline(yintercept = 0, lty=2)+
  coord_flip()+
  geom_bar(stat="identity",width=.7,alpha=.8)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  labs(x = "Percentage of known intensity (%)") +
  scale_fill_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Phospho-proteomics distribution \n")
print(hs)
cat("\n \n")

numeric_df<- c_anno_prot[c_anno_prot[order(c_anno_prot$condition),"sample"],]
numeric_df$numeric_values<-colSums(is.na(psm_log_prot_df))
numeric_df$numeric_percentage<- 100-(numeric_df$numeric_values/nrow(psm_log_prot_df)*100)
setnames(numeric_df,"numeric_percentage","Percentage of known intensity (%)")
hs<-ggplot(data=numeric_df, aes(x=factor(sample, levels=unique(numeric_df$sample)),y=`Percentage of known intensity (%)`,fill=sample,colour=sample))+
  #geom_hline(yintercept = 0, lty=2)+
  coord_flip()+
  geom_bar(stat="identity",width=.7,alpha=.8)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  labs(x = "Percentage of known intensity (%)") +
  scale_fill_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Proteomics distribution \n")
print(hs)
cat("\n \n")
remove(hs,numeric_df)
shiny::setProgress(0.34, detail = "Doing normalizations...")
```

#### 2.3. Percentage of phosphosite
The following graph represent the percentage of S, T, Y of the phosphosites.

```{r numeric_percentage_phosphosite, echo=F, message=F, warning=F, results='asis'}
cat("\n \n")
if(readPD_files){
  active_sites <- lapply(lapply(stri_extract_all_regex(psm_peptide_table$modif, "\\w\\d+\\(1|\\w\\d+\\.|\\ \\w\\]|\\w\\(1"), 
                                function(x){stri_replace_all(x,regex = "\\ ",replacement = "")}), 
                         function(y){unlist(stri_extract_all_regex(unlist(y), "S|T|Y"))}) %>% unlist() %>% table()
} else{
  active_sites <- lapply(stri_extract_all_regex(psm_peptide_table$`Annotated Sequence`, "\\w\\(1"), 
                         function(x){stri_sub_all(x, from = 1, to = 1)}) %>% unlist() %>% table()
}
numeric_df<- data.frame("Site" = c("S", "T", "Y"),
                        "perc"= c((active_sites["S"]/sum(active_sites)*100), 
                                  (active_sites["T"]/sum(active_sites)*100), 
                                  (active_sites["Y"]/sum(active_sites)*100)),
                        "label"= c(paste(as.character(round(active_sites["S"]/sum(active_sites)*100, digits = 2)), "%"), 
                                   paste(as.character(round(active_sites["T"]/sum(active_sites)*100, digits = 2)), "%"),
                                   paste(as.character(round(active_sites["Y"]/sum(active_sites)*100, digits = 2)), "%")))
setnames(numeric_df,"perc","Percentage of phosphosite (%)")

hs <- ggplot(data=numeric_df, aes(x=Site,y=`Percentage of phosphosite (%)`,fill=Site))+
  # geom_hline(yintercept = c(0, 25, 50, 75, 100), lty=1, alpha=.1)+
  #coord_flip()+
  geom_bar(stat="identity",width=.4,alpha=.95)+
  theme_bw(base_size = bs*1.5, base_family = bf)+
  theme(legend.position = "none")+
  labs(y = "Percentage of the phosphosite (%)") +
  scale_fill_manual(values=c("#F79256", "#FBD1A2", "#7DCFB6")) +
  # scale_colour_manual(values=(colour_vec)) +
  ylim(0, 100) +
  # scale_fill_hue(l=45) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.x = element_blank()) +
  geom_text(data=numeric_df,aes(label=label, y=Inf),fontface="italic", colour=rep("black",3), alpha=0.9,size=0.4*bs,vjust=1.5,hjust=0.5)

print(hs)
cat("\n \n")

remove(hs,numeric_df,active_sites)

shiny::setProgress(0.34, detail = "Doing normalizations...")
```


#### 2.4. Normalization and Imputation
To perform the analysis, two normalization function are applied.
For the Proteomic study, PSMs values were summarized into proteins and normalized across samples, with the "medianSweeping" function contained in the Bioconductor package [DEqMS](<https://www.bioconductor.org/packages/release/bioc/html/DEqMS.html>).
For result of the phospho-proteomic, the normalization is done by the function equalMedianNormalization from  [DEqMS](<https://www.bioconductor.org/packages/release/bioc/html/DEqMS.html>), which normalizes to have equal medians in all samples.

```{r prot_summarization, warning=F, message=F, echo=F}
message("Median normalization in progress...")
gene_anno_df <- psm_anno_df %>% dplyr::select(symbol) %>% unique()

dat_psm <- cbind(psm_anno_df[,c("old_id","symbol")],psm_log_prot_df)
#For peptides analysis
# dat_psm <- cbind(rownames(psm_anno_df),rownames(psm_anno_df),psm_log_df)

# 4 methods to summarise peptides into proteins:
# medianSweeping (also correct intensities so that the median of all proteins is 0)
# medianSummary
# medpolishSummary
# farmsSummary

#Summarize into proteins and normalize by median
dat_gene = DEqMS::medianSweeping(dat_psm,group_col = 2)
remove(gene_anno_df)

# Median centering log2 table for peptides
dat_pep = DEqMS::equalMedianNormalization(psm_log_pet_df)

message("Normalization DONE.")

shiny::setProgress(0.38, detail = "Doing imputation...")
```

The principal imputation method is based on the PhosR package. It is a package for comprehensive analysis of phosphoproteomic data, but it hase two core components: data processing, which has many useful function to manage the raw data, and downstream analysis for the phospho-proteomic analysis.
PhosR is always applied but in some cases, it does not work like when there is only 1 sample in a specific condition. In this rare case, it uses a simpler round imputation. It calculates the mean and the standard deviation of the matrix and it generates the imputed values based on the gaussian function derived.

```{r imputation, echo=F, message=F, warning=F, results='asis'}
message("Imputation of intensity matrix in progress...")
dat_gene<-tryCatch(
  {
    #Imputation with Phospho
    ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(dat_gene)))
    grps <- as.factor(c_anno_prot[colnames(dat_gene), "condition"])
    ppe <- scImpute(ppe, 0.6, grps)
    ppe <- tImpute(ppe, assay = "imputed")
    dat_gene[is.na(dat_gene)]<-ppe@assays@data@listData$imputed[is.na(dat_gene)]
    cat("Done the *PhosR* imputation for proteome \n")
    dat_gene
  },
  error=function(cond){
    # Rounds of imputation
    mat_i <- dat_gene
    col_sele<-colnames(mat_i)

    vec_all<-unlist(mat_i[,col_sele]) # convert to vector
    vec_numeric<-vec_all[-which(is.na(vec_all))] # remove NAs
    orig_stats<-c(mean(vec_numeric),sd(vec_numeric)) # calculate mean and sd
    imp_stats<-c(orig_stats[1]-(orig_stats[2]*1.8),orig_stats[2]*0.3) # imputed mean = mean-1.8*sd, imputed sd = sd*0.3

    set.seed(42)
    imp_matrix<-matrix(rnorm(length(vec_all), mean = imp_stats[1], sd = imp_stats[2]), ncol=ncol(mat_i)) # create matrix of imputed values
    dat_gene[is.na(dat_gene)]<-imp_matrix[is.na(dat_gene)]
    cat("Done *round* imputation for proteome \n")
    dat_gene
  }
)

remove(ppe,grps)

dat_pep<-tryCatch(
  {
    #Imputation with Phospho
    ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(dat_pep)))
    grps <- as.factor(c_anno_phos[colnames(dat_gene), "condition"])
    ppe <- scImpute(ppe, 0.6, grps)
    ppe <- tImpute(ppe, assay = "imputed")
    dat_pep[is.na(dat_pep)]<-ppe@assays@data@listData$imputed[is.na(dat_pep)]
    cat("Done the *PhosR* imputation for phospho-proteome \n")
    dat_pep
  },
  error=function(cond){
    # Rounds of imputation
    mat_i <- dat_pep
    col_sele<-colnames(mat_i)

    vec_all<-unlist(mat_i[,col_sele]) # convert to vector
    vec_numeric<-vec_all[-which(is.na(vec_all))] # remove NAs
    orig_stats<-c(mean(vec_numeric),sd(vec_numeric)) # calculate mean and sd
    imp_stats<-c(orig_stats[1]-(orig_stats[2]*1.8),orig_stats[2]*0.3) # imputed mean = mean-1.8*sd, imputed sd = sd*0.3

    set.seed(42)
    imp_matrix<-matrix(rnorm(length(vec_all), mean = imp_stats[1], sd = imp_stats[2]), ncol=ncol(mat_i)) # create matrix of imputed values
    dat_pep[is.na(dat_pep)]<-imp_matrix[is.na(dat_pep)]
    cat("Done *round* imputation for phospho-proteome \n")
    dat_pep
  }
)

remove(ppe,grps)

shiny::setProgress(0.42, detail = "Done normalization and imputation...")
```

```{r batch_correction, warning=F, message=F, echo=F, eval=batch_corr_exe, results='asis'}
cat("#### 2.4.1. Batch correction {.tabset}  \n")
cat("A batch effect correction is applied to the datased using the proBatch package. \n")
cat("Two MDSs are created, one based on the corrected peptide intensities of the phospho-proteomics analysis, tab **Phospho-proteome**. The second on the corrected protein intensities of the proteomics analysis, tab **Proteome** \n")
cat(" \n \n")

batch_annotation <- c_anno_phos
batch_annotation$order<-c(1:nrow(batch_annotation))

dat_pep_long <- matrix_to_long(dat_pep) %>% setnames("FullRunName","sample")
# loess_fit_df_pep <- adjust_batch_trend_df(dat_pep_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
comBat_df_pep <- correct_with_ComBat_df(dat_pep_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
dat_pep = as.data.frame(long_to_matrix(comBat_df_pep, sample_id_col = "sample"))

batch_annotation <- c_anno_prot
batch_annotation$order<-c(1:nrow(batch_annotation))
dat_gene_long <- matrix_to_long(dat_gene) %>% setnames("FullRunName","sample")
# loess_fit_df_gene <- adjust_batch_trend_df(dat_gene_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
comBat_df_gene <- correct_with_ComBat_df(dat_gene_long, batch_annotation, batch_col="ms_batch", sample_id_col="sample")
dat_gene = as.data.frame(long_to_matrix(comBat_df_gene, sample_id_col = "sample"))

# setnames(c_anno,"FullRunName","sample")

###################
#Peptides
# sample_data<-(t(dat_pep))
# sample_distances <- dist(sample_data, method = "euclidean")
# 
# mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
# colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
# mds_cmdscale$sample <- rownames(mds_cmdscale)
# 
# mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno_phos))
# 
# #Take correct order of color
# cc<-mds_cmdscale$color
# if(is.null(cc)){
#   cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
#   names(cc)<-unique(mds_cmdscale$condition)
# } else{
#   names(cc)<-mds_cmdscale$condition
# }
# 
# cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
#   geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
#   geom_text_repel(aes(label=sample), size=0.15*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
#   scale_colour_manual(values=cc[unique(names(cc))]) +
#   theme_bw(base_size = bs, base_family = bf) +
#   theme(legend.position = "right", panel.grid.minor=element_blank())
# 
# cat("##### Phospho-proteome \n")
# print(cmd)
# cat(" \n \n")
# 
# suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"corrected_mds_phosphoproteomics.pdf"), cmd, device=cairo_pdf, width = 4, height = 3, units = c("in")))
# 
# remove(sample_data,sample_distances,mds_cmdscale,cmd)
# 
# #Proteome
# sample_data<-(t(dat_gene))
# sample_distances <- dist(sample_data, method = "euclidean")
# 
# mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
# colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
# mds_cmdscale$sample <- rownames(mds_cmdscale)
# 
# mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno_prot))
# 
# #Take correct order of color
# cc<-mds_cmdscale$color
# if(is.null(cc)){
#   cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
#   names(cc)<-unique(mds_cmdscale$condition)
# } else{
#   names(cc)<-mds_cmdscale$condition
# }
# 
# cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
#   geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
#   geom_text_repel(aes(label=sample), size=0.15*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
#   scale_colour_manual(values=cc[unique(names(cc))]) +
#   theme_bw(base_size = bs, base_family = bf) +
#   theme(legend.position = "right", panel.grid.minor=element_blank())
# 
# cat("##### Proteome \n")
# print(cmd)
# cat(" \n \n")
# 
# suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"corrected_mds_proteome.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in")))
# 
# remove(sample_data,sample_distances,mds_cmdscale,cmd)

shiny::setProgress(0.53, detail = "Perfom Batch effect correction...")
```

```{r sig_tables, message=F, warning=F, echo=F, results='hide'}

#Save proteins table
expr_mat<-dat_gene

expr_l_df <- expr_mat %>% mutate(id=rownames(expr_mat)) %>% pivot_longer(-id, names_to = "sample", values_to = "expr")
expr_l_df <- suppressMessages(left_join(expr_l_df,c_anno_prot))

#Add Standard Deviation column and average
expr_cond_df<-expr_l_df %>% dplyr::group_by(condition,id) %>%
            dplyr::summarise(N=n(),avg=mean(expr),sd=sd(expr),CV=sd(expr)/mean(expr)) %>% ungroup() %>% mutate("se"=sd/sqrt(N))

expr_avg_df <- expr_cond_df %>% dplyr::select(id,condition,avg) %>% pivot_wider(names_from = condition, values_from = avg)
colnames(expr_avg_df)[-1]<-paste0(colnames(expr_avg_df)[-1],"_avg")

expr_se_df <- expr_cond_df %>% dplyr::select(id,condition,se) %>% pivot_wider(names_from = condition, values_from = se)
colnames(expr_se_df)[-1]<-paste0(colnames(expr_se_df)[-1],"_se")

expr_cv_df <- expr_cond_df %>% dplyr::select(id,condition,CV) %>% pivot_wider(names_from = condition, values_from = CV)
colnames(expr_cv_df)[-1]<-paste0(colnames(expr_cv_df)[-1],"_Coef_Variant_(%)")

expr_avgse_df<- suppressMessages(left_join(left_join(expr_avg_df,expr_se_df),expr_cv_df))
rownames(expr_avgse_df) <- expr_avgse_df$id
toPrint<-expr_avgse_df
colnames(toPrint)[1]<-"symbol"

n_pep_prot <- psm_anno_df %>% dplyr::group_by(symbol, .drop=FALSE) %>% dplyr::summarise("Num. Peptides"=n_distinct(row)) %>% ungroup()
n_pep_prot <- left_join(psm_peptide_table_prot, n_pep_prot, by = c("GeneName" = "symbol"))
colnames(n_pep_prot)[3]<-"symbol"
toPrint_datGene<-dat_gene
toPrint_datGene$symbol<-rownames(dat_gene)

#Export table with SE e MEAN
df_to_save<-list("Proteome Normalized matrix intensity"=left_join(n_pep_prot,toPrint_datGene),
                 "Proteome Normalized intensity group by condition"=left_join(n_pep_prot,toPrint))
# writexl::write_xlsx(df_to_save,paste0(dirOutput,"normalised_intensity_table.xlsx"))
# remove(expr_mat,expr_l_df,expr_cond_df,expr_se_df,expr_avg_df,toPrint)


#Save peptides table
expr_mat<-dat_pep

expr_l_df <- expr_mat %>% mutate(id=rownames(expr_mat)) %>% pivot_longer(-id, names_to = "sample", values_to = "expr")
expr_l_df <- suppressMessages(left_join(expr_l_df,c_anno_phos))

#Add Standard Deviation column and average
expr_cond_df<-expr_l_df %>% dplyr::group_by(condition,id) %>%
            dplyr::summarise(N=n(),avg=mean(expr),sd=sd(expr),CV=sd(expr)/mean(expr)) %>% ungroup() %>% mutate("se"=sd/sqrt(N))

expr_avg_pet_df <- expr_cond_df %>% dplyr::select(id,condition,avg) %>% pivot_wider(names_from = condition, values_from = avg)
colnames(expr_avg_pet_df)[-1]<-paste0(colnames(expr_avg_pet_df)[-1],"_avg")

expr_se_pet_df <- expr_cond_df %>% dplyr::select(id,condition,se) %>% pivot_wider(names_from = condition, values_from = se)
colnames(expr_se_pet_df)[-1]<-paste0(colnames(expr_se_pet_df)[-1],"_se")

expr_cv_pep_df <- expr_cond_df %>% dplyr::select(id,condition,CV) %>% pivot_wider(names_from = condition, values_from = CV)
colnames(expr_cv_pep_df)[-1]<-paste0(colnames(expr_cv_pep_df)[-1],"_Coef_Variant_(%)")

expr_avgse_pep_df<- suppressMessages(left_join(left_join(expr_avg_pet_df,expr_se_pet_df)
                                               ,expr_cv_pep_df))
rownames(expr_avgse_pep_df) <- expr_avgse_pep_df$id
toPrint<-expr_avgse_pep_df

#Prepare the README
readme_sheet <- data.frame("INFO"=c(   NA,
                                "Tables with the normalized and imputed abundances.",
                                NA,
                                "In sheet *Proteome Normalized intensity* is written the normalized and imputed version of the original intensities of each protein in each sample of the proteomics analysis.",
                                "In sheet *Phospho-proteome Normalized intensity* is written the normalized and imputed version of the original intensities of each peptide in each sample of the phospho-proteomics analysis.",
                                "In sheet *Proteome Normalized group by condition* is written the average and the standard deviation of each condition described in the Input file for each protein of the proteomics analysis. Where column *avg* is the average of the replicates, column *se* is the standard error, column *Coef_variant* is the coefficient of variant in %.",
                                "In sheet *Phospho-proteome Normalized group by condition* is written the average and the standard deviation of each condition described in the Input file for each peptide of the phospho-proteomics analysis. Where column *avg* is the average of the replicates, column *se* is the standard error, column *Coef_variant* is the coefficient of variant in %."
                              ))

#Export table with SE e MEAN
df_to_save<-list("README"=readme_sheet,
                 "Phospho-proteome Normalized intensity"=merge(psm_peptide_table, dat_pep, by=0)[,-c(1)],
                 "Proteome Normalized intensity"=df_to_save$`Proteome Normalized matrix intensity`,
                 "Phospho-proteome Normalized group by condition"=left_join(rownames_to_column(psm_peptide_table),
                                                                            toPrint, by=c("rowname" = "id"))[,-c(1)],
                 "Proteome Normalized group by condition"=df_to_save$`Proteome Normalized intensity group by condition`)

writexl::write_xlsx(df_to_save,paste0(dirOutput,subfold_Tab,"normalised_intensity_table.xlsx"))
remove(expr_mat,expr_l_df,expr_cond_df,toPrint)

shiny::setProgress(0.45, detail =  "Save normalized data...")
```

#### 2.5. Normalized distributions {.tabset} 
Box plot of the normalized and imputed data for each sample. In tab "Phospho-proteomics distribution" is represented the normalized distribution of the phospho samples, instead in the second tab there are the nomalized values of the proteomics.

```{r norm_distributions, message=F, warning=F, echo=F, results='asis'}
cat("\n \n")

pg_long_df <- dat_pep[,c_anno_phos[order(c_anno_phos$condition),"sample"]] %>% mutate(id=as.factor(rownames(dat_pep[,c_anno_phos[order(c_anno_phos$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "intensity")
pg_long_df <- suppressMessages(left_join(pg_long_df,c_anno_phos))


hs<-ggplot(data=pg_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=intensity,fill=sample,colour=sample))+
  # ggtitle("Normalized samples")+
  #geom_hline(yintercept = 0, lty=2)+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F,colour=NA)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = F)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  labs(x = "Log2 Intensity") +
  scale_fill_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_phos$color), c_anno_phos$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Phospho-proteomics distribution \n")
print(hs)
cat("\n \n")

pg_long_df <- dat_gene[,c_anno_prot[order(c_anno_prot$condition),"sample"]] %>% mutate(id=as.factor(rownames(dat_gene[,c_anno_prot[order(c_anno_prot$condition),"sample"]]))) %>% pivot_longer(-id, names_to = "sample", values_to = "intensity")
pg_long_df <- suppressMessages(left_join(pg_long_df,c_anno_prot))


hs<-ggplot(data=pg_long_df, aes(x=factor(sample, levels=unique(psm_long_df$sample)),y=intensity,fill=sample,colour=sample))+
  # ggtitle("Normalized samples")+
  #geom_hline(yintercept = 0, lty=2)+
  coord_flip()+
  geom_violin(alpha=0.5,scale="width",trim = F,colour=NA)+
  geom_boxplot(alpha=1,fill="white",width=0.2,outlier.shape = NA, notch = F)+
  theme_bw()+
  theme(legend.position = "none",axis.title.y = element_blank())+
  labs(x = "Log2 Intensity") +
  scale_fill_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  scale_colour_manual(values=setNames(as.list(c_anno_prot$color), c_anno_prot$sample)) +
  theme(panel.grid.minor = element_blank(),panel.grid.major.y = element_blank())

cat("##### Proteomics distribution \n")
print(hs)
cat("\n \n")

remove(hs, pg_long_df)

shiny::setProgress(0.47, detail =  "Calculate post-norm distribution...")
```


```{r mds_counts, warning=F, message=F, echo=F, results='asis'}
cat(" \n \n")
cat("#### 2.6. Multi-dimensional reduction analysis of samples {.tabset}  \n")
cat("Following are visualized the Multi-dimensional scaling analysis (MDSs) of the normalized data. The MDS in its simpler version is called PCA. Each sample has its own color described in the Sample_Annotation file, if it was not defined it is used the default palette coloring by condition. \n")
cat("Two MDSs are created, one based on the normalized peptide intensities of the phospho-proteomics analysis, tab **Phospho-proteome**. The second on the normalized protein intensities of the proteomics, tab **Proteome** \n")
cat(" \n \n")

#Peptides
sample_data<-(t(dat_pep))
sample_distances <- dist(sample_data, method = "euclidean")

mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
mds_cmdscale$sample <- rownames(mds_cmdscale)

mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno_phos))

#Take correct order of color
cc<-mds_cmdscale$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
  names(cc)<-unique(mds_cmdscale$condition)
} else{
  names(cc)<-mds_cmdscale$condition
}


cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
  geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  scale_colour_manual(values=cc[unique(names(cc))]) +
  theme_bw(base_size = bs, base_family = bf) +
  theme(legend.position = "right", panel.grid.minor=element_blank())

cat("##### Phospho-proteome \n")
print(cmd)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"general_mds_phosphoproteome.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in")))

#PROTEOMICS
sample_data<-(t(dat_gene))
sample_distances <- dist(sample_data, method = "euclidean")

mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
mds_cmdscale$sample <- rownames(mds_cmdscale)

mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno_prot))

#Take correct order of color

cc<-mds_cmdscale$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
  names(cc)<-unique(mds_cmdscale$condition)
} else{
  names(cc)<-mds_cmdscale$condition
}

cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
  geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  scale_colour_manual(values=cc[unique(names(cc))]) +
  theme_bw(base_size = bs, base_family = bf) +
  theme(legend.position = "right", panel.grid.minor=element_blank())

cat("##### Proteome \n")
print(cmd)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"general_mds_proteome.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,cmd)

shiny::setProgress(0.49, detail = "Calculate MDS...")
```

```{r pca_norm, warning=F, message=F, echo=F, results='asis'}
cat(" \n \n")
cat("#### 2.7. PCA analysis of samples {.tabset}  \n")
cat("Following are visualized the Principal Component analysis (PCA) of the normalized data. Each sample has its own color described in the Sample_Annotation file, if it was not defined it is used the default palette coloring by condition. \n")
cat("Two PCAs are created, one based on the normalized peptide intensities of the phospho-proteomics analysis, tab **Phospho-proteome**. The second on the normalized protein intensities of the proteomics, tab **Proteome** \n")
cat(" \n \n")

#Peptides
sample_data<-(t(dat_pep))
apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
pc <- apca_prot$x[,1:2]

pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
pc<- merge(pc, c_anno_phos, by = 0)
pc$condition <- as.factor(pc$condition)

ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
ve <- ve[c(1, 2)]
labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

#Take correct order of color
cc<-pc$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(pc$condition))]
  names(cc)<-unique(pc$condition)
} else{
  names(cc)<-pc$condition
}
#ggplot method
p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
      geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
      geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
      scale_colour_manual(values=cc[unique(names(cc))]) +
      theme_bw(base_size = bs, base_family = bf) +
      theme(legend.position = "right", panel.grid.minor=element_blank()) +
      xlab(labs[1]) +
      ylab(labs[2])

cat("##### Phospho-proteome \n")
print(p1)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"general_PCA_phosphoproteome.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,p1)

#Proteome
sample_data<-(t(dat_gene))
apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
pc <- apca_prot$x[,1:2]

pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
pc<- merge(pc, c_anno_prot, by = 0)
pc$condition <- as.factor(pc$condition)

ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
ve <- ve[c(1, 2)]
labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

#Take correct order of color
cc<-pc$color
if(is.null(cc)){
  cc<-colour_vec[1:length(unique(pc$condition))]
  names(cc)<-unique(pc$condition)
} else{
  names(cc)<-pc$condition
}

#ggplot method
p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
      geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
      geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
      scale_colour_manual(values=cc[unique(names(cc))]) +
      theme_bw(base_size = bs, base_family = bf) +
      theme(legend.position = "right", panel.grid.minor=element_blank()) +
      xlab(labs[1]) +
      ylab(labs[2])

cat("##### Proteome \n")
print(p1)
cat(" \n \n")

suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"general_PCA_proteome.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

remove(sample_data,sample_distances,mds_cmdscale,cmd)

shiny::setProgress(0.51, detail = "Calculate PCA...")
```


```{r boxplot_proteins, warning=F, message=F, echo=F, eval=boxplot_prot_exe, results='asis'}
prot_find<-unique(c(intersect(prot_boxplot,psm_peptide_table$GeneName),
                    intersect(str_to_title(prot_boxplot),psm_peptide_table$GeneName),
                    intersect(str_to_upper(prot_boxplot),psm_peptide_table$GeneName),
                    intersect(str_to_lower(prot_boxplot),psm_peptide_table$GeneName)))

if(length(prot_find)>0){
  cat("#### 2.9. Control boxplot proteins intensities {.tabset}  \n")
  cat("Boxplot figures for the control of the intensities of selected proteins. The list of proteins need to be written in the options file. For each protein shows the intensity group by condition. \n")
  cat("Selected proteins identified in the normalized list: \n")
  cat(paste(prot_find, sep = ", "))
  cat(" \n")
  cat(" \n \n")

  prot_intensity_long <- as.data.table(dat_pep[rownames(psm_peptide_table[which(psm_peptide_table$GeneName %in% prot_find),]),])
  prot_intensity_long$genename <- psm_peptide_table[which(psm_peptide_table$GeneName %in% prot_find),"GeneName"]
  prot_intensity_long <- prot_intensity_long[,lapply(.SD,mean,na.rm=TRUE),by=genename,.SDcols=colnames(dat_pep)] %>% as.data.frame()
  prot_intensity_long<-prot_intensity_long[,c(-1)]
  rownames(prot_intensity_long)<-prot_find
  prot_intensity_long <- proBatch::matrix_to_long(prot_intensity_long) %>%
                              data.table::setnames(new = c("Protein","Condition","Intensity"))
  prot_intensity_long <- unique((left_join(prot_intensity_long,
                                             c_anno_phos[prot_intensity_long$Condition, c("sample","condition")],
                                             by=c("Condition"="sample")))[,-c(2)])  %>%
                              data.table::setnames(new = c("Protein","Intensity","Condition"))
    

  expr_cond_df<-prot_intensity_long %>% dplyr::group_by(Condition,Protein) %>%
            dplyr::summarise(N=n(),avg=mean(Intensity),sd=sd(Intensity)) %>% ungroup() %>% mutate("se"=sd/sqrt(N))
  prot_avg_se_long <- expr_cond_df[, c("Condition","Protein","avg","se")]
  
  #Take correct order of color
  cc<-c_anno_phos$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(c_anno_phos$condition))]
    names(cc)<-unique(c_anno_phos$condition)
  } else{
    names(cc)<-c_anno_phos$condition
  }
  cc<-unique(cc)
    # save(prot_intensity_long, cc, bs, bf,cc, prot_avg_se_long, dat_gene, prot_find, c_anno, file = "tmp_2.RData")
  g<-ggplot(prot_avg_se_long,aes(Condition,avg,fill=Condition,colour=Condition))+
    geom_crossbar(aes(ymin=avg,ymax=avg),position = "dodge",width=.8,alpha=.9,fatten=1.5)+
    geom_errorbar(aes(ymin=(avg-se), ymax=(avg+se)), width=.4,position=position_dodge(),show.legend=F,alpha=.8)+
    geom_quasirandom(data=prot_intensity_long, aes(Condition,Intensity), alpha=.7,width=.1,shape=16,size=0.11*bs)+
    scale_fill_manual(name="Condition",values=cc[sort(unique(prot_intensity_long$Condition))]) +
    scale_colour_manual(name="Condition",values=cc[sort(unique(prot_intensity_long$Condition))])+
    # scale_y_continuous(limits=c(0,NA),expand = expand_scale(mult = c(.1, .25)))+
    theme_bw(base_size = bs, base_family = bf) +
    theme(axis.title.x=element_blank()) +
    theme(axis.text.x = element_text(angle = 30, hjust = 1, colour=cc[sort(unique(prot_intensity_long$Condition))]))+
    theme(panel.grid.major.x=element_blank(),
          panel.grid.minor.y=element_blank())+
    theme(legend.text = element_text(size = 0.7*bs),
          legend.key.size = unit((0.015*bs),"in"),
          legend.position="none",
          legend.title=element_blank(),
          legend.background = element_rect(fill = NA))+

    theme(strip.text=element_text(colour="white",face="bold"))+
    theme(panel.border=element_rect(colour=c("grey40"),size=0.03*bs))+
    theme(strip.background=element_rect(fill="grey40",colour="grey40",size=0.03*bs))+
    theme(plot.title = element_text(hjust = 0.5))+
    facet_wrap(~Protein, scales = "free",ncol = if(length(prot_find)>4){round(length(prot_find)/1.9)}else{4})+
    labs(y="Abundance")
  print(g)

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"boxplot_control_intensity.pdf"), g, device=cairo_pdf, 
                          width = ((if(length(prot_find)<4){((length(prot_find)-1/(length(prot_find)))^1.2)*0.9}else{(4*1.2)*0.9}))+(0.75*length(unique(prot_avg_se_long$Condition))), 
                          height = 4*(if(length(prot_find)>=4){(length(prot_find) %/% 4)+1}else{1}), units = c("in")))

}else{
  cat("##### Selected proteins in options file do not find in the normalised matrix. Check the spell of the proteins. \n")
  cat(" \n \n")
}

shiny::setProgress(0.56, detail = "Control boxplot proteins...")
```

## 3. Identification of Differentially Expressed Peptides of the phospho-proteomic

Differential expression analysis for phospho-proteomics is performed with the Limma package. First are reported the comparison for which PhosProTN execute the differential analysis. Other than the formula desired by the user, for each condition is studied the differentiality between the phospho samples against the proteomic samples. 

The conditions from the phospho-proteomics are represented by an **_p** at the end of the condition, the **_i** represent the conditions from the proteomics. Also, the comparison provided in input by the user are adapted for the phospho differential analysis.

```{r diff_analysis,  warning=F, message=F, echo=F}
shiny::setProgress(0.58, detail = "Differential Analysis in progress...")
message("Differentiation analysis in progress...")

c_anno_phos$sample <- str_c(c_anno_phos$sample, "_p")
c_anno_prot$sample <- str_c(c_anno_prot$sample, "_i")
c_anno <- rbind(c_anno_phos,c_anno_prot)

colnames(dat_pep) <- str_c(colnames(dat_pep), "_p")
colnames(dat_gene) <- str_c(colnames(dat_gene), "_i")
dat_gene$genename <- rownames(dat_gene)
dat_pep$genename <- psm_peptide_table[match(rownames(dat_pep),paste(psm_peptide_table$GeneName, 
                                                                    psm_peptide_table$`Annotated Sequence`, 
                                                                    psm_peptide_table$Modifications, sep="_")),"GeneName"]
dat_pep$names <- rownames(dat_pep)
dat_complete <- inner_join(dat_pep, dat_gene)
rownames(dat_complete) <- dat_complete$names
dat_complete <- dat_complete %>% dplyr::select(-c("genename", "names"))

dat_pep <- dat_pep %>% dplyr::select(-c("genename", "names"))

colnames(expr_avgse_pep_df)[1] <- "names"
expr_avgse_pep_df$id <- psm_peptide_table[rownames(expr_avgse_pep_df),"GeneName"]
expr_avgse_complete_df <- inner_join(expr_avgse_pep_df, expr_avgse_df)
rownames(expr_avgse_complete_df) <- expr_avgse_complete_df$names
expr_avgse_complete_df <- expr_avgse_complete_df %>% dplyr::select(-c("id"))
colnames(expr_avgse_complete_df)[1] <- "id"

#Execution of differentiation analysis using DEqMS for proteins
psm_count_table<-as.data.frame(table(rownames(dat_pep)))
#Make the design
df <- data.frame("p" = unique(sort(str_remove(c_anno_phos$condition, "_p\\b"))), "i" = unique(sort(str_remove(c_anno_prot$condition, "_i\\b"))))
df <- unique(df[match(df$p, df$i),])
df$rule <- str_c(str_c(df$p, "_p"), "-", str_c(df$i, "_i"))
contro_list <- df$rule

contro_list<-c(contro_list,
               str_c(str_c("(", stringi::stri_replace_all_regex(formule_contrast, str_c("\\b",df$p,"\\b"), str_c(df$p, "_p"), vectorize = FALSE), ")"),
                     "-",
                     str_c("(", stringi::stri_replace_all_regex(formule_contrast, str_c("\\b",df$p,"\\b"), str_c(df$p, "_i"), vectorize = FALSE), ")"))
               )
names(contro_list) <- make.names(c(str_c(df$p,"_PhosphoEnr"), names(formule_contrast)), unique = T)

save(list=ls(), file="tmp.RData")

if(length(contro_list) > 0){
  deps_pep_df <- limmafnc("PEP",c_anno,dat_complete,psm_count_table,contro_list,expr_avgse_complete_df,signal_thr,fc_thr, pval_thr, pval_fdr)
}
deps_pep_l_df<-deps_pep_df$degs_l_df
deps_pep_w_df<-deps_pep_df$degs_w_df
toPrint_pep<-deps_pep_w_df

#Prepare the README
readme_sheet <- data.frame("INFO"=c(NA,
                                "Summary of the differential analysis done with DeqMS and Limma",
                                NA,
                                "In each sheet, the columns are:",
                                "1. *Accession* is the UniprotID of protein,",
                                "2. *Description* is the description of protein,",
                                "3. *GeneName* is Gene Symbol,",
                                "4. *Annotated Sequence* is the sequence of peptides,",
                                "5. *Modifications* is the modification that affect the peptides,",
                                "6. *Position in Master Proteins* is the UniprotID with the position on the sequence,",
                                NA,
                                "And for each comparison:",
                                "7. *class*: is ‚Äú+‚Äù if the protein is up-regulated following the parameters set reported in the report.html, 
                                    ‚Äú-‚Äù if the protein is down-regulated, ‚Äú=‚Äù otherwise",
                                "8. *log2_FC*: is the log2 Fold Change of the contrast",
                                "9. *p_val*: is the p.value",
                                "10. *p_adj*: is the adjusted p.value",
                                "11. *log2_expr*: is the signal log2 expression"
                              ))

#Export table with SE e MEAN
df_to_save<-list("README"=readme_sheet,
                 "DEPs_PhosphoProteome"=inner_join(rownames_to_column(psm_peptide_table), toPrint_pep, by=c("rowname" = "id"))[,-c(1)])
writexl::write_xlsx(df_to_save,paste0(dirOutput,subfold_Tab,"DEPs_table.xlsx"))

formule_contrast <- contro_list

remove(deps_df,toPrint,deps_pep_df,toPrint_pep,df_to_save)
message("Differentation analysis DONE.")

```

#### Constrast design used for the differential analysis
The following formulas are the comparison on which is performed the differential analysis.

```{r print_settings_design, warning=FALSE, echo=F, message=FALSE, results='asis'}
cat("**Contrast design formula are:** ")
cat(" \n")
kable(formule_contrast, col.names = c("Limma Formula"))
cat(" \n")

```

#### Number of DEPs for each comparison
In the folllowing plot is represented graphically the number of DEPs for each contrast desscribed previously.

```{r number_deps, warning=FALSE, echo=FALSE, results='asis'}
# Plot DEPs barplot (as a double barplot)

plot_DEPs<-function(DEPs_df, # dataframe containing DEPs result
                    contrast_col="comp", # Name of the column with contrast names
                    class_col="class", # Name of the column with classes (+,-,= are expected)
                    color_vec=c("#EAB364", "#84A298") # Colors for Up and Down regulated
                     ){
  res_mat<-DEPs_df %>% group_by(get(contrast_col),get(class_col),.drop=FALSE) %>% summarise("Number"=n()) %>% ungroup()
  # get() to return the value of variable
  # in this way we can assign the name of the column to a variable and keep the same script changing every time only the name of the column
  # .drop=FALSE to keep the comparisons with zero-value classes (for example in the fdr df)
  colnames(res_mat)<-c("Contrast","Class","Number")
  res_df<-res_mat %>% filter(Class!="=")

  res_df$Class<-factor(res_df$Class,levels=c("+","-"))
  res_df$Contrast<-as.factor(res_df$Contrast)
  res_df$Number<-as.numeric(res_df$Number)
  res_df$Number[which(res_df$Class=="-")]<-res_df$Number[which(res_df$Class=="-")]*(-1)
  # *(-1) to assign to the total number of down-reg a - sign and put them on the left of the plot

  #Change ratio based on the number of comp
  n_comp<-length(unique(res_df$Contrast))
  # ratio<-1/((5/n_comp)+0.25)
  bs<-11
  bap<-ggplot(res_df,aes(x=Contrast,y=Number,fill=Class)) +
    scale_fill_manual(name="",values=color_vec,labels=c("Up-Regulated","Down-Regulated"))+
    geom_bar(stat="identity",position=position_nudge(),width=0.6,alpha=0.9) +
    geom_text(aes(x=Contrast, y=Number, label=abs(Number), hjust=ifelse(res_df$Number>=0,1,-0)), colour="white",size=bs*0.4,fontface="plain") +
    theme_bw(base_size = bs) +
    theme(axis.title.y=element_blank()) +
    theme(panel.border=element_blank()) +
    theme(axis.ticks=element_blank()) +
    theme(panel.grid=element_blank()) +
    # theme(aspect.ratio = ratio) +
    geom_hline(yintercept=0,col="grey30",lty=1,lwd=0.05*bs)+
    theme(axis.text.y=element_text(colour="grey20")) +
    theme(axis.text.x=element_blank()) +
    theme(legend.position="bottom") +
    #theme(legend.justification=c(1.05,1.05), legend.position=c(1,0.07)) +
    theme(legend.title=element_blank())+
    coord_flip()+
    theme(legend.text = element_text(size = bs),
          legend.key.size = unit((0.012*bs),"in"))+
    labs(y="Number of DEPs")
  return(bap)
}

cat(" \n \n")
#Peptides
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat(" \n \n")
  heig<-unique(deps_pep_l_df$comp)
  pDEPs<-plot_DEPs(deps_pep_l_df,
                    contrast_col="comp",
                    class_col="class",
                    color_vec=c("grey60", "grey40"))
  oldheig <- knitr::opts_chunk$get("fig.height")
  knitr::opts_chunk$set(fig.height = max(min(20,length(heig)*0.75),2))
  print(pDEPs)
  cat(" \n \n")
  knitr::opts_chunk$set(fig.height = oldheig)

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"DEPs_peptides_count_barplot.pdf"), pDEPs, device=cairo_pdf,
                          height = max(min(20,length(heig)*0.75),2), units = c("in")))
  remove(pDEPs,cmd,mds_cmdscale)
}else{
  message("No gene differentiated discovered.")
  cat("No gene differentiated discovered.")
}

shiny::setProgress(0.60, detail = "Count DEPs...")
```

```{r volcano_protein, fig.height=6, fig.width=6, warning=FALSE, echo=FALSE, results='asis', eval=F}
cat(" \n \n")
if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){

  cat("#### 3.1.1. Volcano plot of Proteins {.tabset}  \n")
  cat("In the tabs below, the figures represent the volcano plots of differentially expressed proteins. Each condition has its own tab with the correspoding figure. \n \n ")
  cat("The line in the volcano are the threshold set. \n \n ")
  cat("Class identify the state of the protein. \"+\" are the Up-regulated DEPs, \"-\" are the Down-regulated DEPs, \"=\" are the non-significative DEPs. The tool writes the labels of the proteins which can fit in the graph. \n")
  cat(" \n \n")

  for(comp in unique(deps_l_df$comp)){
    input_df <- deps_l_df[which(deps_l_df$comp == comp),]
    labels_up <- (input_df %>% filter(class == '+'))$id
    labels_down <- (input_df %>% filter(class == '-'))$id

    cmd<-ggplot(data=input_df, aes(x=log2_FC, y=-log10(if(pval_fdr){p_adj}else{p_val}), col=class, label=id)) +
      geom_point(pch=20,cex=2) +
      geom_hline(yintercept=-log10(pval_thr), col="black") +
      geom_vline(xintercept=c(-fc_thr, fc_thr), col="black") +
      # geom_text_repel(data = input_df %>% filter(id %in% labels),color="white") +
      geom_label_repel(data = input_df %>% filter(id %in% labels_up), label.padding = unit(0.1, "lines"), color="black",xlim = c(1.5, NA)) +
      geom_label_repel(data = input_df %>% filter(id %in% labels_down), label.padding = unit(0.1, "lines"), color="black",xlim = c(NA, -1.5)) +
      ggtitle(paste0("Volcano Plot of ",comp)) +
      ylab(if(pval_fdr){"-log10(fdr)"}else{"-log10(p_val"}) +
      scale_color_manual(values=c(color_constrast[comp,"color_constrast"], color_constrast[comp,"color_constrast_dark"], "grey70")) +
      scale_x_continuous(limits = c(min(-max(abs(input_df$log2_FC)),-3), max(max(abs(input_df$log2_FC)),3))) +
      scale_y_continuous(limits = c(0, max(max(abs(-log10(if(pval_fdr){input_df$p_adj}else{input_df$p_val}))),4))) +
      theme_bw(base_size = bs, base_family = bf)

    cat("##### ",comp," \n")
    print(cmd)
    cat(" \n \n")
  }
shiny::setProgress(0.63, detail = "Perform volcano plot...")
}

```

```{r volcano_pep, fig.height=6, fig.width=6, warning=FALSE, echo=FALSE, results='asis'}
col_sigle_contrast <- data.frame("color_constrast"=c_anno[match(df$p, str_remove(c_anno$condition, "_p\\b|_i\\b")),"color"], "color_constrast_dark"=c(""), row.names = paste0(df$p, "_default"))
# darker.col = function(color, how.much = 50){
#     colorRampPalette(c(color, "black"))(100)[how.much]
# }
for(col in rownames(col_sigle_contrast)){
  col_sigle_contrast[col,"color_constrast_dark"]<-darker.col(col_sigle_contrast[col,"color_constrast"])
}
color_constrast<-rbind(color_constrast,col_sigle_contrast)

cat(" \n \n")
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){

  cat("#### 3.1.2. Volcano plot {.tabset}  \n")
  cat("In the tabs below, the figures represent the volcano plots of differentially expressed peptides. Each condition has its own tab with the correspoding figure. \n \n The line in the volcano are the threshold set. \n \n Class identify the state of the peptides. \"+\" are the Up-regulated DEPs, \"-\" are the Down-regulated DEPs, \"=\" are the non-significative DEPs. The tool writes the labels of the peptides which can fit in the graph. \n")
  cat(" \n \n")

  for(comp in unique(deps_pep_l_df$comp)){
    input_df <- na.omit((deps_pep_l_df[which(deps_pep_l_df$comp == comp),])[order(deps_pep_l_df$id),])
    input_df$id <- psm_peptide_table[input_df$id, "GeneName"]
    # pos<-lapply(str_match_all(str_split(psm_peptide_table$`Position in Master Proteins`,";",n=1),"\\[(.*?)\\]"), function(x){x[,1][1]})
    # labels<-str_c(psm_peptide_table$GeneName,pos,sep="_")
    # input_df$id<-labels
    labels_up <- (input_df[order(input_df$p_val),] %>% filter(class == '+'))$id
    labels_up <- labels_up[1:min(100, length(labels_up))]
    labels_down <- (input_df[order(input_df$p_val),] %>% filter(class == '+'))$id
    labels_down <- labels_down[1:min(100, length(labels_down))]

    cmd<-ggplot(data=input_df, aes(x=log2_FC, y=-log10(if(pval_fdr){p_adj}else{p_val}), col=class, label=id)) +
      geom_point(pch=20,cex=2) +
      geom_hline(yintercept=-log10(pval_thr), col="black") +
      geom_vline(xintercept=c(-fc_thr, fc_thr), col="black") +
      # geom_text_repel(data = input_df %>% filter(id %in% labels),color="white") +
      geom_label_repel(data = input_df %>% filter(id %in% labels_up, class == '+'),
                       label.padding = unit(0.1, "lines"), color="black",xlim = c(1.5, NA)) +
      geom_label_repel(data = input_df %>% filter(id %in% labels_down, class == '-'),
                       label.padding = unit(0.1, "lines"), color="black",xlim = c(NA, -1.5)) +
      ggtitle(paste0("Volcano Plot of ",comp)) +
      ylab(if(pval_fdr){"-log10(fdr)"}else{"-log10(p_val"}) +
      scale_color_manual(values=c(color_constrast[comp,"color_constrast"], color_constrast[comp,"color_constrast_dark"], "grey70")) +
      scale_x_continuous(limits = c(min(-max(abs(input_df$log2_FC)),-3), max(max(abs(input_df$log2_FC)),3))) +
      scale_y_continuous(limits = c(0, max(max(abs(-log10(if(pval_fdr){input_df$p_adj}else{input_df$p_val}))),4))) +
      theme_bw(base_size = bs, base_family = bf)

    cat("##### ",comp," \n")
    print(cmd)
    cat(" \n \n")
  }
shiny::setProgress(0.65, detail = "Perform volcano plot...")
}

```

```{r MDS_prot_deps, warning=F, message=F, echo=F, eval=T, results='asis', eval =F}
if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat("#### 3.2.1. Multi-dimensional reduction analysis of samples based on up-/down-regulated proteins \n")
  cat("The below figure is the MDS analysis on the significative differentially expressed proteins. \n \n")
  #Select only genes that are differentiated and print PCA of samples
  deps_vec_all<- deps_l_df %>% dplyr::filter(class!="=") %>%
  pull(id) %>% unique() %>% sort()

  # sample_data<-t(dat_gene[toupper(deps_vec_all),])
  sample_data<-t(dat_gene[(deps_vec_all),])

  sample_distances <- dist(sample_data, method = "euclidean")

  mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
  colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
  mds_cmdscale$sample <- rownames(mds_cmdscale)

  mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno_prot))
  #Take correct order of color
  cc<-mds_cmdscale$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
    names(cc)<-unique(mds_cmdscale$condition)
  } else{
    names(cc)<-mds_cmdscale$condition
  }
  cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
    # ggtitle("samples")+
    geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
    geom_text_repel(aes(label=sample), size=0.15*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
    scale_colour_manual(values=cc[unique(names(cc))]) +
    theme_bw(base_size = bs, base_family = bf) +
    theme(legend.position = "right", panel.grid.minor=element_blank())

  print(cmd)

  ggsave(paste0(dirOutput,subfold_Fig,"DEPs_proteins_mds.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in"))

  shiny::setProgress(0.67, detail = "Perform MDS...")

}

```

```{r MDS_deps_pep, warning=F, message=F, echo=F, eval=T, results='asis'}
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  cat("#### 3.2.2. Multi-dimensional reduction analysis of samples based on up-/down-regulated peptides of the phospho-proteomics \n")
  cat("The below figure is the MDS analysis on the significative differentially expressed peptides of the phosphoproteome. \n \n")
  #Select only genes that are differentiated and print PCA of samples
  deps_vec_all<- deps_pep_l_df %>% dplyr::filter(class!="=") %>%
                    pull(id) %>% unique() %>% sort()

  # sample_data<-t(dat_gene[toupper(deps_vec_all),])
  sample_data<-t(dat_pep[(deps_vec_all),])

  sample_distances <- dist(sample_data, method = "euclidean")

  mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
  colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
  mds_cmdscale$sample <- rownames(mds_cmdscale)

  mds_cmdscale <- suppressMessages(left_join(mds_cmdscale,c_anno_phos))
  #Take correct order of color
  cc<-mds_cmdscale$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(mds_cmdscale$condition))]
    names(cc)<-unique(mds_cmdscale$condition)
  } else{
    names(cc)<-mds_cmdscale$condition
  }
  cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
    # ggtitle("samples")+
    geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
    geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
    scale_colour_manual(values=cc[unique(names(cc))]) +
    theme_bw(base_size = bs, base_family = bf) +
    theme(legend.position = "right", panel.grid.minor=element_blank())

  print(cmd)

  ggsave(paste0(dirOutput,subfold_Fig,"DEPs_mds_phosphoproteome.pdf"), cmd, device=cairo_pdf, width = (3+(0.13*nrow(mds_cmdscale))), height = (3+(0.07*nrow(mds_cmdscale))), units = c("in"))

shiny::setProgress(0.69, detail = "Perform MDS...")
}

```

```{r pca_deps, warning=F, message=F, echo=F, results='asis'}
  cat(" \n \n")
  cat("#### 3.3. PCA analysis of samples based on up-/down-regulated peptides of the phospho-proteome  \n")
  cat("Following are visualized the Principal Component analysis (PCA) of the normalized data. Each sample has its own color described in the Sample_Annotation file, if it was not defined it is used the default palette coloring by condition. \n")
  cat("The PCA is the representation of the differentially expressed peptides of the phosphoproteome, tab **Phospho-proteome** \n")
  cat(" \n \n")
######################
# if(deps_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){  
# 
# shiny::setProgress(0.70, detail = "Perform PCA...")
# 
#   deps_vec_all<- deps_l_df %>% dplyr::filter(class!="=") %>%
#   pull(id) %>% unique() %>% sort()
# 
#   # sample_data<-t(dat_gene[toupper(deps_vec_all),])
#   sample_data<-t(dat_gene[(deps_vec_all),])
#   apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
#   pc <- apca_prot$x[,1:2]
# 
#   pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
#   pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
#   pc<- merge(pc, c_anno_prot, by = 0)
#   pc$condition <- as.factor(pc$condition)
# 
#   ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
#   ve <- ve[c(1, 2)]
#   labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")
# 
#   #Take correct order of color
#   cc<-pc$color
#   if(is.null(cc)){
#     cc<-colour_vec[1:length(unique(pc$condition))]
#     names(cc)<-unique(pc$condition)
#   } else{
#     names(cc)<-pc$condition
#   }
#   #ggplot method
#   p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
#         geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
#         geom_text_repel(aes(label=sample), size=0.15*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
#         scale_colour_manual(values=cc[unique(names(cc))]) +
#         theme_bw(base_size = bs, base_family = bf) +
#         theme(legend.position = "right", panel.grid.minor=element_blank()) +
#         xlab(labs[1]) +
#         ylab(labs[2])
# 
#   cat("##### Proteins \n")
#   print(p1)
#   cat(" \n \n")
# 
#   suppressMessages(ggsave(paste0(dirOutput,"DEPs_proteins_PCA.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))
# 
#   remove(sample_data,sample_distances,mds_cmdscale,cmd)
# }
######################

cat(" \n \n")
if(deps_pep_l_df %>% dplyr::filter(class!="=") %>% nrow() > 0){
  #Peptides
  deps_vec_all<- deps_pep_l_df %>% dplyr::filter(class!="=") %>%
  pull(id) %>% unique() %>% sort()

  # sample_data<-t(dat_gene[toupper(deps_vec_all),])
  sample_data<-t(dat_pep[(deps_vec_all),])
  apca_prot <- sample_data %>% prcomp(scale = TRUE, center = TRUE)
  pc <- apca_prot$x[,1:2]

  pc[,"PC1"] <- as.numeric(pc[,"PC1"]) / (apca_prot$sdev[1] * sqrt(nrow(sample_data)))
  pc[,"PC2"] <- as.numeric(pc[,"PC2"]) / (apca_prot$sdev[2] * sqrt(nrow(sample_data)))
  pc<- merge(c_anno_phos, pc, by.x = "sample", by.y = "row.names")
  pc$condition <- as.factor(pc$condition)

  ve <- apca_prot$sdev^2/sum(apca_prot$sdev^2)
  ve <- ve[c(1, 2)]
  labs <- paste0(colnames(pc)[c(2,3)], " (", round(ve * 100, 2), "%)")

  #Take correct order of color
  cc<-pc$color
  if(is.null(cc)){
    cc<-colour_vec[1:length(unique(pc$condition))]
    names(cc)<-unique(pc$condition)
  } else{
    names(cc)<-pc$condition
  }
  #ggplot method
  p1 <- ggplot(pc, aes(PC1, PC2, colour = condition)) +
        geom_point(size=1.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
        geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
        scale_colour_manual(values=cc[unique(names(cc))]) +
        theme_bw(base_size = bs, base_family = bf) +
        theme(legend.position = "right", panel.grid.minor=element_blank()) +
        xlab(labs[1]) +
        ylab(labs[2])

  # cat("##### Phospho-proteome \n")
  print(p1)
  cat(" \n \n")

  suppressMessages(ggsave(paste0(dirOutput,subfold_Fig,"DEPs_phosphoproteome_PCA.pdf"), p1, device=cairo_pdf, width = (3+(0.13*nrow(pc))), height = (3+(0.07*nrow(pc))), units = c("in")))

  remove(sample_data,sample_distances,mds_cmdscale,p1)
}

```


```{r enrichment_universe,message=F, warning=F,echo=F, eval=run_enrich_universe, results='asis'}
shiny::setProgress(0.75, detail = "Enrichment in progress whole Universe in background... \n Can require several minutes...")

message("Enrichment in progress whole Universe in background... \n Can require several minutes...")
#Perform enriched analysis with EnrichR
p = callr::r_bg(
    func = function(g, pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr) {
      source("functions_2021.R")
      enrichRfnc_universe(g, pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr)
    },
    args = list(unique(psm_peptide_table[deps_pep_l_df[which(deps_pep_l_df$comp %in% names(formule_CORAL)), "id"], "GeneName"]), pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr),
    stdout = "|",
    stderr = "|",
    error = getOption("callr.error", "error")
  )

```

```{r enrichment,message=F, warning=F,echo=F, eval=run_enrich, results='asis'}
shiny::setProgress(0.75, detail = "Enrichment in progress... \n Can require several minutes...")
cat(" \n \n")
cat("## 4. Functional analysis of Differentially Expressed Proteins \n")
cat("The enrichment analysis is done by [EnrichR](https://maayanlab.cloud/Enrichr/). It is a web-base application which integrates a large number of data sets that permit to obtain information about many categories. EnrichR organises its hundreds of data sets in 8 sections: Transcription, Pathways, Ontologies, Diseases/Drugs, Cell Types, Misc, Legacy, and Crowd. All the libraries of EnrichR are queried to provide the most complete research. \n \n ")
cat(" Each comparison is analysed through 3 sets of proteins: the Up-regulated (called **UP**), the Down-regulated (called **DOWN**), and the set (called **ALL**) obtained by the merge of Up- and Down-regulated proteins. \n")
def_val_height=  knitr::opts_chunk$get("fig.height")
message("Enrichment step with EnrichR in proress...")
doNextChunk <- tryCatch({
  deps_pep_l_df$id<- psm_peptide_table[deps_pep_l_df$id, "GeneName"]
  #Perform enriched analysis with EnrichR
  enr_df<-enrichRfnc(deps_pep_l_df[which(deps_pep_l_df$comp %in% names(formule_CORAL)),], pval_fdr_enrich, pval_enrich_thr, overlap_size_enrich_thr)
  #Save in RData for possible further analysis
  save(enr_df, file=paste0(dirOutput,subfold_Dat,"DEPs_enrichment_data.RData"))

  writexl::write_xlsx((enr_df %>% dplyr::filter(`P<0.05` == "T",overlap_size>=overlap_size_enrich_thr)),
                      path = paste0(dirOutput,subfold_Tab,"DEPs_enrichment_table.xlsx"))

  dir.create(file.path(dirOutput,subfold_Fig,"enrich/"), showWarnings = FALSE)
  dirOutput_enr=paste0(dirOutput,subfold_Fig,"enrich/")
  TRUE
},
error=function(cond){
  print("\n ERROR: An error occur when connect to EnrichR. \n ")
  FALSE
})
message("Enrichment DONE.")
shiny::setProgress(0.77, detail = "Done Enrichment...")

```


```{r enrichment_plots, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk, results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  cat("#### 4.1. Enrichment of DEPs lists filtered by databases.\n")
  cat("The figure is done by the UP (up-regulated proteins) and the DOWN (down-regulated proteins) analysis. The graph visualizes only the significant enriched terms of the pre-selected data sets. \n")
  cat("The dimension of the point is given by the Odds Ratio in log2 scale. The filling is based on the significativity of the adj.P.Value against the selected threshold. \n")

  #Filter the DEPs taking only the ones from the desired DBs
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  `P<0.05` == "T",
                  !str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  #Select the results divided in up and down
  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk, results='hide'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  #Print the plot
  # col_vec<-color_base[sort(rep(c(1:length(color_base)),2))]
  # if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector(t(color_constrast[unique(str_remove(enr_sele_df$input_name, "_up\\b|_down\\b")),]))
  names(col_vec)<-unique(enr_sele_df$input_name)
  # }
  el<- enrichment_dotmatrix(enr_sele_df,
                           size_col="log2_OR",
                           color_col="input_name",
                           color_vec = col_vec,
                           # color_vec=color_base[sort(rep(c(1:length(color_base)),2))],
                           char_max=60)

  tryCatch({
    print(el +guides(color=F))
    message(paste0(dirOutput_enr,"enrichment_database_filter.pdf"))
    ggsave(paste0(dirOutput_enr,"enrichment_database_filter.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.77, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_all, echo=F, message=F, warning=F, eval = doNextChunk, results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
  cat("#### 4.2. Enrichment of DEPs lists filtered by databases.\n")
  cat("The figure is done by the ALL (join of up- and down-regulated proteins) analysis. The graph visualizes only the significant enriched terms of the pre-selected data sets. \n")
  cat(" The dimension of the point is given by the Odds Ratio in log2 scale. The filling is based on the significativity of the adj.P.Value against the selected threshold. \n")
  #Select DEPs in the DBs of interest
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  `P<0.05` == "T",
                  str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  #Select the ALL column (UP union DOWN)
  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk, results='hide'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_DBs) > 0){
    # col_vec<-color_base
    # if(length(as.vector(t(color_constrast)))>0){
    col_vec<-as.vector((color_constrast[unique(str_remove(enr_sele_df$input_name, "_all\\b")),"color_constrast"]))
    names(col_vec)<-unique(enr_sele_df$input_name)
    # }
    el<- enrichment_dotmatrix(enr_sele_df,
                           size_col="log2_OR",
                           color_col="input_name",
                           color_vec=col_vec,
                           char_max=60)

  tryCatch({
    print(el +guides(color=F))
    ggsave(paste0(dirOutput_enr,"enrichment_database_filter_all.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.79, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_terms, echo=F, message=F, warning=F, eval = doNextChunk, results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  cat("#### 4.3. Enrichment of DEPs lists filtered by key-words \n ")
  cat("The figure is done by the UP (up-regulated proteins) and the DOWN (down-regulated proteins) analysis. The graph visualizes only the significant enriched terms which contains the selected key-words. \n")
  cat(" The dimension of the point is given by the Odds Ratio in log2 scale. The filling is based on the significativity of the adj.P.Value against the selected threshold. \n")
  cat(" \n")
  cat("**List of terms to search:**")
  cat(" \n")
  cat(paste(enrich_filter_term, collapse=", "))

  lookup_words<-enrich_filter_term

  enr_sele_names<-NULL

  #For each patter we want, search in each DEPs name to find it
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(fdr<pval_enrich_thr,
                                        overlap_size>=overlap_size_enrich_thr,
                                        !str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  # write_tsv(enr_sele_df ,file=paste(dirOutput,dirOutput_ev,"enrich_myc_v1_all.txt",sep=""))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_terms_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk, results='hide'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  # col_vec<-color_base[sort(rep(c(1:length(color_base)),2))]
  # if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector(t(color_constrast[unique(str_remove(enr_sele_df$input_name, "_up\\b|_down\\b")),]))
  names(col_vec)<-unique(enr_sele_df$input_name)
  # }  
  el<- enrichment_dotmatrix(enr_sele_df,
                         size_col="log2_OR",
                         color_col="input_name",
                         color_vec = col_vec,
                         # color_vec=color_base[sort(rep(c(1:length(color_base)),2))],
                         char_max=60) + guides(color=F)
  tryCatch({
    print(el)

    ggsave(paste0(dirOutput_enr,"enrichment_term_filter.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })

}

shiny::setProgress(0.82, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_all_terms, echo=F, message=F, warning=F, eval = doNextChunk, results='asis'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  cat("#### 4.4. Enrichment of DEPs lists filtered by key-words. \n")
  cat("The figure is done by the ALL (join of up- and down-regulated proteins) analysis. The graph visualizes only the significant enriched terms which contains the selected key-words. \n")
  cat(" The dimension of the point is given by the Odds Ratio in log2 scale. The filling is based on the significativity of the adj.P.Value against the selected threshold. \n")
  cat(" \n")
  cat("**List of terms to search:**")
  cat(" \n")
  cat(paste(enrich_filter_term, collapse=", "))

  lookup_words<-enrich_filter_term

  enr_sele_names<-NULL
  #For each pattern search in DEPs name
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(fdr<pval_enrich_thr,
                                        overlap_size>=overlap_size_enrich_thr,
                                        str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  # write_tsv(enr_sele_df ,file=paste(dirOutput,dirOutput_ev,"enrich_myc_v1_all.txt",sep=""))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_terms_2, echo=F, message=FALSE, warning=FALSE, eval = doNextChunk, results='hide'}
if(run_enrich_universe){hide_res<-p$read_output()}

if(length(enrich_filter_term) > 0){
  # col_vec<-color_base
  #   if(length(as.vector(t(color_constrast)))>0){
    col_vec<-as.vector((color_constrast[unique(str_remove(enr_sele_df$input_name, "_all\\b")),"color_constrast"]))
  names(col_vec)<-unique(enr_sele_df$input_name)
    # }
  el<- enrichment_dotmatrix(enr_sele_df,
                         size_col="log2_OR",
                         color_col="input_name",
                         color_vec=col_vec,
                         char_max=60) + guides(color=F)

  tryCatch({
    print(el)

    ggsave(paste0(dirOutput_enr,"enrichment_term_filter_all.pdf"), el, device=cairo_pdf, width = 7, height =
             max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.85, detail = "Plotting enrichment results...")
```


```{r enrichment_universe_get, message=F, warning=F,echo=F, eval=run_enrich_universe, results='asis'}
shiny::setProgress(0.75, detail = "Enrichment in progress whole Universe in background... \n Can require several minutes...")

#Wait 10 minutes. If do not end in 10 minutes, kill the process
hide_res<-p$read_output()
p$wait(30000)
for (i in 1:10) {
  p$read_output()
  p$wait(1000*60)  
}

if(p$is_alive() | is.null(p$get_result())){
  p$kill()
  print("\n ERROR: An error occur when connect to EnrichR for the enrichemnt of the whole universe of the experiment. \n ")
  run_enrich_universe <- FALSE
} else{
  enr_df_universe<-p$get_result()
  p$kill()
  #Save in RData for possible further analysis
  save(enr_df_universe, file=paste0(dirOutput,subfold_Dat,"DEPs_enrichment_data_universe.RData"))

  writexl::write_xlsx((enr_df_universe %>% dplyr::filter(`P<0.05` == "T",overlap_size>=overlap_size_enrich_thr)),
                      path = paste0(dirOutput,subfold_Tab,"DEPs_enrichment_table_universe.xlsx"))

  dir.create(file.path(dirOutput,subfold_Fig,"enrich/"), showWarnings = FALSE)
  dirOutput_enr=paste0(dirOutput,subfold_Fig,"enrich/")
  message("Enrichment whole universe DONE.")
}
shiny::setProgress(0.75, detail = "Done Enrichment of universe...")

```

```{r enrichment_plots_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_DBs) > 0){
  cat("#### 4.5. Enrichment of DEPs lists filtered by databases compared to the whole experiment.\n")
  cat("The figure is done by the UP (up-regulated proteins) and the DOWN (down-regulated proteins) analysis. The graph visualizes only the significant enriched terms of the pre-selected data sets. \n")
  cat("The dimension of the point is given by the Odds Ratio in log2 scale. The filling is based on the significativity of the adj.P.Value against the selected threshold. \n")
  
  #Filter the DEPs taking only the ones from the desired DBs
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  `P<0.05` == "T",
                  !str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  #Select the results divided in up and down
  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='hide'}

if(length(enrich_filter_DBs) > 0){
  #Print the plot
  # col_vec<-color_base[sort(rep(c(1:length(color_base)),2))]
  # if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector(c(t(color_constrast[unique(str_remove(enr_sele_df$input_name, "_up\\b|_down\\b")),]), "grey30", "grey70"))
  # col_vec<-as.vector(c(t(color_constrast), "grey30", "grey70"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  # }
  el<- enrichment_dotmatrix(enr_sele_df,
                           size_col="log2_OR",
                           color_col="input_name",
                           color_vec = col_vec,
                           # color_vec=color_base[sort(rep(c(1:length(color_base)),2))],
                           char_max=60)

  tryCatch({
    print(el +guides(color=F))
    message(paste0(dirOutput_enr,"enrichment_database_filter_vsUniverse.pdf"))
    ggsave(paste0(dirOutput_enr,"enrichment_database_filter_vsUniverse.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.77, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_all_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_DBs) > 0){
  cat("#### 4.6. Enrichment of DEPs lists filtered by databases compared to whole experiment.\n")
  cat("The figure is done by the ALL (join of up- and down-regulated proteins) analysis. The graph visualizes only the significant enriched terms of the pre-selected data sets. \n")
  cat(" The dimension of the point is given by the Odds Ratio in log2 scale. The filling is based on the significativity of the adj.P.Value against the selected threshold. \n")
  #Select DEPs in the DBs of interest
  annos<- enrich_filter_DBs

  enr_sele_names <- enr_df %>%
    dplyr::filter(anno_class %in% annos,
                  overlap_size>=overlap_size_enrich_thr,
                  anno_size<=10000,
                  `P<0.05` == "T",
                  str_ends(input_name,"_all")) %>%
    dplyr::arrange(-overlap_size) %>% dplyr::group_by(input_name,anno_class) %>% slice_head(n=5) %>%
    ungroup() %>% dplyr::select(anno_class,anno_name)

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))

  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  #Select the ALL column (UP union DOWN)
  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='hide'}

if(length(enrich_filter_DBs) > 0){
    # col_vec<-color_base
    # if(length(as.vector(t(color_constrast)))>0){
    col_vec<-as.vector(c(na.omit(color_constrast[unique(str_remove(enr_sele_df$input_name, "_all\\b")),1]), "grey50"))
    # col_vec<-as.vector(c((color_constrast), "grey30", "grey70"))
    names(col_vec)<-unique(enr_sele_df$input_name)
    col_vec["Universe_all"]<-"grey50"
    # }
    el<- enrichment_dotmatrix(enr_sele_df,
                           size_col="log2_OR",
                           color_col="input_name",
                           color_vec=col_vec,
                           char_max=60)

  tryCatch({
    print(el +guides(color=F))
    ggsave(paste0(dirOutput_enr,"enrichment_database_filter_all_vsUniverse.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.79, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_terms_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_term) > 0){
  cat("#### 4.7. Enrichment of DEPs lists filtered by terms compared to whole experiment. \n ")
  cat("The figure is done by the UP (up-regulated proteins) and the DOWN (down-regulated proteins) analysis. The graph visualizes only the significant enriched terms which contains the selected key-words. \n")
  cat(" The dimension of the point is given by the Odds Ratio in log2 scale. The filling is based on the significativity of the adj.P.Value against the selected threshold. \n")
  cat(" \n")
  cat("**List of terms to search:**")
  cat(" \n")
  cat(paste(enrich_filter_term, collapse=", "))

  lookup_words<-enrich_filter_term

  enr_sele_names<-NULL

  #For each patter we want, search in each DEPs name to find it
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(`P<0.05` == "T",
                                        overlap_size>=overlap_size_enrich_thr,
                                        !str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  # write_tsv(enr_sele_df ,file=paste(dirOutput,dirOutput_ev,"enrich_myc_v1_all.txt",sep=""))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(!str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_terms_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='hide'}

if(length(enrich_filter_term) > 0){
  # col_vec<-color_base[sort(rep(c(1:length(color_base)),2))]
  # if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector(c(t(color_constrast[unique(str_remove(enr_sele_df$input_name, "_up\\b|_down\\b")),]), "grey30", "grey70"))
  # col_vec<-as.vector(c(t(color_constrast), "grey30", "grey70"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  # }  
  el<- enrichment_dotmatrix(enr_sele_df,
                         size_col="log2_OR",
                         color_col="input_name",
                         color_vec = col_vec,
                         # color_vec=color_base[sort(rep(c(1:length(color_base)),2))],
                         char_max=60) + guides(color=F)
  tryCatch({
    print(el)

    ggsave(paste0(dirOutput_enr,"enrichment_term_filter_vsUniverse.pdf"), el, device=cairo_pdf, width = 7, height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })

}

shiny::setProgress(0.82, detail = "Plotting enrichment results...")
```

```{r enrichment_plots_all_terms_vsUniverse, echo=F, message=F, warning=F, eval = (doNextChunk&run_enrich_universe), results='asis'}

if(length(enrich_filter_term) > 0){
  cat("#### 4.8. Enrichment of DEPs lists filtered by terms compared to the whole experiment. \n")
  cat("The figure is done by the ALL (join of up- and down-regulated proteins) analysis. The graph visualizes only the significant enriched terms which contains the selected key-words. \n")
  cat(" The dimension of the point is given by the Odds Ratio in log2 scale. The filling is based on the significativity of the adj.P.Value against the selected threshold. \n")
  cat(" \n")
  cat("**List of terms to search:**")
  cat(" \n")
  cat(paste(enrich_filter_term, collapse=", "))

  lookup_words<-enrich_filter_term

  enr_sele_names<-NULL
  #For each pattern search in DEPs name
  for(word in lookup_words){
    matches <- enr_df %>% dplyr::filter(`P<0.05` == "T",
                                        overlap_size>=overlap_size_enrich_thr,
                                        str_ends(input_name,"_all")) %>% dplyr::select(anno_class,anno_name)
    matches <- matches[grepl(paste0("\\b",word,"\\b"),matches$anno_name,ignore.case=TRUE),]
    enr_sele_names<-rbind(enr_sele_names,matches) %>% unique()
  }

  enr_sele_df<-suppressMessages(inner_join(enr_df,enr_sele_names))
  enr_sele_df <- rbind(enr_sele_df, suppressMessages(inner_join(enr_df_universe,enr_sele_names)))

  # write_tsv(enr_sele_df ,file=paste(dirOutput,dirOutput_ev,"enrich_myc_v1_all.txt",sep=""))

  enr_sele_df <- enr_sele_df %>% dplyr::filter(str_ends(input_name,"_all"))
  knitr::opts_chunk$set(fig.height = max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3))
}
```

```{r enrichment_plots_all_terms_2_vsUniverse, echo=F, message=FALSE, warning=FALSE, eval = (doNextChunk&run_enrich_universe), results='hide'}

if(length(enrich_filter_term) > 0){
  # col_vec<-color_base
  #   if(length(as.vector(t(color_constrast)))>0){
  col_vec<-as.vector(c(na.omit(color_constrast[unique(str_remove(enr_sele_df$input_name, "_all\\b")),1]), "grey50"))
  # col_vec<-as.vector(c((color_constrast), "grey30", "grey70"))
  names(col_vec)<-unique(enr_sele_df$input_name)
  col_vec["Universe_all"]<-"grey50"
    # }
  el<- enrichment_dotmatrix(enr_sele_df,
                         size_col="log2_OR",
                         color_col="input_name",
                         color_vec=col_vec,
                         char_max=60) + guides(color=F)

  tryCatch({
    print(el)

    ggsave(paste0(dirOutput_enr,"enrichment_term_filter_all_vsUniverse.pdf"), el, device=cairo_pdf, width = 7, height =
             max(min(20,length(unique(enr_sele_df$anno_name))*0.5),3), units = c("in"))
  },
  error=function(cond){
    print("Error: No enriched term found with current parameters\n")
  })
}

shiny::setProgress(0.85, detail = "Plotting enrichment results...")
```


```{r selection_genes, echo=F, message=F, warning=F, eval=run_STRING, results='asis'}
shiny::setProgress(0.82, detail = "Network analysis in progress... \n Can require several minutes...")
cat(" \n \n")
cat("## 5. Differetially Expressed Proteins in STRINGdb network \n")
cat("Protein-protein interactions (PPIs) is crucial for understanding cell physiology in different states. Also, knowledge from PPIs can be used (EMBL-EBI, 2022) for characterize unknown proteins, study pathways, characterize relationship between proteins. The pipeline uses [STRING](https://string-db.org/) to execute the PPI analysis. The database is prefilter removing the edges with low strength. The iteration searchs the interactions between DEPs in the database. Discovered all the connections, the clusters are identified. \n")
#Reset of height of plots
if(run_enrich){knitr::opts_chunk$set(fig.height = def_val_height)}

deps_l_df <- deps_pep_l_df[which(deps_pep_l_df$comp %in% names(formule_CORAL)),]
#Select up- down- regualted genes, if 0 genes are find, the all network analysis is skipped
g_sel_comp<-list()
doComp<-list()
for (comp in unique(deps_l_df$comp)){
  tmp_deps<-deps_l_df[(deps_l_df$class != "=" & deps_l_df$comp == comp), ]
  genes<-(tmp_deps[order(tmp_deps$p_val),])[1:min(500, nrow(tmp_deps)),"id"]
  if(length(genes)>0){g_sel_comp[[comp]]<-unique(vapply(str_split(genes, "_", n = 2), `[`, 1, FUN.VALUE=character(1)))}else{g_sel_comp[[comp]]<-list()}
  if(length(g_sel_comp[[comp]])!=0){doComp[comp]=TRUE}
}
if(length(doComp)==0 | all(doComp==F)){
  doNextChunk_STRING<-FALSE
  print("WARNING: Not possible to continue with the STRING network evaluation. No protein up- or down-regulated.\n")
}else{
  doNextChunk_STRING<-TRUE
  dir.create(file.path(dirOutput,subfold_Fig,"network/"), showWarnings = FALSE)
  dirOutput_net=paste0(dirOutput,subfold_Fig,"network/")
}

shiny::setProgress(0.84, detail = "Network analysis done... \n Can require several minutes...")
```

```{r network_string_communities, echo=F, message=F, warning=F, eval = doNextChunk_STRING, results='hide'}
message("Build PPI network with STRING in progress... \n Can require several minutes...")

rm(cluster_ext, cmd, comm, dat_psm,df_to_save,dt_links,edge_list,el,enr_sele_df,enr_sele_names, matches, mds_cmdscale, psm_anno_df, 
       sample_data, annos, colToKeep, comp, currentTime, dirOutput_1,dirOutput_2, doNextChunk,
       f, filenames, filt_genes, g_sel, genes, l, links, lookup_words, name_list, net_genes, now, res, sample_distances, word,
       batch_annotation,comBat_df_gene, comBat_df_pep, dat_gene_long,dat_pep_long,
       gene_name, input_df, pos, prot_intensity_long, deps_vec_all, i, labels, labels_down, labels_up, list.of.packages,
       list.of.packages.bio, new.packages, prot_find, template_files)
gc()
#Read STRINGdb edges for human
#Human id --> 9606
#Mouse id --> 10090
string_db <- STRINGdb$new(version="11.5", species=taxonomy_NCBI, score_threshold=600, input_directory="")
gene_name<-unlist(g_sel_comp) %>% unique() %>% as.data.frame()
colnames(gene_name)<-c("gene_id")
string_mapped <- string_db$map(gene_name, "gene_id", removeUnmappedRows = TRUE)
links_string <- string_db$get_interactions(string_mapped$STRING_id)
links_string$from <- string_mapped$gene_id[match(links_string$from,string_mapped$STRING_id)]
links_string$to <- string_mapped$gene_id[match(links_string$to,string_mapped$STRING_id)]
string_gene_df<-data_frame("gene1"=links_string$from,"gene2"=links_string$to,"weigth"=links_string$combined_score)

if(nrow(string_gene_df) > 0){
  # cat(" \n")
  # cat("#### 5.1. Number of proteins in each communities discovered \n")
  # cat("Each image is a different contrast analysis \n")
  data_comms_df<-list()
  data_comms_list<-list()
  data_dt_links<-list()
  colour_vector<-list()
  #Cycle for each contrast
  for (comp in names(doComp)){
    # params ----
    thr_score <- 150 # define max strength of interaction

    #Select genes that are up or down regulated
    g_sel <- g_sel_comp[[comp]]
    if(all(unique(!grepl("[[:lower:]]",string_gene_df$gene1)))){
      g_sel<-toupper(g_sel)
    }else{
      g_sel<-str_to_title(g_sel)
    }
    #Find communities in STRING db
    comm <- suppressMessages(find_communities(g_sel, thr_score,string_gene_df))
    i_comms_df <- comm[["i_comms_df"]]
    data_comms_df[[comp]]<-i_comms_df
    i_comms_list <- comm[["i_comms_list"]]
    data_comms_list[[comp]]<-i_comms_list
    dt_links <- comm[["dt_links"]]
    data_dt_links[[comp]]<-dt_links

    # colour_vector[[comp]] <- c(c(brewer.pal(n = 8, name = "Dark2")), "#680000", "#ae0001", "#eb8c00", "#680000", "#001080", "#999999", "#434343")
    colour_vector[[comp]] <- c(c(brewer.pal(n = 8, name = "Dark2")), color_base)
    colour_vector[[comp]] <- colour_vector[[comp]][1:length(i_comms_list)]

    cat("\n")
  }

  i_comms_df<-data_comms_df
  i_comms_list<-data_comms_list
  dt_links<-data_dt_links

  message("Network DONE.")
}else{
  print("WARNING: No strong interaction detected beetween the proteins. Usually too few proteins.")
  doNextChunk_STRING <- FALSE
  message("Network incomplete.")
}

shiny::setProgress(0.85, detail = "Generating network figures... \n Can require several minutes...")
```

```{r network_string, echo=F, message=F, warning=F, eval = doNextChunk_STRING, fig.width=12, results='asis'}
message("Plotting STRING network in progress...")
cat("#### 5.1. Number of proteins in each communities discovered  {.tabset}  \n")
cat("The bar plots below describe the communities discovered in each network. The heigth of the bar is the number of gene in that community. Each tab is a different contrast analysis. ")
cat(" \n \n")




for (comp in names(doComp)){
  scr_thr <-  200# visual
  links <- 2
  # Filter genes and links ----
  # net_genes <- toupper(g_sel_comp[[comp]])
  net_genes <- g_sel_comp[[comp]]
  if(all(unique(!grepl("[[:lower:]]",string_gene_df$gene1)))){
      net_genes<-toupper(net_genes)
    }else{
      net_genes<-str_to_title(net_genes)
    }
  net_edges <- subset(dt_links[[comp]], from%in%net_genes & to%in%net_genes) #select genes with weight>scr_thr
  net_edges<-net_edges[which(net_edges$weight > mean(net_edges$weight)*0.7),]

  gene_links<-table(c(net_edges$from,net_edges$to))
  filt_genes<-names(gene_links)[which(gene_links > links)] #select genes with link > links
  net_edges<-subset(net_edges,from %in% filt_genes & to %in% filt_genes)

  gene_links<-table(c(net_edges$from,net_edges$to))
  filt_genes<-names(gene_links)[which(gene_links >= 2)] #remove isolated genes (leaves)
  net_edges<-subset(net_edges,from %in% filt_genes & to %in% filt_genes)

  net_edges$group_to<-"PP"

  # Vertices df ----
  gene_vertices<-data.frame(label=filt_genes)
  if(nrow(gene_vertices) != 0){
    rownames(gene_vertices)<-gene_vertices$label

    gene_vertices$Community<-(i_comms_df[[comp]])[as.character(gene_vertices$label),"comm_n"] #class=communities
    #Set size bigger for genes in a community
    # gene_vertices$n_size<-1.5 #column that define the size of the dots
    # gene_vertices[which(is.na(gene_vertices$Community)),"n_size"]<-0.75
    # 
    # gene_vertices$type<-"A" # can be used for shape
    #gene_vertices[which(rownames(gene_vertices)%in%sma_genes),"type"]<-"B"

    nc<-ggplot(gene_vertices, aes(x=Community, fill=Community)) +
        geom_bar(alpha=0.9, colour="white", width=0.4)+
        scale_x_discrete(drop=FALSE)+
        scale_fill_manual(values=colour_vector[[comp]], drop=FALSE)+
        theme_bw(base_size = bs) +
        labs(x = "Community", y = "# genes") +
        theme(legend.position = "none", panel.grid.major.x = element_blank(),
              panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank())+
        ggtitle("Number of genes in each community", subtitle = paste0("Communities of condition: ",comp))

    cat("##### ",comp," \n")
    print(nc)
    cat(" \n \n")
    ggsave(paste0(dirOutput_net,comp,"_community_number_gene_filtered.pdf"), nc, device=cairo_pdf, width = 4, height = 4, units = c("in"))

    # plot with DiagrammeR----
    # net_net <- suppressMessages(fortify(as.edgedf(as.data.frame(net_edges)), gene_vertices))
    # uniqueN(net_net$from_id)
    # 
    # #BUILD NETWORK
    # node_list_from<-as.data.table(unique(net_net[,c("from_id")]))
    # node_list_to<-as.data.table(unique(net_net[,c("to_id")]))
    # colnames(node_list_from)<-"node"
    # colnames(node_list_to)<-"node"
    # node_list<-as.data.table(rbind((node_list_from),(node_list_to)))
    # node_list<-node_list[!duplicated(node_list$node)]
    # node_list[,id:=seq(1, nrow(node_list))]
    # node_list<-merge(node_list,net_net[,c("from_id","Community","n_size")],by.x="node",by.y="from_id")
    # 
    # node_list<-unique(node_list)
    # 
    # colnames(node_list)<-c("name","id","Community","size")
    # 
    # edge_list<-net_net[,c("from_id","to_id","weight")]
    # colnames(edge_list)<-c("from","to","weight")
    # edge_list<-as.data.table(edge_list)
    # edge_list<-na.omit(edge_list)
    # g <- graph_from_data_frame(edge_list, directed=TRUE, vertices=node_list)
    
    # layouts <- if(length(node_list$name) > 400){c("kk")}else{c("fr","kk")}
      
    tb = tibble(v = c(net_edges$from, net_edges$to))
    d = as.vector(table(tb$v))
    nodes = mutate(gene_vertices, Degree = d)
    
    g <- graph_from_data_frame(net_edges, directed=TRUE, vertices=nodes)
    
    layouts <- if(length(nodes$label) > 400){c("kk")}else{c("fr","kk")}
    p = callr::r_bg(
      func = function(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts) {
        source("functions_2021.R")
        plot_networks(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts)
      },
      args = list(g, scr_thr, bf, comp, colour_vector, bs, dirOutput_net, layouts),
      stdout = "|",
      stderr = "|",
      error = getOption("callr.error", "error")
    )
    
    p$wait()
    
    cat(" \n \n")
    rm(net_genes, net_edges, gene_links, filt_genes, net_edges, gene_vertices, nc, net_net, 
           node_list_from, node_list_to, node_list, edge_list, g, name_list, l_list)
    gc()
  }
}


cat("\n \n")
message("Networking with STRING DONE")
cat("\n \n")
cat("#### 5.2. Network plots \n ")
cat("\n \n Results inside folder: *network*")
cat("\n ")
cat("\n \n The network are not reported in this report since for each comparison are generated 2 figures since we use 2 layouts for the nodes. For each comparison a 2-page pdf file is created. \n")

message("Cleaning...")

shiny::setProgress(0.90, detail = "Network figures generated...")
```


```{r kinase_tree_CORAL, echo=F, message=T, warning=F, eval=run_kinaseTree, results='asis'}
shiny::setProgress(0.90, detail = "Kinase identification and Kinase draw in progress... \n Can require several minutes...")
cat(" \n \n")
cat("## 6. Kinase Trees  {.tabset}  \n")
cat("In this step PhosProTN study the kinase activity of the differential expressed phosphosite. The identification of the kinase is perfomed by [PhosR](https://github.com/PYangLab/PhosR) package (Kim et al. 2021), which provide a score of their activity based on the comparison formula provided. The activities of the kinases are saved in txt files inside the *KinaseTree* folder. \n \n Other than the numeric results, graphical kinase trees are generated using an adapted version of the webtool [CORAL](http://phanstiel-lab.med.unc.edu/CORAL/) (Metz K.S. et al. 2018). \n \n ")
cat((paste0("DISCLAIMER CORAL: The kinome tree plots generated by CORAL make use the data generated by",
                tags$a("Manning et al., Science, 2002",href="http://science.sciencemag.org/content/298/5600/1912.long", target="_blank"),
                " and are based on a figure generated by ",
                tags$a("Cell Signaling Technology",href="https://www.cellsignal.com/contents/science/protein-kinases-introduction/kinases", target="_blank"),
                ".")))
cat("\n \n Results inside folder: *KinaseTree*")
cat(" \n \n ")

dir.create(file.path(dirOutput,subfold_Fig,"kinaseTree/"), showWarnings = FALSE)
dirOutput_kinase=paste0(dirOutput,subfold_Fig,"kinaseTree/")

if(!run_enrich){deps_pep_l_df$id<- psm_peptide_table[deps_pep_l_df$id, "GeneName"]}

kinase_act_phosr_wrapper <- function(comparison) {
  oldwd<-getwd()
  source("functions_2021.R")
  library(PhosR)
  library(pheatmap)
  library(svgPanZoom)
  source("CORAL/global.R")
  source("server.R")
  svg<-kinase_act_phosr(dirOutput_kinase, formule_CORAL, comparison, dat_pep, deps_pep_l_df, psm_peptide_table, c_anno_phos, df)
  setwd(oldwd)
  svg
}

ncores <- min(detectCores()-2, length(names(formule_CORAL)))
res <- NULL
res <- mclapply(names(formule_CORAL), kinase_act_phosr_wrapper, mc.cores = ncores)
cat(" \n \n")
for(i in 1:length(res)){
  cat(" \n")
  cat(paste0("### ", stri_split_regex(str = res[[i]], pattern = "\\/|\\_kinase")[[1]][7], " \n \n "))
  cat(paste0("![](", res[[i]], ")"), "\n")
  # cat(knitr::include_graphics(res[[i]]))
  cat(" \n \n")
}

# svgPanZoom::svgPanZoom(res[1],viewBox = T,controlIconsEnabled=F)
# #RUN CORAL
# source("R/CORAL/global.R")

shiny::setProgress(0.95, detail = "Kinase analysis done...")
```

```{r save_df, echo=F, message=F, warning=F, results='hide'}

save(c_anno_phos,
     c_anno,
     color_constrast,
     dat_pep,
     dat_complete,
     psm_peptide_table,
     deps_pep_l_df,
     df,
     expr_avgse_pep_df,
     expr_avgse_complete_df,
     formule_CORAL,
     colour_vec,
     bf,
     bs,
     fc_thr, pval_thr, pval_enrich_thr, overlap_size_enrich_thr,
     file = paste0(dirOutput,subfold_Dat,"database_env_R.RData"))

remove(list = ls()[-1])
gc()

shiny::setProgress(1, detail = "Saving RData...")
```
